This is the experiment conducted to check the consistency of the
generated TPTP after commit a95148e7, right after implementing
"bottom-up" relativization (issue #34).

The TPTP was generated using the following command:

(compile-suo-kif :tptp t).

This will generate the output.tptp file out of Merge.kif and
Mid-Level-Ontology.kif (that were concatenated into
samples/mini-sumo.tptp).

Also, added the consistency check conjecture at the end of output.tptp:

fof(q,conjecture,$false).

Vampire was the run with

$ vampire --mode casc -m 90000 -t 5D output.tptp

Explanation for the arguments:
http://vprover.org/cav2013.pdf

-t 5D, -m 90000: timeout of 5 days, max memory usage 90 Gb.

-- mode casc: When one runs VAMPIRE on a problem, the default strategy
              of VAMPIRE is used.  This strategy was carefully
              selected to solve a reasonably large number of problems
              based on the statistics collected by running VAMPIRE on
              problems from the TPTP library.  However, it is
              important to understand that there is no single best
              strategy, so for solving hard problems using a single
              strategy is not a good idea. [...] Fortunately, VAMPIRE
              users do not have to understand all the parameters. One
              can use a special VAMPIRE mode, called the CASC mode and
              used as --mode casc, which mimics the strategies used at
              the last CASC competition [32]. In this mode, VAMPIRE
              will treat the input problem with a cocktail of
              strategies running them sequentially with various time
              limits.

(note: it is not clear if -t and -m override the limits set up by CASC
mode).

Vampire output is at vampire-output.txt.

E was run as:

$ eproof --tptp3-format suo-kif-consistency.tptp

E output is at e-output.txt

== Analysis of the proof provided by E, using IDV.

= Setup

To use IDV, download ServiceTools.tgz from TPTP.org, ajust the path on
the IDV utility. and execute ./idv e-output.txt.

If you a re-running E, remove the comments (lines starting with '#'),
since they confuse IDV.

= Analysis

While SUMO specifies:

(disjoint Collection SelfConnectedObject)

E was able to prove:

(not (disjoint Collection SelfConnectedObject))

as follows:

It used three branches.

[a2862]
# generated by SUO-KIF
(forall (?MEMBER ?TYPE ?GROUP)
 (=>
  (and (=>
        (and (instance ?GROUP Collection) (instance ?TYPE SetOrClass))
        (memberType ?GROUP ?TYPE))
       (=> (and (instance ?MEMBER Object) (instance ?GROUP Collection))
        (member ?MEMBER ?GROUP)))
  (instance ?MEMBER ?TYPE)))

# original from SUMO
(=>
  (and
    (memberType ?GROUP ?TYPE)
    (member ?MEMBER ?GROUP))
  (instance ?MEMBER ?TYPE))

[a7705]
(forall (?S ?O ?TOP)
 (=>
  (and (=>
        (and (instance ?TOP SelfConnectedObject)
             (instance ?O SelfConnectedObject))
        (top ?TOP ?O))
       (=>
        (and (instance ?S SelfConnectedObject)
             (instance ?O SelfConnectedObject))
        (side ?S ?O)))
  (not (=> (and (instance ?TOP Entity) (instance ?S Entity))
        (equal ?TOP ?S)))))

# original from SUMO:
(=>
  (and
    (top ?TOP ?O)
    (side ?S ?O))
  (not
    (equal ?TOP ?S)))

[a4449]
(forall (?CLASS2 ?CLASS1)
 (=>
  (=> (and (instance ?CLASS1 SetOrClass) (instance ?CLASS2 SetOrClass))
   (disjoint ?CLASS1 ?CLASS2))
  (forall (?INST)
   (not (and (instance ?INST ?CLASS1) (instance ?INST ?CLASS2))))))

# original from SUMO:
(=>
   (disjoint ?CLASS1 ?CLASS2)
   (forall (?INST)
     (not
       (and 
         (instance ?INST ?CLASS1)
         (instance ?INST ?CLASS2)))))

a) s_instance(X4,s_Collection)
b) s_instance(X1,s_SelfConnectedObject)
c) [a4449] => 
   ( ~ s_instance(X1,X2) | ~ s_instance(X1,X3) | ~ s_disjoint(X3,X2) )

from b) and c) we conclude that

d) ( ~ s_disjoint(X1,s_SelfConnectedObject) | ~ s_instance(X2,X1) )

from a) and d) we conclude that

~ s_disjoint(s_Collection,s_SelfConnectedObject)

>> This analysis is incomplete <<
