;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; comp.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *ancestry* *depth* *limit*                      *unifications* *inferences* *termination*                      *thing* *answer* *answers*                      alist traceexpressions)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfindp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfindp (p facts rules)  (compfindx 't p facts rules));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfindx;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfindx (*thing* p facts rules)  (let (alist *answer*)    (setq *unifications* 0)    (setq *inferences* 0)    (setq *termination* nil)    (setq alist (environment))    (when (compone p (list p) alist 0 nil facts rules) *answer*)))(defun compone (p pl al depth cont facts rules)  (setq *inferences* (1+ *inferences*))  (compcall p al depth)  (cond ((>= *inferences* *limit*)         (setq *termination* t)         (compstop (car pl) al depth))        ((>= depth *depth*)         (setq *termination* t)         (compstop (car pl) al depth))        (t (componeexp p pl al depth cont facts rules))))(defun componeexp (p pl al depth cont facts rules)  (cond ((atom p) (componeconstant p pl al depth cont facts rules))        ((eq (car p) 'not) (componeunprovable p pl al depth cont facts rules))        ((eq (car p) 'and) (componeand p pl al depth cont facts rules))        ((eq (car p) 'or) (componeor p pl al depth cont facts rules))        ((eq (car p) 'same) (componesame p pl al depth cont facts rules))        ((eq (car p) 'distinct) (componedistinct p pl al depth cont facts rules))        ((eq (car p) 'oneof) (componeoneof p pl al depth cont facts rules))        ((eq (car p) 'choose) (componechoose p pl al depth cont facts rules))        ((eq (car p) 'bagofall) (componebagofall p pl al depth cont facts rules))        ((eq (car p) 'unprovable) (componeunprovable p pl al depth cont facts rules))	((eq (car p) 'ground) (componeground p pl al depth cont facts rules))	((eq (car p) 'nonground) (componenonground p pl al depth cont facts rules))        ((eq (car p) 'execute) (componeexecute p pl al depth cont facts rules))        ((eq (car p) 'evaluate) (componeevaluate p pl al depth cont facts rules))        ((eq (car p) 'stringmatch) (componestringmatch p pl al depth cont facts rules))	((get (car p) 'basicval) (componebasicval p pl al depth cont facts rules))        ((get (car p) 'basic) (componebasic p pl al depth cont facts rules))        (t (componers p pl al depth cont facts rules))))(defun componeconstant (p pl al depth cont facts rules)  (cond ((eq 'true p) (componelast pl al depth cont facts rules))        ((eq 'false p) (compfail (car pl) al depth))        (t (componers p pl al depth cont facts rules))))(defun componeand (p pl al depth cont facts rules)  (cond ((null (cdr p)) (componelast pl al depth cont facts rules))        ((compone (cadr p) (cdr p) al depth (cons (list pl al depth) cont) facts rules))        (t (compfail (car pl) al depth))))(defun componeor (p pl al depth cont facts rules)  (setq cont (cons (list pl al depth) cont))  (do ((l (cdr p) (cdr l)))      ((null l) (compfail (car pl) al depth))      (when (compone (car l) (list (car l)) al depth cont facts rules)        (return t))))(defun componesame (p pl al depth cont facts rules)  (let (ol)    (cond ((setq ol (unify (cadr p) al (caddr p) al))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun componedistinct (p pl al depth cont facts rules)  (let (ol)    (cond ((setq ol (unify (cadr p) al (caddr p) al))           (backup ol) (compfail (car pl) al depth))          (t (componelast pl al depth cont facts rules)))))(defun componeoneof (p pl al depth cont facts rules)  (when (seqvarp (caddr p)) (setq p (plug p al)))  (do ((l (cddr p) (cdr l)) (ol))      ((null l) (compfail (car pl) al depth))      (cond ((not (setq ol (unify (cadr p) al (car l) al))))            ((componeexit pl al depth cont facts rules) (backup ol) (return t))            (t (backup ol)))))(defun componechoose (p pl al depth cont facts rules)  (let (x ol)    (setq p (plugstdexp p al))    (setq x (compfindx (cadr p) (caddr p) facts rules))    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun componebagofall (p pl al depth cont facts rules)  (let (answer ol)    (setq p (plug p al))    (setq answer (cons 'listof (compfinds (cadr p) (caddr p) facts rules)))    (cond ((setq ol (unify answer al (cadddr p) al))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun componeunprovable (p pl al depth cont facts rules)  (cond ((compone (cadr p) (cdr p) al depth nil facts rules)         (compfail (car pl) al depth))        (t (componelast pl al depth cont facts rules))))(defun componeground (p pl al depth cont facts rules)  (cond ((and (groundp (plug (cadr p) al)))         (componelast pl al depth cont facts rules))        (t (compfail (car pl) al depth))))(defun componenonground (p pl al depth cont facts rules)  (cond ((groundp (plug (cadr p) al))         (compfail (car pl) al depth))        (t (componelast pl al depth cont facts rules))))(defun componeexecute (p pl al depth cont facts rules)  (let (values ol)    (setq p (plug p al))    (cond ((null (cddr p))           (cond ((ignore-errors (eval (cadr p)))                  (componelast pl al depth cont facts rules))                 (t (compfail (car pl) al depth))))          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun componeevaluate (p pl al depth cont facts rules)  (let (values ol)    (setq p (plug p al))    (cond ((null (cddr p))           (cond ((compevals (cadr p)) (componelast pl al depth cont facts rules))                 (t (compfail (car pl) al depth))))          ((and (car (setq values (compevals (cadr p))))                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compevals (x)  (cond ((atom x) (ignore-errors (list (eval x))))        (t (ignore-errors (multiple-value-list (apply (car x) (cdr x)))))))(defun componestringmatch (p pl al depth cont facts rules)  (componeexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont facts rules))(defun componebasicval (p pl al depth cont facts rules)  (let (x y ol)    (setq p (plug p al) x (butlast p) y (car (last p)))    (cond ((not (groundp x)) (compfail (car pl) al depth))          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))           (prog1 (componelast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun componebasic (p pl al depth cont facts rules)  (setq p (plug p al))  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p)))         (componelast pl al depth cont facts rules))        (t (compfail (car pl) al depth))))(defun componers (p pl al depth cont facts rules)  (cond ((and *ancestry* (componeancestor p al cont)) (compfail (car pl) al depth))        ((componeth p pl al depth cont facts rules))        ((componedb p pl al depth cont facts rules))        (t (compfail (car pl) al depth))))(defun componeancestor (p al cont)  (do ((l (cdr cont) (cdr l)))      ((null l) nil)      (if (identify (caaar l) (cadar l) p al) (return t))))(defun componeth (p pl al depth cont facts rules)  (do ((l (envindexps p al facts) (cdr l)) (bl (environment)) (ol))      ((null l))      (cond ((setq ol (unify (car l) bl p al))             (cond ((componeexit pl al depth cont facts rules) (backup ol) (return t))                   ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol)))))))(defun componedb (p pl al depth cont facts rules)  (do ((l (envindexps p al rules) (cdr l)) (bl (environment)) (ol))      ((null l))      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))             (cond ((not (setq ol (unify (cadar l) bl p al))))                   ((componeexit pl al depth cont facts rules) (backup ol) (return t))                   ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol))))            ((and (listp (car l)) (eq '<= (caar l)))             (cond ((not (setq ol (unify (cadar l) bl p al))))                   ((compone (caddar l) (cddar l) bl                             (1+ depth) (cons (list pl al depth) cont) facts rules)                    (backup ol) (return  t))                   (t (backup ol))))            ((setq ol (unify (car l) bl p al))             (cond ((componeexit pl al depth cont facts rules) (backup ol) (return t))                   ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol)))))))(defun componeexit (pl al depth cont facts rules)  (let (ans)    (compexit (car pl) al depth)    (cond ((cdr pl) (setq ans (compone (cadr pl) (cdr pl) al depth cont facts rules)))          (cont (setq ans (componeexit (caar cont) (cadar cont) (caddar cont) (cdr cont) facts rules)))          (t (setq *answer* (plugstdexp *thing* alist) ans t)))    (if ans t (compredo (car pl) al depth))))(defun componelast (pl al depth cont facts rules)  (compexit (car pl) al depth)  (cond ((cdr pl) (compone (cadr pl) (cdr pl) al depth cont facts rules))        (cont (componeexit (caar cont) (cadar cont) (caddar cont) (cdr cont) facts rules))        (t (setq *answer* (plugstdexp *thing* alist)))))(defun compcall (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Call: | p) nil)))(defun compexit (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Exit: | p) nil)))(defun compredo (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Redo: | p) nil)))(defun compfail (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Fail: | p) nil)))(defun compstop (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Stop: | p) nil)))(defun compsave (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Save: | p) nil)))(defun compdrop (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Drop: | p) nil)))(defun compdone (p al depth)  (cond ((not traceexpressions) nil)        ((find (setq p (plugstdexp p al)) traceexpressions :test #'instp)         (tracemessage depth '|Done: | p) nil)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfinds;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfinds (*thing* p facts rules)  (let (alist *answers*)    (setq *unifications* 0)    (setq *inferences* 0)    (setq *termination* nil)    (setq alist (environment))    (compall p (list p) alist 0 nil facts rules)    (nreverse (uniquify *answers*))))(defun compall (p pl al depth cont facts rules)  (setq *inferences* (1+ *inferences*))  (compcall p al depth)  (cond ((>= *inferences* *limit*)         (setq *termination* t)         (compstop (car pl) al depth))        ((>= depth *depth*)         (setq *termination* t)         (compstop (car pl) al depth))        (t (compallexp p pl al depth cont facts rules))))(defun compallexp (p pl al depth cont facts rules)  (cond ((atom p) (compallconstant p pl al depth cont facts rules))        ((eq (car p) 'not) (compallunprovable p pl al depth cont facts rules))        ((eq (car p) 'and) (compalland p pl al depth cont facts rules))        ((eq (car p) 'or) (compallor p pl al depth cont facts rules))        ((eq (car p) 'same) (compallsame p pl al depth cont facts rules))        ((eq (car p) 'distinct) (compalldistinct p pl al depth cont facts rules))        ((eq (car p) 'oneof) (compalloneof p pl al depth cont facts rules))        ((eq (car p) 'choose) (compallchoose p pl al depth cont facts rules))        ((eq (car p) 'bagofall) (compallbagofall p pl al depth cont facts rules))        ((eq (car p) 'unprovable) (compallunprovable p pl al depth cont facts rules))	((eq (car p) 'ground) (compallground p pl al depth cont facts rules))	((eq (car p) 'nonground) (compallnonground p pl al depth cont facts rules))        ((eq (car p) 'execute) (compallexecute p pl al depth cont facts rules))        ((eq (car p) 'evaluate) (compallevaluate p pl al depth cont facts rules))        ((eq (car p) 'stringmatch) (compallstringmatch p pl al depth cont facts rules))	((get (car p) 'basicval) (compallbasicval p pl al depth cont facts rules))        ((get (car p) 'basic) (compallbasic p pl al depth cont facts rules))        (t (compallrs p pl al depth cont facts rules))))(defun compallconstant (p pl al depth cont facts rules)  (cond ((eq p 'true) (compalllast pl al depth cont facts rules))        ((eq p 'false) (compfail (car pl) al depth))        (t (compallrs p pl al depth cont facts rules))))(defun compalland (p pl al depth cont facts rules)  (cond ((null (cdr p)) (compalllast pl al depth cont facts rules))        ((compall (cadr p) (cdr p) al depth (cons (list pl al depth) cont) facts rules))        (t (compfail (car pl) al depth))))(defun compallor (p pl al depth cont facts rules)  (setq cont (cons (list pl al depth) cont))  (do ((l (cdr p) (cdr l)))      ((null l) (compfail (car pl) al depth))      (compall (car l) (list (car l)) al depth cont facts rules)))(defun compallsame (p pl al depth cont facts rules)  (let (ol)    (cond ((setq ol (unify (cadr p) al (caddr p) al))           (compalllast pl al depth cont facts rules)           (backup ol))          (t (compfail p al depth)))))(defun compalldistinct (p pl al depth cont facts rules)  (let (ol)    (cond ((setq ol (unify (cadr p) al (caddr p) al))           (backup ol) (compfail p al depth))          (t (compalllast pl al depth cont facts rules)))))(defun compalloneof (p pl al depth cont facts rules)  (when (seqvarp (caddr p)) (setq p (plug p al)))  (do ((l (cddr p) (cdr l)) (ol))      ((null l) (compfail (car pl) al depth))      (when (setq ol (unify (cadr p) al (car l) al))        (compallexit pl al depth cont facts rules)        (backup ol))))(defun compallchoose (p pl al depth cont facts rules)  (let (x ol)    (setq p (plugstdexp p al))    (setq x (compfindx (cadr p) (caddr p) facts rules))    (cond ((and (not (null x)) (setq ol (unify (cadddr p) alist x alist)))           (prog1 (compallexit pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compallbagofall (p pl al depth cont facts rules)  (let (answer ol)    (setq p (plug p al))    (setq answer (cons 'listof (compfinds (cadr p) (caddr p) facts rules)))    (cond ((setq ol (unify answer al (cadddr p) al))           (prog1 (compalllast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compallunprovable (p pl al depth cont facts rules)  (cond ((compone (cadr p) (cdr p) al depth nil facts rules) (compfail (car pl) al depth))        (t (compalllast pl al depth cont facts rules))))(defun compallground (p pl al depth cont facts rules)  (setq p (plug p al))  (if (groundp p) (compallexit pl al depth cont facts rules)))(defun compallnonground (p pl al depth cont facts rules)  (setq p (plug p al))  (if (groundp p) nil (compallexit pl al depth cont facts rules)))(defun compallexecute (p pl al depth cont facts rules)  (let (values ol)    (setq p (plug p al))    (cond ((null (cddr p))           (cond ((ignore-errors (eval (cadr p))) (compallexit pl al depth cont facts rules))                 (t (compfail (car pl) al depth))))          ((and (car (setq values (ignore-errors (multiple-value-list (eval (cadr p))))))                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,(mapcar #'quotify values)) al)))           (prog1 (compallexit pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compallevaluate (p pl al depth cont facts rules)  (let (values ol)    (setq p (plug p al))    (cond ((null (cddr p))           (cond ((compevals (cadr p)) (compallexit pl al depth cont facts rules))                 (t (compfail (car pl) al depth))))          ((and (car (setq values (compevals (cadr p))))                (setq ol (matchify `(listof . ,(cddr p)) al `(listof . ,values) al)))           (prog1 (compallexit pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compallstringmatch (p pl al depth cont facts rules)  (compallexp `(execute (stringmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) pl al depth cont facts rules))(defun compallbasicval (p pl al depth cont facts rules)  (let (x y ol)    (setq p (plug p al) x (butlast p) y (car (last p)))    (cond ((not (groundp x)) (compfail (car pl) al depth))          ((setq ol (unify (funcall (get (car x) 'basicval) x) al y al))           (prog1 (compalllast pl al depth cont facts rules) (backup ol)))          (t (compfail (car pl) al depth)))))(defun compallbasic (p pl al depth cont facts rules)  (setq p (plug p al))  (cond ((and (groundp p) (apply (get (car p) 'basic) (cdr p))              (compallexit pl al depth cont facts rules)))        (t (compfail (car pl) al depth))))(defun compallrs (p pl al depth cont facts rules)  (cond ((and *ancestry* (compallancestor p al cont)) (compfail (car pl) al depth))        ((and (numberp *ancestry*) (compallnumber p al cont 0))         (setq *termination* t) (compfail (car pl) al depth))        ((compallth p pl al depth cont facts rules))        ((compalldb p pl al depth cont facts rules))        (t (compfail (car pl) al depth))))(defun compallancestor (p al cont)  (do ((l cont (cdr l)))      ((null l) nil)      (if (identify (caaar l) (cadar l) p al) (return t))))(defun compallnumber (p al cont n)  (let (ol)    (cond ((numgeqp n *ancestry*))          ((null cont) nil)          ((atom p)           (compallnumber p al (cdr cont) (if (eq p (caaar cont)) (1+ n) n)))          ((setq ol (unify p al (caaar cont) (cadar cont)))           (prog1 (compallnumber p al (cdr cont) (1+ n)) (backup ol)))          (t (compallnumber p al (cdr cont) n)))))(defun compallth (p pl al depth cont facts rules)  (do ((l (envindexps p al facts) (cdr l)) (bl (environment)) (ol))      ((null l))      (cond ((setq ol (unify (car l) bl p al))             (compallexit pl al depth cont facts rules)             (cond ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol)))))))(defun compalldb (p pl al depth cont facts rules)  (do ((l (envindexps p al rules) (cdr l)) (bl (environment)) (ol))      ((null l))      (cond ((and (listp (car l)) (eq '<= (caar l)) (null (cddar l)))             (when (setq ol (unify (cadar l) bl p al))               (compallexit pl al depth cont facts rules)               (cond ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol)))))            ((and (listp (car l)) (eq '<= (caar l)))             (when (setq ol (unify (cadar l) bl p al))               (compall (caddar l) (cddar l) bl                        (1+ depth) (cons (list pl al depth) cont) facts rules)               (backup ol)))            ((setq ol (unify (car l) bl p al))             (compallexit pl al depth cont facts rules)             (cond ((subolp ol (alist bl)) (backup ol) (return nil))                   (t (backup ol)))))))(defun compallexit (pl al depth cont facts rules)  (compexit (car pl) al depth)  (cond ((cdr pl) (compall (cadr pl) (cdr pl) al depth cont facts rules))        (cont (compallexit (caar cont) (cadar cont) (caddar cont) (cdr cont) facts rules))        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*))))  (compredo (car pl) al depth))(defun compalllast (pl al depth cont facts rules)  (compexit (car pl) al depth)  (cond ((cdr pl) (compall (cadr pl) (cdr pl) al depth cont facts rules))        (cont (compallexit (caar cont) (cadar cont) (caddar cont) (cdr cont) facts rules))        (t (setq *answers* (cons (plugstdexp *thing* alist) *answers*)) nil)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;