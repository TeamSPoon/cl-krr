//------------------------------------------------------------------------------
// residue// residues//------------------------------------------------------------------------------// Notes:
//   current version assumes query is ground
//   current version does not use facts
//   current version does not do not
//   current version assumes global variable primitives
//   current version does not do consistency check
//------------------------------------------------------------------------------var primitives = seq();
function residue (query,facts,rules) {answer = false;  resone(query,seq(),nil,seq(),facts,rules);
  return answer}function residues (query,facts,rules) {answers = seq();  resall(query,seq(),nil,seq(),facts,rules);  return uniquify(answers)}//------------------------------------------------------------------------------function resone (p,pl,al,rl,facts,rules) {if (epitrace) {alert(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return resoneatom(p,pl,al,rl,facts,rules)}  if (p[0] == 'same') {return resonesame(p,pl,al,facts,rules)}  if (p[0] == 'distinct') {return resonedistinct(p,pl,al,facts,rules)}  if (p[0] == 'matches') {return resonematches(p,pl,al,facts,rules)}  //if (p[0] == 'not') {return resonenot(p,pl,al,facts,rules)}  if (p[0] == 'and') {return resoneand(p,pl,al,facts,rules)}  if (p[0] == 'or') {return resoneor(p,pl,al,facts,rules)}  if (findq(operator(p),primitives))
     {return resoneexit(pl,al,adjoin(p,rl),facts,rules)};  //if (resonebackground(p,pl,al,rl,facts,rules)) {return true};  return resoners(p,pl,al,rl,facts,rules)}function resoneatom (p,pl,al,rl,facts,rules) {if (p == 'true') {return resoneexit(pl,al,rl,facts,rules)};  if (p == 'false') {return false};  return resoners(p,pl,al,rl,facts,rules)}function resonesame (p,pl,al,rl,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {return resoneexit(pl,al,rl,facts,rules)};  return false}function resonedistinct (p,pl,al,rl,facts,rules) {if (unify(p[1],p[2],al) == false) {return resoneexit(pl,al,rl,facts,rules)};  return false}function resonematches (p,pl,al,rl,facts,rules) {if (symbolp(p[1]))     {var matches = p[1].match(p[2]);      for (var i=0; i<matches.length; i++)          {var bl = unify(p[3],matches[i],al);           if (bl != false && resoneexit(pl,bl,rl,facts,rules))              {return true}}}  return false}function resonenot (p,pl,al,facts,rules) {if (resone(p[1],seq(),al,facts,rules) == false) {return resoneexit(pl,al,facts,rules)}  return false}function resoneand (p,pl,al,rl,facts,rules) {return resoneexit(concatenate(tail(p),pl),al,rl,facts,rules)}function resoneor (p,pl,al,rl,facts,rules) {var bl;  for (var i=1; i<p.length; i++)      {if (resone(p[i],pl,al,rl,facts,rules)) {return true}}  return false}function resonebackground (p,pl,al,rl,facts,rules) {var bl;  var data = envindexps(p,al,facts);  for (var i=0; i<data.length; i++)      {bl = unify(data[i],p,al);       if (bl != false && resoneexit(pl,bl,rl,facts,rules)) {return true}};  return false}function resoners (p,pl,al,rl,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && resone(copy[2],concatenate(copy.slice(3),pl),bl,rl,facts,rules))              {return true}}          else {bl = unify(copy,p,al);                if (bl != false && resoneexit(pl,bl,rl,facts,rules))                   {return true}}};  return false}function resoneexit (pl,al,rl,facts,rules) {if (pl.length != 0) {return resone(pl[0],tail(pl),al,rl,facts,rules)};  answer = plug(rl,al);  return true}//------------------------------------------------------------------------------function resall (p,pl,al,rl,facts,rules) {if (epitrace) {alert(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return resallatom(p,pl,al,rl,facts,rules)}  if (p[0] == 'same') {return resallsame(p,pl,al,facts,rules)}  if (p[0] == 'distinct') {return resalldistinct(p,pl,al,facts,rules)}  if (p[0] == 'matches') {return resallmatches(p,pl,al,facts,rules)}  //if (p[0] == 'not') {return resallnot(p,pl,al,facts,rules)}  if (p[0] == 'and') {return resalland(p,pl,al,facts,rules)}  if (p[0] == 'or') {return resallor(p,pl,al,facts,rules)}  if (findq(operator(p),primitives))
     {return resallexit(pl,al,adjoin(p,rl),facts,rules)};  //resallbackground(p,pl,al,rl,facts,rules);  return resallrs(p,pl,al,rl,facts,rules)}function resallatom (p,pl,al,rl,facts,rules) {if (p == 'true') {return resallexit(pl,al,rl,facts,rules)};  if (p == 'false') {return false};  return resallrs(p,pl,al,rl,facts,rules)}function resallsame (p,pl,al,rl,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {resallexit(pl,al,rl,facts,rules)}}function resalldistinct (p,pl,al,rl,facts,rules) {if (unify(p[1],p[2],al) == false) {resallexit(pl,al,rl,facts,rules)}}function resallmatches (p,pl,al,rl,facts,rules) {if (symbolp(p[1]))     {var matches = p[1].match(p[2]);      for (var i=0; i<matches.length; i++)          {var bl = unify(p[3],matches[i],al);           if (bl != false) {resallexit(pl,bl,rl,facts,rules)}}}  return false}function resallnot (p,pl,al,facts,rules) {if (resone(p[1],seq(),al,facts,rules) == false) {resallexit(pl,al,facts,rules)}}function resalland (p,pl,al,rl,facts,rules) {resallexit(concatenate(tail(p),pl),al,rl,facts,rules)}function resallor (p,pl,al,rl,facts,rules) {for (var i=0; i<p.length; i++) {resall(p[i],pl,al,rl,facts,rules)}}function resallbackground (p,pl,al,rl,facts,rules) {var data = envindexps(p,al,facts);  for (var i=0; i<data.length; i++)      {var bl = match(p,data[i],al);       if (bl != false) {resallexit(pl,bl,rl,facts,rules)}}}function resallrs (p,pl,al,rl,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false) {resall(copy[2],concatenate(copy.slice(3),pl),bl,rl,facts,rules)}}       else {bl = unify(copy,p,al);             if (bl != false) {resallexit(pl,bl,rl,facts,rules)}}}}function resallexit (pl,bl,rl,facts,rules) {if (pl.length != 0) {return resall(pl[0],tail(pl),bl,rl,facts,rules)};  answers.push(plug(rl,bl));
  return false}

//------------------------------------------------------------------------------// test
//------------------------------------------------------------------------------prims = seq('p');
rules = seq(read('r(X) :- p(X,Y) & q(Y)'), read('q(b)'));
query = read('r(a)');//------------------------------------------------------------------------------//------------------------------------------------------------------------------//------------------------------------------------------------------------------