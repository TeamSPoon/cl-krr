//------------------------------------------------------------------------------// findval//------------------------------------------------------------------------------function findval (query) {if (symbolp(query)) {return findvalsymbol(query)};  if (query[0] == 'and') {return findvaland(query)};  if (query[0] == 'or') {return findvalor(query)};  if (query[0] == 'if') {return findvalif(query[1],query[2],query[3])};  if (query[0] == 'cases') {return findvalcases(query)};  var args = seq();  for (var i=1; i<query.length; i++) {args[i] = findval(query[i])};  return findvalcall(query[0],args)}function findvalsymbol (query) {if (query == 'true') {return 'true'};  if (findq(query,inputs)) {return findinputvalue(query)};  if (findq(query,outputs)) {return findoutputvalue(query)};  return query}function findinputvalue (cellname) {var cell = document.getElementById(cellname);  return cell.options[cell.selectedIndex].dbval}function findoutputvalue (cellname) {for (var i=0; i<definitions.length; i++)      {if (definitions[i][1] == cellname) {return findval(definitions[i][2])}};  return false}function findvaland (query) {for (var i=1; i<query.length; i++)      {if (findval(query[i]) == false) {return false}};  return true}function findvalor (query) {for (var i=1; i<query.length; i++)      {if (findval(query[i]) == true) {return true}};  return false}function findvalif (p,x,y) {if (findval(p) == true) {return findval(x)} else {return findval(y)}}function findvalcases (query) {for (var i=1; i<query.length; i=i+2)      {if (i == query.length-1) {return findval(query[i])};       if (findval(query[i]) == true) {return findval(query[i+1])}}  return false}function findvalcall (fun,args) {if (fun == 'same') {if (args[1]==args[2]) {return true} else {return false}};  if (fun == 'distinct') {if (args[1]!=args[2]) {return true} else {return false}};  args[0] = fun;  return args}function head (p) {if (symbolp(p)) {return p};  if (p[0] == 'not') {return head(p[1])};  return p[0]}

//------------------------------------------------------------------------------// matcher//------------------------------------------------------------------------------function matcher (x,y) {return match(x,y,nil)}function match (x,y,bl) {if (x == y) {return bl};  if (varp(x)) {return matchvar(x,y,bl)};  if (symbolp(x)) {return false};  return matchexp(x,y,bl)}function matchvar (x,y,bl) {var dum = assoc(x,bl);  if (dum != false) {return match(cdr(dum),y,bl)};  if (x == matchval(y,bl)) {return bl};  return acons(x,y,bl)}function matchval (y,bl) {if (varp(y))     {var dum = assoc(y,bl);      if (dum != false) {return matchval(cdr(dum),bl)};      return y};  return y}function matchexp(x,y,bl) {if (symbolp(y)) {return false};  var m = x.length;  var n = y.length;    if (m != n) {return false};  for (var i=0; i<m; i++)      {bl = match(x[i],y[i],bl);       if (bl == false) {return false}};  return bl}//------------------------------------------------------------------------------// Unification
//------------------------------------------------------------------------------function unifier (x,y) {return unify(x,y,nil)}function unify (x,y,bl) {if (x == y) {return bl};  if (varp(x)) {return unifyvar(x,y,bl)};  if (symbolp(x)) {return unifyatom(x,y,bl)};  return unifyexp(x,y,bl)}function unifyvar (x,y,bl) {var dum = assoc(x,bl);  if (dum != false) {return unify(cdr(dum),y,bl)};  if (x == unifyval(y,bl)) {return bl};  return acons(x,y,bl)}function unifyval (y,bl) {if (varp(y))     {var dum = assoc(y,bl);      if (dum != false) {return unifyval(cdr(dum),bl)};      return y};  return y}function unifyatom (x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)} else return false}function unifyexp(x,y,bl) {if (varp(y)) {return unifyvar(y,x,bl)}  if (symbolp(y)) {return false};  if (x.length != y.length) {return false};  for (var i=0; i<x.length; i++)      {bl = unify(x[i],y[i],bl);       if (bl == false) {return false}};  return bl}

//------------------------------------------------------------------------------// Plugging
//------------------------------------------------------------------------------

function plug (x,bl) {if (varp(x)) {return plugvar(x,bl)};  if (symbolp(x)) {return x};  return plugexp(x,bl)}function plugvar (x,bl) {var dum = assoc(x,bl);  if (dum == false) {return x};  return plug(cdr(dum),bl)}function plugexp (x,bl) {var exp = new Array(x.length);  for (var i=0; i<x.length; i++)      {exp[i] = plug(x[i],bl)};  return exp}var alist;function standardize (x) {alist = nil;  return standardizeit(x)}function standardizeit (x) {if (varp(x)) {return standardizevar(x)};  if (symbolp(x)) {return x};  return standardizeexp(x)}function standardizevar (x) {var dum = assoc(x,alist);  if (dum != false) {return cdr(dum)};  var rep = newvar();  alist = acons(x,rep,alist);  return rep}function standardizeexp (x) {var exp = new Array(x.length);  for (var i=0; i<x.length; i++)      {exp[i] = standardizeit(x[i])};  return exp}

//------------------------------------------------------------------------------
function allsafep (s) {for (var i=0; i<s.length; i++)      {if (!safep(s[i])) {alert(grind(s[i])); return false}};  return true}
//------------------------------------------------------------------------------// compfindp// compfindx// compfinds// sortfinds//------------------------------------------------------------------------------function compfindp (query,facts,rules) {return compfindx('true',query,facts,rules)}function compfindx (result,query,facts,rules) {thing = result;  answer = false;  if (compone(query,seq(),seq(),nil,facts,rules)) {return answer};  return false}function compfinds (result,query,facts,rules) {thing = result;  answers = seq();  compall(query,seq(),seq(),nil,facts,rules);  return uniquify(answers)}

function compfindn (m,n,result,query,facts,rules)
 {var results = compfinds(result,query,facts,rules);
  if (results.length>=n) {return results.slice(m,n)};
  if (results.length>=m) {return results.slice(m)};
  return seq()}

function sortfinds (result,query,facts,rules) {thing = result;  answers = seq();  compall(query,seq(),seq(),nil,facts,rules);  return vniquify(answers)}//------------------------------------------------------------------------------

function compone (p,pl,al,cont,facts,rules) {if (epitrace) {console.log(grind(pluug(p,al,al)) + '-' + pl + '-' + al)};
  inferences = inferences + 1;  if (symbolp(p)) {return componeatom(p,pl,al,cont,facts,rules)}  if (p[0] == 'same') {return componesame(p,pl,al,cont,facts,rules)}  if (p[0] == 'distinct') {return componedistinct(p,pl,al,cont,facts,rules)}  if (p[0] == 'matches') {return componematches(p,pl,al,cont,facts,rules)}  if (p[0] == 'plus') {return componeplus(p,pl,al,cont,facts,rules)}  if (p[0] == 'times') {return componetimes(p,pl,al,cont,facts,rules)}  if (p[0] == 'min') {return componemin(p,pl,al,cont,facts,rules)}  //if (p[0] == 'bagofall') {return componebagofall(p,pl,al,cont,facts,rules)}  if (p[0] == 'not') {return componenot(p,pl,al,cont,facts,rules)}  if (p[0] == 'and') {return componeand(p,pl,al,cont,facts,rules)}  if (p[0] == 'or') {return componeor(p,pl,al,cont,facts,rules)}  if (componebackground(p,pl,al,cont,facts,rules)) {return true};  return componers(p,pl,al,cont,facts,rules)}function componeatom (p,pl,al,cont,facts,rules) {if (p == 'true') {return componeexit(pl,al,cont,facts,rules)};  if (p == 'false') {return false};  return componers(p,pl,al,cont,facts,rules)}function componesame (p,pl,al,cont,facts,rules) {var ol = seq();  if (vnifyp(p[1],al,p[2],al,ol)) {return componeexit(pl,al,cont,facts,rules)};  backup(ol);  return false}function componedistinct (p,pl,al,cont,facts,rules) {var ol = seq();  if (vnifyp(p[1],al,p[2],al,ol)) {backup(ol); return false};  return componeexit(pl,al,cont,facts,rules)}function componematches (p,pl,al,cont,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var ol = seq();               if (vnifyp(p[3],al,matches[i],al,ol))                  {if (componeexit(pl,al,cont,facts,rules))                      {backup(ol); return true}}}}};  return false}function componeplus (p,pl,al,cont,facts,rules) {var total=0;
  for (var i=1; i<p.length-1; i++)
      {var arg = pluug(p[i],al,al);
       if (arg=='true') {total += 1}
          else {arg=parseFloat(arg);
                if (!isNaN(arg)) {total += arg}}};
  total = total+'';
  var ol = seq();  if (vnify(p[p.length-1],al,total,al,ol))
     {if (componeexit(pl,al,cont,facts,rules))         {backup(ol); return true}};
  return false}function componetimes (p,pl,al,cont,facts,rules) {var result=1;
  for (var i=1; i<p.length-1; i++)
      {var arg = pluug(p[i],al,al);
       if (arg!='true')
          {arg=parseFloat(arg);
           if (isNaN(arg)) {result = 0}
              else {result = result * arg}}};
  result = result + '';  var ol = seq();  if (vnify(p[p.length-1],al,result,al,ol))
     {if (componeexit(pl,al,cont,facts,rules))         {backup(ol); return true}};
  return false}function componemin (p,pl,al,cont,facts,rules) {var min = 0;
  var arg = parseFloat(pluug(p[1],al,al));
  if (!isNaN(arg)) {min = arg};
  for (var i=2; i<p.length-1; i++)
      {var arg = parseFloat(pluug(p[i],al,al));
       if (isNaN(arg)) {arg = 0};
       if (arg<min) {min = arg}};
  min = min+'';  var ol = seq();  if (vnify(p[p.length-1],al,min,al,ol))
     {if (componeexit(pl,al,cont,facts,rules))         {backup(ol); return true}};
  return false}function componebagofall (p,pl,al,cont,facts,rules) {p = pluug(p,al,al);
  var ol = seq();
  var result = seq('listof').concat(compfinds(p[1],p[2],facts,rules));
  if (vnifyp(p[3],al,result,al,ol))
     {if (componeexit(pl,al,cont,facts,rules))         {backup(ol); return true}};  return false}

function componenot (p,pl,al,cont,facts,rules) {if (!compone(p[1],seq(),al,nil,facts,rules))     {return componeexit(pl,al,cont,facts,rules)};  return false}function componeand (p,pl,al,cont,facts,rules) {return componeexit(concatenate(tail(p),pl),al,cont,facts,rules)}function componeor (p,pl,al,cont,facts,rules) {for (var i=0; i<p.length; i++)      {if (compone(p[i],pl,al,cont,facts,rules)) {return true}};  return false}function componebackground (p,pl,al,cont,facts,rules) {//var data = facts;  var data = envvndexps(p,al,facts);
  for (var i=0; i<data.length; i++)      {var bl = seq();       var ol = seq();       if (vnifyp(data[i],bl,p,al,ol))          {if (componeexit(pl,al,cont,facts,rules)) {backup(ol); return true};           backup(ol)}}  return false}function componers (p,pl,al,cont,facts,rules) {var data = viewindexps(p,rules);  for (var i=0; i<data.length; i++)      {var bl = seq();       var ol = seq();       if (data[i][0] == 'rule')          {if (vnifyp(data[i][1],bl,p,al,ol))              {var ql = data[i].slice(3);               var nc = cons(seq(pl,al,cont),cont);               if (compone(data[i][2],ql,bl,nc,facts,rules))                  {backup(ol); return true};               backup(ol)}}       else {if (vnifyp(data[i],bl,p,al,ol))                {if (componeexit(pl,al,cont,facts,rules))                    {backup(ol); return true};                 backup(ol)}}}  return false}function componeexit (pl,al,cont,facts,rules) {if (pl.length != 0) {return compone(pl[0],tail(pl),al,cont,facts,rules)};  if (nullp(cont)) {answer = pluug(thing,al,al); return true};  return componeexit(car(cont)[0],car(cont)[1],car(cont)[2],facts,rules)}//------------------------------------------------------------------------------function compall (p,pl,al,cont,facts,rules) {if (epitrace) {console.log(grind(pluug(p,al,al)) + '-' + pl + '-' + al)};
  inferences = inferences + 1;  if (symbolp(p)) {return compallatom(p,pl,al,cont,facts,rules)}  if (p[0] == 'same') {return compallsame(p,pl,al,cont,facts,rules)}  if (p[0] == 'distinct') {return compalldistinct(p,pl,al,cont,facts,rules)}  if (p[0] == 'matches') {return compallmatches(p,pl,al,cont,facts,rules)}  if (p[0] == 'plus') {return compallplus(p,pl,al,cont,facts,rules)}  if (p[0] == 'times') {return compalltimes(p,pl,al,cont,facts,rules)}  if (p[0] == 'min') {return compallmin(p,pl,al,cont,facts,rules)}  if (p[0] == 'not') {return compallnot(p,pl,al,cont,facts,rules)}  if (p[0] == 'and') {return compalland(p,pl,al,cont,facts,rules)}  if (p[0] == 'or') {return compallor(p,pl,al,cont,facts,rules)}  compallbackground(p,pl,al,cont,facts,rules);  return compallrs(p,pl,al,cont,facts,rules)}function compallatom (p,pl,al,cont,facts,rules) {if (p == 'true') {return compallexit(pl,al,cont,facts,rules)};  if (p == 'false') {return false};  return compallrs(p,pl,al,cont,facts,rules)}function compallsame (p,pl,al,cont,facts,rules) {var ol = seq();  if (vnifyp(p[1],al,p[2],al,ol))     {compallexit(pl,al,cont,facts,rules); backup(ol)}}function compalldistinct (p,pl,al,cont,facts,rules) {var ol = seq();  if (vnifyp(p[1],al,p[2],al,ol)) {backup(ol); return false};  return compallexit(pl,al,cont,facts,rules)}
function compallmatches (p,pl,al,cont,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var ol = seq();               if (vnifyp(p[3],al,matches[i],al,ol))                  {compallexit(pl,al,cont,facts,rules); backup(ol)}}}};  return false}function compallplus (p,pl,al,cont,facts,rules) {var total=0;
  for (var i=1; i<p.length-1; i++)
      {var arg = pluug(p[i],al,al);
       if (arg=='true') {total += 1}
          else {arg=parseFloat(arg);
                if (!isNaN(arg)) {total += arg}}};
  total = total+'';
  var ol = seq();  if (vnify(p[p.length-1],al,total,al,ol))
     {compallexit(pl,al,cont,facts,rules); backup(ol)};
  return false}function compalltimes (p,pl,al,cont,facts,rules) {var result=1;
  for (var i=1; i<p.length-1; i++)
      {var arg = pluug(p[i],al,al);
       if (arg!='true')
          {arg=parseFloat(arg);
           if (isNaN(arg)) {result = 0}
              else {result = result * arg}}};
  result = result + '';  var ol = seq();  if (vnify(p[p.length-1],al,result,al,ol))
     {compallexit(pl,al,cont,facts,rules); backup(ol)};
  return false}function compallmin (p,pl,al,cont,facts,rules) {var min = 0;
  var arg = parseFloat(pluug(p[1],al,al));
  if (!isNaN(arg)) {min = arg};
  for (var i=2; i<p.length-1; i++)
      {var arg = parseFloat(pluug(p[i],al,al));
       if (isNaN(arg)) {arg = 0};
       if (arg<min) {min = arg}};
  min = min+'';  var ol = seq();  if (vnify(p[p.length-1],al,min,al,ol))
     {compallexit(pl,al,cont,facts,rules); backup(ol)};
  return false}function compallsymbolize (p,pl,al,cont,facts,rules) {var arg = pluug(p[1],al,al);
  if (varp(arg))  {return false};
  var val = symbolize(arg);
  var ol = seq();  if (vnify(p[2],al,val,al,ol))
     {compallexit(pl,al,cont,facts,rules); backup(ol)};
  return false}

function compallbagofall (x,p,pl,al,cont,results,facts,rules) {p = pluug(p,al,al);
  var ol = seq();
  var answers = seq();
  compall(p[1],p[2],seq(),al,nil,answers,facts,rules);
  var result = seq('list').concat(answers);
  if (vnifyp(p[3],al,result,al,ol))
     {compallexit(x,pl,al,cont,results,facts,rules);
      backup(ol);
      return false};  return false}

function compallnot (p,pl,al,cont,facts,rules) {if (compone(p[1],seq(),al,nil,facts,rules) == false)
     {compallexit(pl,al,cont,facts,rules)}}function compalland (p,pl,al,cont,facts,rules) {compallexit(concatenate(tail(p),pl),al,cont,facts,rules)}function compallor (p,pl,al,cont,facts,rules) {for (var i=0; i<p.length; i++) {compall(p[i],pl,al,cont,facts,rules)}}function compallbackground (p,pl,al,cont,facts,rules) {//var data = facts;
  //var data = indexees(p[0],facts);
  var data = envvndexps(p,al,facts);
  for (var i=0; i<data.length; i++)      {var bl = seq();       var ol = seq();       if (vnifyp(data[i],bl,p,al,ol))          {compallexit(pl,al,cont,facts,rules);           backup(ol)}}}function compallrs (p,pl,al,cont,facts,rules) {var data = viewindexps(p,rules);  for (var i=0; i<data.length; i++)      {var bl = seq();       var ol = seq();       if (data[i][0] == 'rule')          {if (vnifyp(data[i][1],bl,p,al,ol))              {var ql = data[i].slice(3);               var nc = cons(seq(pl,al,cont),cont);               compall(data[i][2],ql,bl,nc,facts,rules);               backup(ol)}}       else {if (vnifyp(data[i],bl,p,al,ol))                {compallexit(pl,al,cont,facts,rules);                 backup(ol)}}}}function compallexit (pl,al,cont,facts,rules) {if (pl.length != 0) {return compall(pl[0],tail(pl),al,cont,facts,rules)};  if (nullp(cont)) {answers.push(pluug(thing,al,al)); return true};  return compallexit(car(cont)[0],car(cont)[1],car(cont)[2],facts,rules)}

//------------------------------------------------------------------------------// basefindp// basefindx// basefinds//------------------------------------------------------------------------------function basefindp (query,facts,rules) {return basefindx('true',query,facts,rules)}function basefindx (result,query,facts,rules) {thing = result;  answer = false;  if (baseone(query,seq(),nil,facts,rules)) {return answer};  return false}function basefinds (result,query,facts,rules) {thing = result;  answers = seq();  baseall(query,seq(),nil,facts,rules);  return uniquify(answers)}//------------------------------------------------------------------------------function baseone (p,pl,al,facts,rules) {if (epitrace) {console.log(grind(p) + '-' + pl + '-' + al)};  if (symbolp(p)) {return baseoneatom(p,pl,al,facts,rules)}  if (p[0] == 'same') {return baseonesame(p,pl,al,facts,rules)}  if (p[0] == 'distinct') {return baseonedistinct(p,pl,al,facts,rules)}  if (p[0] == 'matches') {return baseonematches(p,pl,al,facts,rules)}  if (p[0] == 'not') {return baseonenot(p,pl,al,facts,rules)}  if (p[0] == 'and') {return baseoneand(p,pl,al,facts,rules)}  if (p[0] == 'or') {return baseoneor(p,pl,al,facts,rules)}  if (baseonebackground(p,pl,al,facts,rules)) {return true};  return baseoners(p,pl,al,facts,rules)}function baseoneatom (p,pl,al,facts,rules) {if (p == 'true') {return baseoneexit(pl,al,facts,rules)};  if (p == 'false') {return false};  return baseoners(p,pl,al,facts,rules)}function baseonesame (p,pl,al,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {return baseoneexit(pl,al,facts,rules)};  return false}function baseonedistinct (p,pl,al,facts,rules) {if (unify(p[1],p[2],al) == false) {return baseoneexit(pl,al,facts,rules)};  return false}

function baseonematches (p,pl,al,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false && baseoneexit(pl,bl,facts,rules))                  {return true}}}};  return false}function baseonenot (p,pl,al,facts,rules) {if (baseone(p[1],seq(),al,facts,rules) == false) {return baseoneexit(pl,al,facts,rules)}  return false}function baseoneand (p,pl,al,facts,rules) {return baseoneexit(concatenate(tail(p),pl),al,facts,rules)}function baseoneor (p,pl,al,facts,rules) {var bl;  for (var i=1; i<p.length; i++)      {if (baseone(p[i],pl,al,facts,rules)) {return true}}  return false}function baseonebackground (p,pl,al,facts,rules) {var bl;  var data = envindexps(p,al,facts);  for (var i=0; i<data.length; i++)      {bl = unify(data[i],p,al);       if (bl != false && baseoneexit(pl,bl,facts,rules)) {return true}};  return false}function baseoners (p,pl,al,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && baseone(copy[2],concatenate(copy.slice(3),pl),bl,facts,rules))              {return true}}          else {bl = unify(copy,p,al);                if (bl != false && baseoneexit(pl,bl,facts,rules))                   {return true}}};  return false}function baseoneexit (pl,al,facts,rules) {if (pl.length != 0) {return baseone(pl[0],tail(pl),al,facts,rules)};  answer = plug(thing,al);  return true}//------------------------------------------------------------------------------function baseall (p,pl,al,facts,rules) {if (epitrace) {console.log(grind(p) + '-' + pl + '-' + al)};  if (symbolp(p)) {return baseallatom(p,pl,al,facts,rules)}  if (p[0] == 'same') {return baseallsame(p,pl,al,facts,rules)}  if (p[0] == 'distinct') {return basealldistinct(p,pl,al,facts,rules)}  if (p[0] == 'matches') {return baseallmatches(p,pl,al,facts,rules)}  if (p[0] == 'not') {return baseallnot(p,pl,al,facts,rules)}  if (p[0] == 'and') {return basealland(p,pl,al,facts,rules)}  if (p[0] == 'or') {return baseallor(p,pl,al,facts,rules)}  if (find(p[0],tables)) {return baseallbackground(p,pl,al,facts,rules)};  return baseallrs(p,pl,al,facts,rules)}function baseallatom (p,pl,al,facts,rules) {if (p == 'true') {return baseallexit(pl,al,facts,rules)};  if (p == 'false') {return false};  return baseallrs(p,pl,al,facts,rules)}function baseallsame (p,pl,al,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {baseallexit(pl,al,facts,rules)}}function basealldistinct (p,pl,al,facts,rules) {if (unify(p[1],p[2],al) == false) {baseallexit(pl,al,facts,rules)}}function baseallmatches (p,pl,al,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false) {baseallexit(pl,bl,facts,rules)}}}};  return false}function baseallnot (p,pl,al,facts,rules) {if (baseone(p[1],seq(),al,facts,rules) == false) {baseallexit(pl,al,facts,rules)}}function basealland (p,pl,al,facts,rules) {baseallexit(concatenate(tail(p),pl),al,facts,rules)}function baseallor (p,pl,al,facts,rules) {for (var i=0; i<p.length; i++) {baseall(p[i],pl,al,facts,rules)}}function baseallbackground (p,pl,al,facts,rules) {var data = envindexps(p,al,facts);  for (var i=0; i<data.length; i++)      {var bl = match(p,data[i],al);       if (bl != false) {baseallexit(pl,bl,facts,rules)}}}function baseallrs (p,pl,al,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false) {baseall(copy[2],concatenate(copy.slice(3),pl),bl,facts,rules)}}       else {bl = unify(copy,p,al);             if (bl != false) {baseallexit(pl,bl,facts,rules)}}}}function baseallexit (pl,bl,facts,rules) {if (pl.length != 0) {return baseall(pl[0],tail(pl),bl,facts,rules)};  answers.push(plug(thing,bl))}
//------------------------------------------------------------------------------
// residue// residues//------------------------------------------------------------------------------// Notes:
//   current version assumes query is ground
//   current version does not do negation as failure (correctly)
//   current version does not do consistency check (incorrectly)
//------------------------------------------------------------------------------function residue (query,prims,rules) {answer = false;  resone(query,seq(),nil,seq(),prims,rules);
  return answer}function residues (query,prims,rules) {answers = seq();  resall(query,seq(),nil,seq(),prims,rules);  return uniquify(answers)}//------------------------------------------------------------------------------function resone (p,pl,al,rl,prims,rules) {if (epitrace) {console.log(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return resoneatom(p,pl,al,rl,prims,rules)}  if (p[0] == 'same') {return resonesame(p,pl,al,rl,prims,rules)}  if (p[0] == 'distinct') {return resonedistinct(p,pl,al,rl,prims,rules)}  if (p[0] == 'matches') {return resonematches(p,pl,al,rl,prims,rules)}  //if (p[0] == 'not') {return resonenot(p,pl,al,rl,prims,rules)}  if (p[0] == 'and') {return resoneand(p,pl,al,rl,prims,rules)}  if (p[0] == 'or') {return resoneor(p,pl,al,rl,prims,rules)}  if (findq(operator(p),prims))
     {return resoneexit(pl,al,adjoin(p,rl),prims,rules)};  return resoners(p,pl,al,rl,prims,rules)}function resoneatom (p,pl,al,rl,prims,rules) {if (p == 'true') {return resoneexit(pl,al,rl,prims,rules)};  if (p == 'false') {return false};  return resoners(p,pl,al,rl,prims,rules)}function resonesame (p,pl,al,rl,prims,rules) {al = unify(p[1],p[2],al);  if (al != false) {return resoneexit(pl,al,rl,prims,rules)};  return false}function resonedistinct (p,pl,al,rl,prims,rules) {if (unify(p[1],p[2],al) == false) {return resoneexit(pl,al,rl,prims,rules)};  return false}function resonematches (p,pl,al,rl,prims,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false && resoneexit(pl,bl,rl,prims,rules))                  {return true}}}};  return false}function resonenot (p,pl,al,rl,prims,rules) {if (resone(p[1],seq(),al,prims,rules) == false) {return resoneexit(pl,al,rl,prims,rules)}  return false}function resoneand (p,pl,al,rl,prims,rules) {return resoneexit(concatenate(tail(p),pl),al,rl,prims,rules)}function resoneor (p,pl,al,rl,prims,rules) {var bl;  for (var i=1; i<p.length; i++)      {if (resone(p[i],pl,al,rl,prims,rules)) {return true}}  return false}function resonebackground (p,pl,al,rl,prims,rules) {var bl;  var data = envindexps(p,al,prims);  for (var i=0; i<data.length; i++)      {bl = unify(data[i],p,al);       if (bl != false && resoneexit(pl,bl,rl,prims,rules)) {return true}};  return false}function resoners (p,pl,al,rl,prims,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && resone(copy[2],concatenate(copy.slice(3),pl),bl,rl,prims,rules))              {return true}}          else {bl = unify(copy,p,al);                if (bl != false && resoneexit(pl,bl,rl,prims,rules))                   {return true}}};  return false}function resoneexit (pl,al,rl,prims,rules) {if (pl.length != 0) {return resone(pl[0],tail(pl),al,rl,prims,rules)};  answer = plug(rl,al);  return true}//------------------------------------------------------------------------------function resall (p,pl,al,rl,prims,rules) {if (epitrace) {console.log(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return resallatom(p,pl,al,rl,prims,rules)}  if (p[0] == 'same') {return resallsame(p,pl,al,rl,prims,rules)}  if (p[0] == 'distinct') {return resalldistinct(p,pl,al,rl,prims,rules)}  if (p[0] == 'matches') {return resallmatches(p,pl,al,rl,prims,rules)}  //if (p[0] == 'not') {return resallnot(p,pl,al,rl,prims,rules)}  if (p[0] == 'and') {return resalland(p,pl,al,rl,prims,rules)}  if (p[0] == 'or') {return resallor(p,pl,al,rl,prims,rules)}  if (findq(operator(p),prims))
     {return resallprim(p,pl,al,rl,prims,rules)};  return resallrs(p,pl,al,rl,prims,rules)}function resallatom (p,pl,al,rl,prims,rules) {if (p == 'true') {return resallexit(pl,al,rl,prims,rules)};  if (p == 'false') {return false};  return resallrs(p,pl,al,rl,prims,rules)}function resallsame (p,pl,al,rl,prims,rules) {al = unify(p[1],p[2],al);  if (al != false) {resallexit(pl,al,rl,prims,rules)}}function resalldistinct (p,pl,al,rl,prims,rules) {if (unify(p[1],p[2],al) == false) {resallexit(pl,al,rl,prims,rules)}}function resallmatches (p,pl,al,rl,prims,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false) {resallexit(pl,bl,rl,prims,rules)}}}};  return false}function resallnot (p,pl,al,rl,prims,rules) {if (resone(p[1],seq(),al,prims,rules) == false) {resallexit(pl,al,rl,prims,rules)}}function resalland (p,pl,al,rl,prims,rules) {resallexit(concatenate(tail(p),pl),al,rl,prims,rules)}function resallor (p,pl,al,rl,prims,rules) {for (var i=0; i<p.length; i++) {resall(p[i],pl,al,rl,prims,rules)}}

function resallprim (p,pl,al,rl,prims,rules)
 {return resallexit(pl,al,rl.concat([p]),prims,rules)}function resallrs (p,pl,al,rl,prims,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false) {resall(copy[2],concatenate(copy.slice(3),pl),bl,rl,prims,rules)}}       else {bl = unify(copy,p,al);             if (bl != false) {resallexit(pl,bl,rl,prims,rules)}}}}function resallexit (pl,bl,rl,prims,rules) {if (pl.length != 0) {return resall(pl[0],tail(pl),bl,rl,prims,rules)};  answers.push(plug(rl,bl));
  return false}

//------------------------------------------------------------------------------
// viewresidue// viewresidues//------------------------------------------------------------------------------// Notes:
//   current version assumes query is ground
//   current version does not do negation as failure (correctly)
//   current version does not do consistency check (incorrectly)
//------------------------------------------------------------------------------function viewresidue (query,prims,facts,rules) {answer = false;  viewresone(query,seq(),nil,seq(),prims,facts,rules);
  return answer}function viewresidues (query,prims,facts,rules) {answers = seq();  viewresall(query,seq(),nil,seq(),prims,facts,rules);  return uniquify(answers)}//------------------------------------------------------------------------------function viewresone (p,pl,al,rl,prims,facts,rules) {if (epitrace) {console.log(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return viewresoneatom(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'same') {return viewresonesame(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'distinct') {return viewresonedistinct(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'matches') {return viewresonematches(p,pl,al,rl,prims,facts,rules)}  //if (p[0] == 'not') {return viewresonenot(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'and') {return viewresoneand(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'or') {return viewresoneor(p,pl,al,rl,prims,facts,rules)}  if (findq(operator(p),prims))
     {return viewresoneexit(pl,al,adjoin(p,rl),prims,facts,rules)};  if (viewresonebackground(p,pl,al,rl,prims,facts,rules)) {return true};  return viewresoners(p,pl,al,rl,prims,facts,rules)}function viewresoneatom (p,pl,al,rl,prims,facts,rules) {if (p == 'true') {return viewresoneexit(pl,al,rl,prims,facts,rules)};  if (p == 'false') {return false};  return viewresoners(p,pl,al,rl,prims,facts,rules)}function viewresonesame (p,pl,al,rl,prims,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {return viewresoneexit(pl,al,rl,prims,facts,rules)};  return false}function viewresonedistinct (p,pl,al,rl,prims,facts,rules) {if (unify(p[1],p[2],al) == false)
     {return viewresoneexit(pl,al,rl,prims,facts,rules)};  return false}function viewresonematches (p,pl,al,rl,prims,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false && viewresoneexit(pl,bl,rl,prims,facts,rules))                  {return true}}}};  return false}function viewresonenot (p,pl,al,rl,prims,facts,rules) {if (viewresone(p[1],seq(),al,prims,facts,rules) == false)
     {return viewresoneexit(pl,al,prims,facts,rules)}  return false}function viewresoneand (p,pl,al,rl,prims,facts,rules) {return viewresoneexit(concatenate(tail(p),pl),al,rl,prims,facts,rules)}function viewresoneor (p,pl,al,rl,prims,facts,rules) {var bl;  for (var i=1; i<p.length; i++)      {if (viewresone(p[i],pl,al,rl,prims,facts,rules)) {return true}}  return false}function viewresonebackground (p,pl,al,rl,prims,facts,rules) {var bl;  var data = envindexps(p,al,prims);  for (var i=0; i<data.length; i++)      {bl = unify(data[i],p,al);       if (bl != false && viewresoneexit(pl,bl,rl,prims,facts,rules)) {return true}};  return false}function viewresoners (p,pl,al,rl,prims,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false && viewresone(copy[2],concatenate(copy.slice(3),pl),bl,rl,facts,prims,rules))              {return true}}          else {bl = unify(copy,p,al);                if (bl != false && viewresoneexit(pl,bl,rl,prims,facts,rules))                   {return true}}};  return false}function viewresoneexit (pl,al,rl,prims,facts,rules) {if (pl.length != 0) {return viewresone(pl[0],tail(pl),al,rl,prims,facts,rules)};  answer = plug(rl,al);  return true}//------------------------------------------------------------------------------function viewresall (p,pl,al,rl,prims,facts,rules) {if (epitrace) {console.log(p + ' - [' + pl + '] - [' + al + ']')};  if (symbolp(p)) {return viewresallatom(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'same') {return viewresallsame(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'distinct') {return viewresalldistinct(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'matches') {return viewresallmatches(p,pl,al,rl,prims,facts,rules)}  //if (p[0] == 'not') {return viewresallnot(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'and') {return viewresalland(p,pl,al,rl,prims,facts,rules)}  if (p[0] == 'or') {return viewresallor(p,pl,al,rl,prims,facts,rules)}  if (findq(operator(p),prims))
     {return viewresallexit(pl,al,adjoin(p,rl),prims,facts,rules)};
  viewresallbackground(p,pl,al,rl,prims,facts,rules);  return viewresallrs(p,pl,al,rl,prims,facts,rules)}function viewresallatom (p,pl,al,rl,prims,facts,rules) {if (p == 'true') {return viewresallexit(pl,al,rl,prims,facts,rules)};  if (p == 'false') {return false};  return viewresallrs(p,pl,al,rl,prims,facts,rules)}function viewresallsame (p,pl,al,rl,prims,facts,rules) {al = unify(p[1],p[2],al);  if (al != false) {viewresallexit(pl,al,rl,prims,facts,rules)}}function viewresalldistinct (p,pl,al,rl,prims,facts,rules) {if (unify(p[1],p[2],al) == false)
     {viewresallexit(pl,al,rl,prims,facts,rules)}}function viewresallmatches (p,pl,al,rl,prims,facts,rules) {var str = pluug(p[1],al,al)
  if (symbolp(str))     {var matches = str.match(p[2]);
      if (matches!=null)         {for (var i=0; i<matches.length; i++)              {var bl = unify(p[3],matches[i],al);               if (bl != false) {viewresallexit(pl,bl,rl,prims,facts,rules)}}}}  return false}function viewresallnot (p,pl,al,prims,facts,rules) {if (viewresone(p[1],seq(),al,prims,facts,rules) == false)
     {viewresallexit(pl,al,prims,facts,rules)}}function viewresalland (p,pl,al,rl,prims,facts,rules) {viewresallexit(concatenate(tail(p),pl),al,rl,prims,facts,rules)}function viewresallor (p,pl,al,rl,prims,facts,rules) {for (var i=0; i<p.length; i++)
      {viewresall(p[i],pl,al,rl,prims,facts,rules)}}function viewresallbackground (p,pl,al,rl,prims,facts,rules) {var data = envindexps(p,al,prims);  for (var i=0; i<data.length; i++)      {var bl = match(p,data[i],al);       if (bl != false) {viewresallexit(pl,bl,rl,prims,facts,rules)}}}function viewresallrs (p,pl,al,rl,prims,facts,rules) {var copy;  var bl;  for (var i=0; i<rules.length; i++)      {copy = standardize(rules[i]);       if (copy[0] == 'rule')          {bl = unify(copy[1],p,al);           if (bl != false)
              {viewresall(copy[2],concatenate(copy.slice(3),pl),bl,rl,prims,facts,rules)}}       else {bl = unify(copy,p,al);             if (bl != false) {viewresallexit(pl,bl,rl,prims,facts,rules)}}}}function viewresallexit (pl,bl,rl,prims,facts,rules) {if (pl.length != 0)
     {return viewresall(pl[0],tail(pl),bl,rl,prims,facts,rules)};  answers.push(plug(rl,bl));
  return false}

//------------------------------------------------------------------------------
