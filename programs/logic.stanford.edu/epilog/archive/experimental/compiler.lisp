;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfindp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfindp (p th)  (compfindx 't p th));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfindx;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfindx (x p th)  (viewfindx x p th));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compfinds;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compfinds (x p th)  (cond ((atom p) (viewfinds x p th))        ((get (car p) 'compilations)         (viewfinds x p th))        (t (viewfinds x p th))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; compiler;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun compiler (x p)  (cond ((atom p) (compalldepthatom x p al))          ((eq (car p) 'not) (compallold x p al))          ((eq (car p) 'and) (compalland x p al))          ((eq (car p) 'or) (compallold x p al))          ((eq (car p) 'same) (compallold x p al))          ((eq (car p) 'distinct) (compallold x p al))          ((eq (car p) 'oneof) (compallold x p al))          ((eq (car p) 'choose) (compallold x p al))          ((eq (car p) 'bagofall) (compallold x p al))          ((eq (car p) 'unprovable) (compallold x p al))          ((eq (car p) 'ground) (compallold x p al))          ((eq (car p) 'nonground) (compallold x p al))          ((eq (car p) 'execute) (compallold x p al))          ((eq (car p) 'evaluate) (compallold x p al))          ((get (car p) 'basicval) (compallold x p al))          ((get (car p) 'basic) (compallold x p al))          (t (compilerth x p al)))(defun compalland (x p al)  (cond ((null (cdr p)) (compalldepth x 'true al))        ((null (cddr p)) (compalldepth x (cadr p) al))        (t (let (var ins outs vl bl nl)             (setq var (newvar))             (setq ins (newin) outs (newout))             (setq vl (impvars nil (cdr p) (vars x)))             (setq bl al)             (setq nl (cons `(setq ,ins ,(compalldepth (caddr vl) (cadr p) al)) nl))             (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))                 ((null l))                 (setq bl (cons (cons (car l) `(nth ,i ,var)) bl)))             (do ((l (cddr p) (cdr l)) (vl (cddr vl) (cddr vl)) (dl (dependencies p)))                 ((null (cdr l))                  (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))                         (setq nl (cons `(loop for ,var in ,ins                                               when ,(planoneexp t (car l) bl)                                               do ,(compalldone x bl outs)) nl))                         (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                             (setq nl (cons `(nreverse ,outs) nl))                             (setq nl (cons `(nreverse (uniquify ,outs)) nl))))                        (t  (setq nl (cons `(loop for ,var in ,ins                                                  do ,(compallexp x (car l) bl outs)) nl))                            (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                                (setq nl (cons `(nreverse ,outs) nl))                                (setq nl (cons `(nreverse (uniquify ,outs)) nl))))))                 (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))                        (setq nl (cons `(loop for ,var in ,ins                                              when ,(planoneexp t (car l) bl)                                              do ,(compalldone (caddr vl) bl outs)) nl))                        (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                            (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))                            (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))))                       (t  (setq nl (cons `(loop for ,var in ,ins                                                 do ,(compallexp (caddr vl) (car l) bl outs)) nl))                           (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                               (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))                               (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl)))))                 (setq bl al)                 (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))                     ((null l))                     (setq bl (cons (cons (car l) `(nth ,i ,var)) bl))))             `(let (,ins ,outs) . ,(nreverse nl))))))(defun compallth (x p al where)  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)        (index (indexable p al *theory*))        (test `((equalp (nth 0 ,var) ,(indexable (car p) al *theory*)))))       ((null l) `(loop for ,var in (indexees ,index *theory*)                        when ,(maksand (nreverse test))                        do (setq ,where (cons ,(makresult x al) ,where))))       (cond ((eq '?* (car l)))             ((groundp (car l))              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))             ((setq dum (assoc (car l) al))              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))(defun compalldepth (x p al)  (let ((*varcount* *varcount*) (*incount* *incount*) (*outcount* *outcount*))    (cond ((atom p) (compalldepthatom x p al))          ((eq 'not (car p)) (compallold x p al))          ((eq 'and (car p)) (compalldepthand x p al))          ((eq 'or (car p)) (compallold x p al))          ((eq 'same (car p)) (compallold x p al))          ((eq 'distinct (car p)) (compallold x p al))          ((eq 'oneof (car p)) (compallold x p al))          ((eq 'choose (car p)) (compallold x p al))          ((eq 'bagofall (car p)) (compallold x p al))          ((eq 'unprovable (car p)) (compallold x p al))          ((eq 'ground (car p)) (compallold x p al))          ((eq 'nonground (car p)) (compallold x p al))          ((eq 'execute (car p)) (compallold x p al))          ((eq 'evaluate (car p)) (compallold x p al))          ((eq 'strmatch (car p)) (compallold x p al))          ((get (car p) 'basicval) (compallold x p al))          ((get (car p) 'basic) (compallold x p al))          (t (compalldepthth x p al)))))(defun compalldepthatom (x p al)  (cond ((eq 'true p) `(list ,(makresult x al)))        ((eq 'cut p) `(list ,(makresult x al)))        ((eq 'false p) nil)        (t `(if (find ',p (indexees ',p *theory*)) (list ,(makresult x al))))))(defun compalldepthth (x p al)  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)     ;;; (cdr p) -> p, 1 -> 0        (index (indexable p al *theory*)) (one (onep (vars x) p al))        (test `((equalp (nth 0 ,var) ',(car p)))))       ((null l)        (setq test (cons `(= (length ,var) ,i) test))        `(loop for ,var in (indexees ,index *theory*)               with answers               when ,(maksand (nreverse test))               do (setq answers (cons ,(makresult x al) answers))               finally (return ,(if one '(nreverse answers) '(nreverse (uniquify answers))))))       (cond ((eq '?* (car l)))             ((groundp (car l))              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))             ((setq dum (assoc (car l) al))              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))(defun tableindexable (p al)  (cond ((atom p)         (let (dum)         (cond ((varp p)                (if (setq dum (assoc p al)) (cdr dum)))               ((atom p) (quotify p)))))        (t (quotify (car p)))))(defmethod indexable (p al th)  (cond ((atom p)         (let (dum)         (cond ((varp p)                (if (setq dum (assoc p al)) (cdr dum)))               ((atom p) (quotify p)))))        (t (do ((l (cdr p) (cdr l)) (dum))               ((null l) (indexable (car p) al th))               (cond ((varp (car l))                      (if (setq dum (assoc (car l) al)) (return (cdr dum))))                     ((atom (car l)) (return (quotify (car l)))))))))(defun compallold (x p al)  `(let ((answers))     ,(compallexp x p al 'answers)     ;(uniquify (nreverse answers))     (nreverse answers)))(defun compallexp (x p al where)  (let ((*varcount* *varcount*) (*incount* *incount*) (*outcount* *outcount*))    (cond ((atom p) (compallatom x p al where))          ((eq 'not (car p)) (compallnot x (cadr p) al where))          ((eq 'and (car p)) (compalland x p al where))          ((eq 'or (car p)) (compallor x p al where))          ((eq 'same (car p)) (compallsame x p al where))          ((eq 'distinct (car p)) (compalldistinct x p al where))          ((eq 'oneof (car p)) (compalloneof x p al where))          ((eq 'choose (car p)) (compallchoose x p al where))          ((eq 'bagofall (car p)) (compallbagofall x p al where))          ((eq 'unprovable (car p)) (compallunprovable x (cadr p) al where))	  ((eq 'ground (car p)) (compallground x p al where))	  ((eq 'nonground (car p)) (compallnonground x p al where))          ((eq 'execute (car p)) (compallexecute x p al where))          ((eq 'evaluate (car p)) (compallevaluate x p al where))          ((eq 'strmatch (car p)) (compallstrmatch x p al where))	  ((get (car p) 'basicval) (compallbasicval x p al where))          ((get (car p) 'basic) (compallbasic x p al where))          (t (compallth x p al where)))))(defun compallnot (x p al where)  (cond ((atom p) (compallnotatom x p al where))        ((eq 'not (car p)) (compallexp x (cadr p) al where))        ((eq 'and (car p)) (compallnotand x p al where))        ((eq 'or (car p)) (compallnotor x p al where))        ((eq 'same (car p)) nil)        ((eq 'distinct (car p)) nil)        ((eq 'oneof (car p)) nil)        ((eq 'choose (car p)) nil)        ((eq 'bagofall (car p)) (compallnotbagofall x p al where))        ((eq 'unprovable (car p)) (compallexp x (cadr p) al where))        ((eq 'ground (car p)) nil)        ((eq 'nonground (car p)) nil)        ((eq 'execute (car p)) (compallnotexecute x p al where))        ((eq 'evaluate (car p)) (compallnotevaluate x p al where))        ((eq 'strmatch (car p)) (compallnotstrmatch x p al where))        ((get (car p) 'basicval) (compallnotbasicval x p al where))        ((get (car p) 'basic) (compallnotbasic x p al where))        (t (compallunprovable x p al where))))(defun compallatom (x p al where)  (cond ((eq 'true p) (compalldone x al where))        ((eq 'cut p) (compalldone x al where))        ((eq 'false p) nil)        (t `(if (find ',p (indexees ',p *theory*)) ,(compalldone x al where)))))(defun compalland (x p al where)  (cond ((null (cdr p)) (compalldone (makresult x al) al where))        ((null (cddr p)) (compallexp x (cadr p) al where))        (t (let (var ins outs vl bl nl)             (setq var (newvar))             (setq ins (newin))             (setq outs (newout))             (setq vl (impvars nil (cdr p) (vars x)))             (setq bl al)             (setq nl (list (compallexp (caddr vl) (cadr p) al outs)))             (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))             (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))                 ((null l))                 (setq bl (cons (cons (car l) `(nth ,i ,var)) bl)))             (do ((l (cddr p) (cdr l)) (vl (cddr vl) (cddr vl)) (dl (dependencies p)))                 ((null (cdr l))                  (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))                         (setq nl (cons `(loop for ,var in ,ins                                               when ,(planoneexp t (car l) bl)                                               do ,(compalldone x bl where)) nl)))                        (t  (setq nl (cons `(loop for ,var in ,ins                                                  do ,(compallexp x (car l) bl where)) nl)))))                 (cond ((subsetp (caddr vl) (car vl)) ; was (subsetp (cadr vl) (car vl))                        (setq nl (cons `(loop for ,var in ,ins                                              when ,(planoneexp t (car l) bl)                                              do ,(compalldone (caddr vl) bl outs)) nl))                        (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                            (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))                            (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl))))                       (t  (setq nl (cons `(loop for ,var in ,ins                                                 do ,(compallexp (caddr vl) (car l) bl outs)) nl))                           (if (monotonicp (car vl) (cadr vl) (caddr vl) dl)                               (setq nl (cons `(setq ,ins (nreverse ,outs) ,outs nil) nl))                               (setq nl (cons `(setq ,ins (nreverse (uniquify ,outs)) ,outs nil) nl)))))                 (setq bl al)                 (do ((l (caddr vl) (cdr l)) (i 0 (1+ i)))                     ((null l))                     (setq bl (cons (cons (car l) `(nth ,i ,var)) bl))))             `(let ((,ins) (,outs)) . ,(nreverse nl))))))(defun impvars (ol pl nl)  (cond ((null pl) (list nl))        (t (let (vl)             (setq nl (impvars (goodvarsform (car pl) ol) (cdr pl) nl))             (setq vl (vars (car pl)))             (list* (intersection ol (unionize vl (car nl))) vl nl)))))(defun compallor (x p al where)  (cond ((null (cdr p)) nil)        ((null (cddr p)) (compallexp x (cadr p) al where))        (t (do ((l (cdr p) (cdr l)) (nl))               ((null l)                (cons 'progn (nreverse (cons `(setq ,where (uniquify ,where)) nl))))               (setq nl (cons (compallexp x (car l) al where) nl))))))(defun compallsame (x p al where)  (cond ((groundedoutp (cadr p) al)         (cond ((groundedoutp (caddr p) al)                `(when (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))                   ,(compalldone x al where)))               (t (compalldone x (cons (cons (caddr p) (makresult (cadr p) al)) al) where))))        ((groundedoutp (caddr p) al)         (compalldone x (cons (cons (cadr p) (makresult (caddr p) al)) al) where))        (t (compalldone x (cons (cons (caddr p) (quotify (cadr p))) al) where))))(defun compalldistinct (x p al where)  `(unless (equalp ,(makresult (cadr p) al) ,(makresult (caddr p) al))     ,(compalldone x al where)))(defun compalloneof (x p al where)  (let (var test (alist al))    (setq var (newvar))    (setq test (codsand (maktestexp (cadr p) var nil)))    (cond ((and (eq test t) (equal x (cadr p))) `(setq ,where (nreverse ',(cddr p))))          (t `(loop for ,var in ',(cddr p)                    when ,test                    do ,(compalldone x alist where))))))(defun compallchoose (x p al where)  (let ((arg1) (arg2) (dum))    (setq arg1 (planoneexp (cadr p) (caddr p) al))    (setq arg2 (car (last p)))    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(compalldone x al where)))          ((setq dum (assoc arg2 al))           `(if (equalp ,arg1 ,(cdr dum)) ,(compalldone x al where)))          (t (setq al (cons (cons arg2 arg2) al))             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(compalldone x al where)))))))(defun compallbagofall (x p al where)  (let ((arg1) (arg2) (dum))    (setq arg1 `(cons 'listof ,(compalldepth (cadr p) (caddr p) al)))    (setq arg2 (car (last p)))    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(compalldone x al where)))          ((setq dum (assoc arg2 al))           `(if (equalp ,arg1 ,(cdr dum)) ,(compalldone x al where)))          (t (setq al (cons (cons arg2 arg2) al))             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(compalldone x al where)))))))(defun compallnotbagofall (x p al where)  (let ((arg1) (arg2) (dum))    (setq arg1 `(cons 'listof ,(compalldepth (cadr p) (caddr p) al)))    (setq arg2 (car (last p)))    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(compalldone x al where)))          ((setq dum (assoc arg2 al))           `(if (not (equalp ,arg1 ,(cdr dum))) ,(compalldone x al where)))          (t `(if ,arg1 ,(compalldone x al where))))))(defun compallunprovable (x p al where)  (setq p (deskolemize p))  `(if (not ,(planoneexp t p al)) ,(compalldone x al where)))(defun compallground (x p al where)  (if (groundedoutp (cadr p) al) (compalldone x al where)))(defun compallnonground (x p al where)  (cond ((groundedoutp (cadr p) al) nil)        (t (compalldone x al where))))(defun compallexecute (x p al where)  (let (dum)    (cond ((null (cddr p))           `(if (ignore-errors ,(makcode (cadr p) al)) ,(compalldone x al where)))          ((null (cdddr p))           (cond ((groundp  (caddr p))                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p)))                     ,(compalldone x al where)))                 ((setq dum (assoc (caddr p) al))                  `(if (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum))                     ,(compalldone x al where)))                 (t (setq al (cons (cons (caddr p) (caddr p)) al))                    `(let ((,(caddr p) (ignore-errors ,(makcode (cadr p) al))))                       (if ,(caddr p) ,(compalldone x al where))))))          (t (do ((l (cddr p) (cdr l)) (vars) (test))                 ((null l) (setq vars (nreverse vars))                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))                     (if ,(maksand (cons (car vars) test)) ,(compalldone x al where))))                 (setq vars (cons (newvar) vars))                 (setq dum (maktest (car l) (car vars) al))                 (unless (eq dum t) (setq test (cons dum test)))                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))(defun compallevaluate (x p al where)  (compallexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al where))(defun compallstrmatch (x p al where)  (compallexp x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al where))(defun compallbasicval (x p al where)  (let ((arg1) (arg2) (dum))    (do ((l (cdr p) (cdr l)) (nl))        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))        (setq nl (cons (makresult (car l) al) nl)))    (setq arg2 (car (last p)))    (cond ((groundp  arg2) `(if (equalp ,arg1 ',arg2) ,(compalldone x al where)))          ((setq dum (assoc arg2 al))           `(if (equalp ,arg1 ,(cdr dum)) ,(compalldone x al where)))          (t (setq al (cons (cons arg2 arg2) al))             `(let ((,arg2 ,arg1)) (if ,(cdar al) ,(compalldone x al where)))))))(defun compallnotbasicval (x p al where)  (let ((arg1) (arg2) (dum))    (do ((l (cdr p) (cdr l)) (nl))        ((null (cdr l)) (setq arg1 `(ignore-errors ,(cons (car p) (nreverse nl)))))        (setq nl (cons (makresult (car l) al) nl)))    (setq arg2 (car (last p)))    (cond ((groundp  arg2) `(if (not (equalp ,arg1 ',arg2)) ,(compalldone x al where)))          ((setq dum (assoc arg2 al))           `(if (not (equalp ,arg1 ,(cdr dum))) ,(compalldone x al where)))          (t `(if ,arg1 ,(compalldone x al where))))))(defun compallbasic (x p al where)  (let ((test))    (setq test (cons (get (car p) 'basic)                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))    `(if (ignore-errors ,test) ,(compalldone x al where))))(defun compallth (x p al where)  (do* ((l (cdr p) (cdr l)) (i 1 (1+ i)) (var (newvar)) (dum)        (index (indexable p al *theory*))        (test `((equalp (nth 0 ,var) ,(indexable (car p) al *theory*)))))       ((null l) `(loop for ,var in (indexees ,index *theory*)                        when ,(maksand (nreverse test))                        do (setq ,where (cons ,(makresult x al) ,where))))       (cond ((eq '?* (car l)))             ((groundp (car l))              (setq test (cons `(equalp (nth ,i ,var) ',(car l)) test)))             ((setq dum (assoc (car l) al))              (setq test (cons `(equalp (nth ,i ,var) ,(cdr dum)) test)))             (t (setq al (cons (cons (car l) `(nth ,i ,var)) al))))))(defun compalldone (x al where)  `(setq ,where (cons ,(makresult x al) ,where)))(defun compallnotatom (x p al where)  (cond ((eq 'true p) nil)        ((eq 'cut p) nil)        ((eq 'false p) (compalldone x al where))))(defun compallnotor (x p al where)  (compalland x (cons 'and (mapcar #'maknot (cdr p))) al where))(defun compallnotand (x p al where)  (cond ((null (cdr p)) nil)        ((null (cddr p)) (compallnot x (cadr p) al where))        (t (do ((l (cdr p) (cdr l)) (nl))               ((null l) (cons 'progn (nreverse nl)))               (setq nl (cons (compallnot x (car l) al where) nl))))))(defun compallnotvalue (x p al where)  (cond ((every #'atom (cdr p))         (compallnotbasicval x (append (cadr p) (cddr p)) al where))        (t (setq p (nreverse (flatten p)))           (rplaca p (maknot (car p)))           (setq p (nreverse p))           (compallexp x p al where))))(defun compallnotexecute (x p al where)  (let (dum)    (cond ((null (cddr p))           `(if (ignore-errors (not ,(makcode (cadr p) al))) ,(compalldone x al where)))          ((null (cdddr p))           (cond ((groundp  (caddr p))                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(quotify (caddr p))))                     ,(compalldone x al where)))                 ((setq dum (assoc (caddr p) al))                  `(if (not (equalp (ignore-errors ,(makcode (cadr p) al)) ,(cdr dum)))                     ,(compalldone x al where)))                 (t `(if (ignore-errors (not ,(makcode (cadr p) al)))                       ,(compalldone x al where)))))          (t (do ((l (cddr p) (cdr l)) (vars) (test))                 ((null l) (setq vars (nreverse vars))                  `(multiple-value-bind ,vars (ignore-errors ,(makcode (cadr p) al))                     (if (not ,(maksand (cons (car vars) test))) ,(compalldone x al where))))                 (setq vars (cons (newvar) vars))                 (setq dum (maktest (car l) (car vars) al))                 (unless (eq dum t) (setq test (cons dum test)))                 (when (varp (car l)) (setq al (acons (car l) (car vars) al))))))))(defun compallnotevaluate (x p al where)  (compallnotexecute x `(execute ,(cons (caadr p) (mapcar #'kwotify (cdadr p))) . ,(cddr p)) al where))(defun compallnotstrmatch (x p al where)  (compallnot x `(execute (strmatches ,(cadr p) ,(caddr p)) ? . ,(cdddr p)) al where))(defun compallnotbasic (x p al where)  (let ((test))    (setq test (cons (get (car p) 'basic)                     (mapcar #'(lambda (x) (makresult x al)) (cdr p))))    `(if (ignore-errors (not ,test)) ,(compalldone x al where))))