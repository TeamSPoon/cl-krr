<HTML><HEAD><TITLE>Minilog Overview</TITLE></HEAD><BODY BGCLOR="WHITE"><BR/><CENTER><H1>An Overview of MINILOG 1.0 for LISP</H1><H2>Logic Group</H2><H2>Stanford University</H2></CENTER><H2>1. Introduction</H2><P>Minilog for Lisp is a set of Common Lisp subroutines implementing ... library of Common Lisp subroutines for use in programs that manipulate information encoded in Standard Information Format (SIF), a variant of first order predicate calculus.  It includes translators to convert expressions from one form to another, pattern matchers of various sorts, subroutines to create and maintain SIF knowledge bases, and a sound and complete inference procedure based on model elimination.</P><P>The inference procedure used in Epilog is based on a technique called <EM>model elimination</EM>.  The procedure closely resembles that of Prolog; but, unlike that that of Prolog, the procedure used in Epilog is sound and complete for the entire language, i.e. all consequences the system derives are correct and it can derive all correct consequences of the information it is given.</P><P>SIF, the language supported by Epilog, is a proper subset of KIF (Knowledge Interchange Format), i.e. all expressions in SIF are expressions in KIF, but not all KIF expressions are expressions in SIF.  Despite this subset relationship, SIF is fully expressive, i.e. for any set of KIF sentences, there is an equivalent set of SIF sentences.  Thus, using the subroutines in Epilog, it is possible to build a sound and complete inference procedure for all of KIF.</P><P>This document is a brief introduction to some of the key features of Epilog.  For more detailed information, the reader is referred to the Epilog reference manual.</P><H2>2. Knowledge Interchange Format</H2><P>KIF is a prefix version of the language of first order predicate calculus with various extensions to enhance its expressiveness.  In Epilog, KIF expressions are represented as Lisp atoms and lists (but not dotted pairs).</P><P>The basic vocabulary of the language includes variables, logical operators, and constants.  Individual variables are distinguished by the presence of <TT>?</TT> as initial character, and sequence variables are distinguished by the presence of an initial <TT>@</TT>.  There is a fixed set of operators <TT>=</TT>,<TT>/=</TT>, <TT>listof</TT>, <TT>quote</TT>, <TT>not</TT>, <TT>and</TT>, <TT>or</TT>, <TT>=></TT>, <TT><=</TT>).  All others words are constants.</P><P>From this basic vocabulary, we can build <EM>terms</EM> to refer to objects in the universe of discourse, as in the following examples.</P><PRE>    (father art)    (+ 2 3)</PRE><P>The language is distinctive in its use of a quotation operator to write terms that refer to expressions.  For example, the following term refers to the expression <TT>(+ 2 3)</TT> literally.</P><PRE>    (quote (+ 2 3))</PRE><P>From terms, we can build sentences.  First and foremost, this provides the ability to encode simple data, as in the examples shown below.</P><PRE>    (parent art bob)    (parent art bea)    (parent bob cal)</PRE><P>Using the logical operators in SIF, it is possible to encode more complex sorts of information (such as negations, disjunctions, rules, and so forth).  The expression shown below is an example of a logical sentence in SIF.  It defines a grandparent as a parent of a parent.</P><PRE>    (<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))</PRE><H2>3. Knowledge Base Manipulation</H2><P>Epilog provides capabilities for managing knowledge bases of sentences encoded in SIF.  In this section, we introduce the subroutines for creating, examining, and destroying knowledge bases.  We also look at Epilog's heterarchical theory mechanism.</P><P>The <TT>save</TT> command is used to add facts to a specified <EM>theory</EM>. Here, we add the facts that Art is the parent of Bob, Bea, and Bess to the theory named <TT>global</TT>.</P><PRE>User: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent art bea) 'global)Lisp: (PARENT ART BEA)User: (save '(parent art bess) 'global)Lisp: (PARENT ART BESS)</PRE><P>Once we have some facts in a theory, we can examine its contents.  The <TT>knownp</TT> command takes a sentence and a theory as arguments.  If the sentence is ground, then <TT>knownp</TT> succeeds if and only if the theory contains that sentence.  If the sentence includes individual or sequence variables, <TT>knownp</TT> succeeds if and only if the theory contains a sentence that matches the argument for some binding of the constituent variables. </P><PRE>User: (knownp '(parent art bob) 'global)Lisp: TUser: (knownp '(parent ?x bob) 'global)Lisp: TUser: (knownp '(parent @l) 'global)Lisp: T</PRE><P>The <TT>knownx</TT> command takes an expression, a sentence, and a theory as arguments.  If the theory contains a matching sentence, <TT>knownx</TT> plugs the variable bindings (if any) into the specified expression and returns the answer.  There is no restriction on the position of the variables in the query.  Note that there are three possible answers for the second query.  The <TT>knownx</TT> subroutine always returns the first answer it finds.</P><PRE>User: (knownx '?x '(parent ?x bob) 'global)Lisp: ART</P>User: (knownx '?y '(parent art ?y) 'global)Lisp: BOB</P>User: (knownx '(related @l) '(parent @l) 'global)Lisp: (RELATED ART BOB)</PRE><P>The <TT>knowns</TT> subroutine is similar to <TT>knownx</TT> except that it returns a list of all possible answers.  The order of answers on the list is the order in which they are found in the theory.</P><PRE>User: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA BESS)User: (knowns '(related ?x ?y) '(parent ?x ?y) 'global)Lisp: ((RELATED ART BOB) (RELATED ART BEA) (RELATED ART BESS))</PRE><P>The <TT>knowng</TT> subroutine takes the same arguments as <TT>knownx</TT> and <TT>knowns</TT> and returns an answer generator as value.  Each time this generator is called, it returns a different answer to the orginal question.  When all answers have been exhausted, it returns <TT>nil</TT>.</P><PRE>User: (setq gen (knowng '?y '(parent art ?y) 'global))Lisp: #&lt;continuation23&gt;User: (funcall gen)Lisp: BOBUser: (funcall gen)Lisp: BEAUser: (funcall gen)Lisp: BESSUser: (funcall gen)Lisp: NIL</PRE><P>The <TT>drop</TT> subroutine is used to delete sentences from a theory.  If <TT>drop</TT> succeeds in finding a matching sentence to remove, it returns the sentence as value.</P><PRE>User: (drop '(parent art bess) 'global)Lisp: (PARENT ART BESS)User: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA)</PRE><P>By specifying different theory arguments to these subroutines, we can manipulate theories without affecting other theories.  For example, here we add some sentences to a new theory, called <TT>mytheory</TT>.  Notice that only the new information is available in this new theory.</P><PRE>User: (save '(parent art bill) 'mytheory)Lisp: (PARENT ART BILL)User: (save '(parent art betty) 'mytheory)Lisp: (PARENT ART BETTY)User: (knowns '?y '(parent art ?y) 'mytheory)Lisp: (BILL BETTY)</PRE><P>Another way of creating a theory is to use the <TT>deftheory</TT> command.  This subroutine takes a theory name and a list of sentences as arguments and arranges that the theory contains exactly those sentences specified and no more.  Here, we create a theory called <TT>another</TT> with two more facts about Art.</P><PRE>User: (deftheory anotherUser:   (parent art ben)User:   (parent art barbara))Lisp: ANOTHERUser: (knowns '?y '(parent art ?y) 'another)Lisp: (BEN BARBARA)</PRE><P>Of course, we can still access our old theory by passing its name as argument.  In the following example, we access our old data by specifying <TT>global</TT> in our call to <TT>knowns</TT>.</P><PRE>User: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA)</PRE><P>Often in working with theories, it is useful to include the facts from one theory inside of another theory.  We can do this by using the <TT>save</TT> command to add them in the other theory as well, but this is wasteful.  An alternative is to call the <TT>includes</TT> routine on two theories, thereby telling the database routines that the first theory implicitly includes the second.  Here, we say that <TT>mytheory</TT> includes <TT>global</TT> and <TT>another</TT> and thereby make all of the facts in these theories available whenever a subroutine accesses <TT>mytheory</TT>.  The <TT>includees</TT> subroutine returns a list of all theories included in the theory specified as argument.  The variable <TT>*includers*</TT> always contains a list of theories with included theories.</P><PRE>User: (includes 'mytheory 'global)Lisp: DONE</P>User: (knowns '?y '(parent art ?y) 'mytheory)Lisp: (BILL BETTY BOB BEA)User: (includees 'mytheory)Lisp: (GLOBAL)User: *includers*Lisp: (MYTHEORY)</PRE><P>The variable <TT>*theories*</TT> contains a list of theories containing one or more sentences.  <TT>empty</TT> removes all sentences from a given theory.  <TT>reset</TT> resets the state of the database and all variables in Epilog to their initial values.</P><PRE>User: *theories*Lisp: (ANOTHER MYTHEORY GLOBAL)User: (empty 'global)Lisp: DONEUser: *theories*Lisp: (ANOTHER MYTHEORY)User: (reset)Lisp: DONE</PRE><H2>4. Inference</H2><P>The basic reasoning program in Epilog is an efficient implementation of the model elimination proof procedure.  The procedure is enhanced to handle metalevel information, and there are also some extensions to support procedural attachment and nonmonotonic reasoning.  In this section, we take a look at the basic first order reasoning capabilities;  the metalevel reasoning ability is described in the next section; and procedural attachments and nonmonotonic reasoning are discussed in the section thereafter.</P><P>The special strength of the inference subroutines is their ability to do inference with logical information encoded as implications.  Here, we enter a definition for the <TT>grandparent</TT> relation, and we enter some facts about Art's family.  Although, according to our definitions, Art is the grandparent of Cal, <TT>knownp</TT> answers <TT>nil</TT>.  This is the correct answer for <TT>knownp</TT> -- after all, the fact is not stored explicitly in the theory.  By contrast, <TT>findp</TT> is able to prove the fact.  The  <TT>findx</TT> subroutine is able to find a grandparent of Cal and a grandchild of Art.  The <TT>finds</TT> subroutine is able to find all of the grandchildren of Art.  The <TT>findg</TT> subroutinereturns a generator.</P><PRE>User: (save '(<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))            'global)Lisp: (<= (GRANDPARENT ?X ?Z) (PARENT ?X ?Y) (PARENT ?Y ?Z))User: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent bob cal) 'global)Lisp: (PARENT BOB CAL)User: (save '(parent bob coe) 'global)Lisp: (PARENT BOB COE)User: (knownp '(grandparent art cal) 'global)Lisp: NILUser: (findp '(grandparent art cal) 'global)Lisp: TUser: (findx '?x '(grandparent ?x cal) 'global)Lisp: ARTUser: (findx '?y '(grandparent art ?y) 'global)Lisp: CALUser: (finds '?y '(grandparent art ?y) 'global)Lisp: (CAL COE)User: (setq gen (findg '?y '(grandparent art ?y) 'global))Lisp: #&lt;continuation24&gt;User: (funcall gen)Lisp: CALUser: (funcall gen)Lisp: COEUser: (funcall gen)Lisp: NIL</PRE><P>The inference subroutines introduced so far illustrate backward reasoning (from the goal to premises using backward implications).  Epilog is also capable of forward reasoning (from premises to conclusions using forward implications).</P><P>As an example, consider the following interaction.  By setting <TT>*saves*</TT> to <TT>(family)</TT>, the user directs the system to save literals involving the <TT>family</TT> relation.  The forward implication asserts that, if a person is in a particular family, then all of his children are in that family as well.  By writing it as a forward implication, we are saying that the implication should be triggered whenever we get information about a person's family.  The subroutine <TT>assume</TT> is used to add sentences to the database and conduct all such forward chaining.  If we discover that Art is a Garfunkel, then we immediately conclude that Bob and Cal and Coe are Garfunkels as well and these facts are stored explicitly in the database.</P><PRE>User: (setq *saves* '(family))Lisp: (FAMILY)User: (save '(=> (family ?x ?z) (parent ?x ?y) (family ?y ?z)) 'global)Lisp: (=> (FAMILY ?X ?Z) (PARENT ?X ?Y) (FAMILY ?Y ?Z))User: (assume '(family art garfunkel) 'global)Lisp: DONEUser: (knowns '?x '(family ?x garfunkel) 'global)Lisp: (ART BOB CAL COE)</PRE><P>So far, we have concentrated exclusively on relations.  Much, if not most, of our conceptualization of the world naturally takes the form of functions.  For functional information, we use a notation much closer to that of Lisp.  If a list is empty, the result of appending the list onto a second list is just the second list; otherwise, the result is obtained by adding the first element of the list to the result of appending the rest of the list to the second list.</P><PRE>User: (save '(= (append (listof) ?m) ?m) 'global)User: (save '(<= (= (append (listof ?x @l) ?m) (listof ?x @n))                 (= (append (listof @l) ?m) (listof @n)))            'global)</PRE><P>Now it is possible to append two lists by making a call to the <TT>findx</TT> routine.</P><PRE>User: (findx '?z '(= (append (listof 1 2) (listof 3 4)) ?z) 'global)Lisp: (listof 1 2 3 4)</PRE><P>The inference subroutines also include a subroutine, called <TT>findval</TT>, capable of evaluating terms directly.</P><PRE>User: (findval '(append (listof 1 2) (listof 3 4)) 'global)Lisp: (listof 1 2 3 4)</PRE><P>Here, we have a more interesting example of automated reasoning.  Given the axioms of equality (reflexivity, symmetry, and transitivity) and the group axioms (left and right identities for the <TT>*</TT> function, right inverse, and associativity), we ask the system to prove that the right inverse is also a left inverse.</P><PRE>User: (deftheory equality        (<= (= ?x ?y) (== ?x ?y))        (= ?x ?x)        (<= (= ?x ?y) (= ?y ?x))        (<= (= ?x ?z) (= ?x ?y) (= ?y ?z)))Lisp: EQUALITYUser: (deftheory group        (<= (= (* ?x ?y) ?x) (= ?y e))        (<= (= (* ?y ?x) ?x) (= ?y e))        (<= (= (* ?x ?y) e) (= ?y (inv ?x)))        (<= (= (* ?x ?v) ?w)            (= (* ?y ?z) ?v)            (= (* ?x ?y) ?u)            (= (* ?u ?z) ?w)))Lisp: GROUPUser: (includes 'group 'equality)Lisp: DONEUser: (setq *depth* 5)Lisp: 5User: (findp '(= (* (inv x) x) e) 'group)Lisp: T</PRE><P>Problems like this one are much more complicated than the simpler examples shown earlier.  While Epilog can handle such cases, the computational cost can be quite large.  For example, the computational cost for the previous examples is just a few milliseconds apiece, whereas the cost in this case is about a second, and the cost to prove more complicated theorems can be much higher.  Fortunately, the inference algorithm used in Epilog is quite simple; and, as a result, it is usually possible to predict its computational performance on a given knowledge base and to control that performance by writing sentences in a judicious manner.</P><H2>5. Metaknowledge</H2><P>One of the distinctive features of SIF is that it allows us to express knowledge about knowledge.  In order to encode such <EM>metaknowledge</EM>, we use a conceptualization in which expressions in the language are treated as objects in the universe of discourse and in which there are functions and relations appropriate to these objects.  In SIF, atoms are treated as primitive objects (i.e. having no subparts).  Complex expressions (i.e. non-atoms) are treated as lists of subexpressions (either atoms or other complex expressions).  In particular, every complex expression is viewed as a list of its immediate subexpressions.</P><P>In order to assert properties of expressions in the language, we need a way of referring to those expressions.  There are two ways of doing this in SIF.  One way is to use the <TT>quote</TT> operator in front of an expression.  For example, to refer to the symbol <TT>john</TT>, we use the term <TT>'john</TT> or, equivalently, <TT>(quote john)</TT>.  To refer to the expression <TT>(p a b)</TT>, we use the term<TT>'(p a b)</TT> or, equivalently, <TT>(quote (p a b))</TT>.</P><P>With a way of referring to expressions, we can assert their properties.  For example, the following sentence ascribes to the individual named <TT>john</TT> the belief that the moon is made of a particular kind of blue cheese.</P><PRE>User: (save '(believes john '(material moon stilton)) 'global)Lisp: (BELIEVES JOHN '(MATERIAL MOON STILTON))</PRE><P>Since expressions are first-order objects, we can quantify over them, thereby asserting properties of whole classes of sentences.  For example, we could say that Mary believes everything that John believes.  This fact together with the preceding fact allows us to conclude that Mary also believes the moon to be madeof blue cheese.</P><PRE>User: (save '(<= (believes mary ?p) (believes john ?p)) 'global)Lisp: (<= (BELIEVES MARY ?P) (BELIEVES JOHN ?P))User: (findp '(believes mary '(material moon stilton)) 'global)Lisp: T</PRE><P>The second way of referring to expressions is SIF is to use the <TT>listof</TT> operator.  We can denote a complex expression like <TT>(p a b)</TT> by a term of the form <TT>(listof 'p 'a 'b)</TT>, as well as <TT>'(p a b)</TT>.  All of Epilog's subroutines treat the <TT>quote</TT> and <TT>listof</TT> forms of denotation as equivalent.  If variables are included in the list form, then any attempt to match the two forms will result in the variables being bound to the appropriate subexpressions.</P><PRE>User: (findp '(believes mary (listof 'material 'moon 'stilton)) 'global)Lisp: TUser: (findx '?y '(believes mary (listof 'material 'moon ?y)) 'global)Lisp: 'STILTON</PRE><P>Unfortunately, these <TT>listof</TT> expressions can be quite cumbersome.  In order to reduce this complexity, SIF defines the read macro characters <TT>^</TT> and <TT>,</TT> to assist the user in writing such expressions in a more natural form.  The use of <TT>^</TT> signals thats the following expression is to be quoted <EM>except</EM> for those components preceded by commas.</P><PRE>User: (findx '?y '(believes mary ^(material moon ,?y)) 'global)Lisp: 'STILTON</PRE><P>The advantage of the <TT>listof</TT> representation over the <TT>quote</TT> representation is that it allows us to quantify over parts of expressions.  For example, let us say that Lisa is more skeptical than Mary.  She agrees with John, but only on the composition of the moon.  The first sentence below assertsthis fact without specifically mentioning <TT>stilton</TT>.  Thus, if we were to later discover that John thought the moon to be made of rocks, then Lisa would be constrained to believe this as well.  The second sentence relates our assertion about Lisa's beliefs to the world of real objects, not just symbols.</P><PRE>User: (save '(<= (believes lisa ^(material moon ,?y))                 (believes john ^(material moon ,?y))) 'global)User: (findp '(believes lisa '(material moon stilton)) 'global)Lisp: T</PRE><P>Another use of <TT>quote</TT> and <TT>listof</TT> is in the formalization of rules of inference.  For example, the following sentence formalizes the ordered resolution rule of inference for ground clauses.  If the first literals in two clauses are complementary, then it is legal to conclude the clause consisting of the remaining literals of each clause.  (Adding unification to this formalization to handle non-ground clauses presents no serious problems.)</P><PRE>User: (save '(<= (resolution ^(or ,?p ,@l)                             ^(or (not ,?p) ,@m)                             ^(or ,@n))                 (= (append (listof @l) (listof @m)) (listof @n)))            'global)</PRE><P>With this information, it is possible for the system to answer metalevel questions about resolution, like the one shown.</P><PRE>User: (findx '?r '(resolution '(or p q) '(or (not p) (not r)) ?r) 'global)Lisp: (LISTOF 'OR 'Q '(NOT R))</PRE><P>While there is little practical value to defining resolution in this way, this example illustrates the power of the representation and the Epilog routines.  More practical examples of this include representation of knowledge about the beliefs, goals, interests, and capabilities of agents and metainformation useful in the control of reasoning.</P><H2>6. Procedural Attachments</H2><P>The knowledge base manipulation routines in Epilog are unable to answer even the simplest questions of arithmetic or equality (unless those facts are explicitly stored).  By contrast, the inference subroutines have knowledge of many basic concepts of SIF, e.g the <TT>&lt;</TT> concept.</P><PRE>User: (findp '(> 3 2) 'global)Lisp: T</PRE><P>Predefined terms are evaluated using the <TT>==</TT> relation.  In this case, the second argument to <TT>==</TT> may be a variable.</P><PRE>User: (findp '(== (+ 2 2) 4) 'global)Lisp: TUser: (findx '?x '(== (+ 2 2) ?x) 'global)Lisp: 4</PRE><P>In addition to these concept-specific attachments, there is a simple but powerful procedural attachment mechanism.  The function constant <TT>execute</TT> takes as argument a fragment of Lisp.  Whenever an equation with an <TT>execute</TT> term as first argument is evaluated, the specified procedure is called on the specified arguments and the a description of the value is unified with the term occurring as the second argument of the equation.  The following examples illustrate this mechanism.</P><PRE>User: (findp '(== (execute (listp '(a b c))) 't) 'global)Lisp: T</PRE><P>Note that calls can be made to the inference routine itself and thus implement a kind of nonmonotonic reasoning.</P><PRE>User: (deftheory global        (parent art bob)        (parent art bea)        (parent art bess)        (= (length (listof)) 0)        (<= (= (length (listof ?x @l)) ?n)               (= (length (listof @l)) ?n1)               (== (+ ?n1 1) ?n))        (<= (= (numchildren ?x) ?z)            (== (execute (finds '?y '(parent art ?y) 'global)) ?y)            (= (length ?y) ?z)))Lisp: DONEUser: (findval '(numchildren art) 'global)Lisp: 3</PRE><H2>7. Conclusion</H2><P>Epilog also includes a full range of utilities (e.g. secondary storage handling) and debugging aids (e.g. for tracing inference routines).</P><P>Please remember that this document is just an introduction to Epilog.  It is intended to be suggestive, not exhaustive.  Although the subroutines presented here illustrate the key features of Epilog, there are many other subroutines as well.  Although the examples used here are quite simple (in keeping with the introductory nature of the presentation), Epilog is intended for use in the construction of very complex knowledge-based systems.</P></BODY></HTML>