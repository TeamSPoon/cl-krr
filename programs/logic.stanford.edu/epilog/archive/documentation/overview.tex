%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\font\eightrm=cmr10 scaled 800\font\eightbf=cmb10 scaled 800\font\twelverm=cmr10 scaled \magstep1\font\twelvebf=cmbx10 scaled \magstep1\font\fourteenrm=cmr10 scaled \magstep2\font\fourteenbf=cmbx10 scaled \magstep2\def\chapter#1#2{\bigskip\hfil{\twelvebf Chapter #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1}\sectioncount=0}\def\appendix#1#2{\bigskip\hfil{\twelvebf Appendix #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1\sectioncount=0}}\def\nochapter#1{\centerline{\fourteenbf #1}\bigskip\sectioncount=0}\def\thechapter{1}\countdef\sectioncount=11\countdef\subsectioncount=13\countdef\subsubsectioncount=15\sectioncount=0\subsectioncount=0\subsubsectioncount=0\def\section#1{\advance\sectioncount by 1\subsectioncount=1\bigskip\noindent{\bf\S\thechapter.\the\sectioncount\ #1}\par\nobreak\medskip}\def\subsection#1{\advance\subsectioncount by 1\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\nosection#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\sect#1{\advance\sectioncount by1\subsectioncount=0\bigskip\noindent{\bf\the\sectioncount. #1}\par\medskip}\def\subsect#1{\advance\subsectioncount by 1\subsubsectioncount=0\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount\ #1}\par\nobreak\medskip}\def\subsubsect#1{\advance\subsubsectioncount by 1\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount.\the\subsubsectioncount\ #1}\par\nobreak\medskip}\def\nosect#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\heading#1{\bigskip\noindent{\bf#1}\par\medskip}\countdef\equationcount=17\equationcount=0\def\equation{\global\advance\equationcount by 1\thechapter.\the\equationcount}\def\eq{\global\advance\equationcount by 1\the\equationcount}\countdef\count=19\count=0\def\theorem#1#2{\bigskip\noindent{\bf#1:\ }{\it#2}\par\medskip}\def\proof{\medskip\noindent{\bf Proof:\ }}\def\qed{\vtop{\hrule height 10pt width 5pt\bigskip}}\def\uncatcodespecials{\def\do##1{\catcode`##1=12}\dospecials}\def\setupverbatim{\tt\def\par{\leavevmode\endgraf}\catcode`\`=\active\obeylines\uncatcodespecials\obeyspaces}{\catcode`\`=\active \gdef`{\relax\lq}}{\obeyspaces\global\let =\ }{\obeylines\global\let^^M=\par}\def\beginverbatim{\par\begingroup\parindent=0pt\setupverbatim\doverbatim}{\catcode`|=0 \catcode`\\=12 |obeylines|gdef|doverbatim^^M#1\endverbatim{#1|endgroup}}\def\verbatim{\begingroup\setupverbatim\doverb}\def\doverb#1{\def\next##1#1{##1\endgroup}\next}\def\start{\ }\def\bibitem#1#2{\medskip\noindent}\def\cite#1{[#1]}\def\date{\the\day\ \ifcase\month\or January\or February\or March\orApril \or May\or June\or July\or August\or September\or October\or November\or December\fi\ \the\year}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\magnification=\magstep1\font\bigrm=cmr10 scaled \magstep1\def\epilog{E{\eightrm PILOG}}\def\prolog{P{\eightrm ROLOG}}\def\lisp{C{\eightrm OMMON} L{\eightrm ISP}}\def\up{$\uparrow$}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\centerline{\bf An Overview of EPILOG 2.0 for LISP}\centerline{\bf Epistemics Inc.}\bigskip\sect{Introduction}\epilog{} is a library of Common Lisp subroutines for use in programs thatmanipulate information encoded in Standard Information Format (SIF), a variantof first order predicate calculus.  It includes translators to convertexpressions from one form to another, pattern matchers of various sorts,subroutines to create and maintain SIF knowledge bases, and a sound and completeinference procedure based on model elimination.The inference procedure used in \epilog{} is based on a technique called {\itmodel elimination}.  The procedure closely resembles that of \prolog{}; but,unlike that that of \prolog{}, the procedure used in \epilog{} is sound andcomplete for the entire language, i.e. all consequences the system derives arecorrect and it can derive all correct consequences of the information it isgiven.SIF, the language supported by \epilog{}, is a proper subset of KIF (KnowledgeInterchange Format), i.e. all expressions in SIF are expressions in KIF, but notall KIF expressions are expressions in SIF.  Despite this subset relationship,SIF is fully expressive, i.e. for any set of KIF sentences, there is anequivalent set of SIF sentences.  Thus, using the subroutines in \epilog{}, it ispossible to build a sound and complete inference procedure for all of KIF.This document is a brief introduction to some of the key features of \epilog{}. For more detailed information, the reader is referred to the \epilog{} referencemanual.\sect{Standard Information Format}SIF is a prefix version of the language of first order predicate calculus withvarious extensions to enhance its expressiveness.  In \epilog{}, SIF expressionsare represented as \lisp{} atoms and lists (but not dotted pairs).The basic vocabulary of the language includes variables, logical operators,and constants.  Individual variables are distinguished by the presence of {\tt?} as initial character, and sequence variables are distinguished by thepresence of an initial {\tt @}.  There is a fixed set of operators ({\tt =},{\tt /=}, {\tt listof}, {\tt quote}, {\tt not}, {\tt and}, {\tt or}, {\tt =>},{\tt <=}).  All others words are constants.From this basic vocabulary, we can build {\it terms} to refer to objects in theuniverse of discourse, as in the following examples.\medskip\beginverbatim    (father art)    (+ 2 3)\endverbatim\medskipThe language is distinctive in its use of a quotation operator to write termsthat refer to expressions.  For example, the following term refers to theexpression {\tt (+ 2 3)} literally.\medskip\beginverbatim    (quote (+ 2 3))\endverbatim\medskipFrom terms, we can build sentences.  First and foremost this provides theability to encode simple data, as in the examples shown below.\medskip\beginverbatim    (parent art bob)    (parent art bea)    (parent bob cal)\endverbatim\medskipWe can use the {\tt =} and {\tt /=} operators to write equations andinequalities.\medskip\beginverbatim    (= (+ 2 2) 4)    (= (father art) joe)    (/= (quote (+ 2 3)) (+ 2 3))\endverbatim\medskipUsing the logical operators in SIF, it is possible to encode more complex sortsof information (such as negations, disjunctions, rules, and so forth).  Theexpression shown below is an example of a logical sentence in SIF.  It defines agrandparent as a parent of a parent.\medskip{\tt (<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))}\par\medskip\sect{Knowledge Base Manipulation}\epilog{} provides capabilities for managing knowledge bases of sentencesencoded in SIF.  In this section, we introduce the subroutines for creating,examining, and destroying knowledge bases.  We also look at \epilog{}'sheterarchical theory mechanism.The {\tt save} command is used to add facts to a specified ``theory''. Here, weadd the facts that Art is the parent of Bob, Bea, and Bess to the theory named{\tt global}.\medskip\beginverbatimUser: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent art bea) 'global)Lisp: (PARENT ART BEA)User: (save '(parent art bess) 'global)Lisp: (PARENT ART BESS)\endverbatim\medskipOnce we have some facts in a theory, we can examine its contents.  The {\ttknownp} command takes a sentence and a theory as arguments.  If the sentence isground, then {\tt knownp} succeeds if and only if the theory contains thatsentence.  If the sentence includes individual or sequence variables, {\ttknownp} succeeds if and only if the theory contains a sentence that matches theargument for some binding of the constituent variables. \medskip\beginverbatimUser: (knownp '(parent art bob) 'global)Lisp: TUser: (knownp '(parent ?x bob) 'global)Lisp: TUser: (knownp '(parent @l) 'global)Lisp: T\endverbatim\medskipThe {\tt knownx} command takes an expression, a sentence, and a theory asarguments.  If the theory contains a matching sentence, {\tt knownx} plugs thevariable bindings (if any) into the specified expression and returns the answer. There is no restriction on the position of the variables in the query.  Note thatthere are three possible answers for the second query.  The {\tt knownx}subroutine always returns the first answer it finds.  \medskip\beginverbatimUser: (knownx '?x '(parent ?x bob) 'global)Lisp: ARTUser: (knownx '?y '(parent art ?y) 'global)Lisp: BOBUser: (knownx '(related @l) '(parent @l) 'global)Lisp: (RELATED ART BOB)\endverbatim\medskipThe {\tt knowns} subroutine is similar to {\tt knownx} except that it returns alist of all possible answers.  The order of answers on the list is the order inwhich they are found in the theory.\medskip\beginverbatimUser: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA BESS)User: (knowns '(related ?x ?y) '(parent ?x ?y) 'global)Lisp: ((RELATED ART BOB) (RELATED ART BEA) (RELATED ART BESS))\endverbatim\medskipThe {\tt knowng} subroutine takes the same arguments as {\tt knownx} and {\ttknowns} and returns an answer generator as value.  Each time this generator iscalled, it returns a different answer to the orginal question.  When allanswers have been exhausted, it return {\tt nil}. \medskip\beginverbatimUser: (setq gen (knowng '?y '(parent art ?y) 'global))Lisp: #<continuation23>User: (funcall gen)Lisp: BOBUser: (funcall gen)Lisp: BEAUser: (funcall gen)Lisp: BESSUser: (funcall gen)Lisp: NIL\endverbatim\medskipThe {\tt drop} subroutine is used to delete sentences from a theory.  If {\ttdrop} succeeds in finding a matching sentence to remove, it returns the sentenceas value.\medskip\beginverbatimUser: (drop '(parent art bess) 'global)Lisp: (PARENT ART BESS)User: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA)\endverbatim\medskipBy specifying different theory arguments to these subroutines, we can manipulatetheories without affecting other theories.  For example, here we add somesentences to a new theory, called {\tt mytheory}.  Notice that only the newinformation is available in this new theory.\medskip\beginverbatimUser: (save '(parent art bill) 'mytheory)Lisp: (PARENT ART BILL)User: (save '(parent art betty) 'mytheory)Lisp: (PARENT ART BETTY)User: (knowns '?y '(parent art ?y) 'mytheory)Lisp: (BILL BETTY)\endverbatim\medskipAnother way of creating a theory is to use the {\tt deftheory} command.  Thissubroutine takes a theory name and a list of sentences as arguments and arrangesthat the theory contains exactly those sentences specified and no more.  Here, wecreate a theory called {\tt another} with two more facts about Art.\medskip\beginverbatimUser: (deftheory anotherUser:   (parent art ben)User:   (parent art barbara))Lisp: ANOTHERUser: (knowns '?y '(parent art ?y) 'another)Lisp: (BEN BARBARA)\endverbatim\medskipOf course, we can still access our old theory by passing its name as argument. In the following example, we access our old data by specifying {\tt global} inour call to {\tt knowns}.\medskip\beginverbatimUser: (knowns '?y '(parent art ?y) 'global)Lisp: (BOB BEA)\endverbatim\medskipOften in working with theories, it is useful to include the facts from onetheory inside of another theory.  We can do this by using the {\tt save} commandto add them in the other theory as well, but this is wasteful.  An alternative isto call the {\tt includes} routine on two theories, thereby telling the databaseroutines that the first theory implicitly includes the second.  Here, we saythat {\tt mytheory} includes {\tt global} and {\tt another} and thereby make allof the facts in these theories available whenever a subroutine accesses {\ttmytheory}.  The {\tt includees} subroutine returns a list of all theoriesincluded in the theory specified as argument.  The variable {\tt *includers*}always contains a list of theories with included theories.\medskip\beginverbatimUser: (includes 'mytheory 'global)Lisp: DONEUser: (knowns '?y '(parent art ?y) 'mytheory)Lisp: (BILL BETTY BOB BEA)User: (includees 'mytheory)Lisp: (GLOBAL)User: *includers*Lisp: (MYTHEORY)\endverbatim\medskipThe variable {\tt *theories*} contains a list of theories containing one or moresentences.  {\tt empty} removes all sentences from a given theory.  {\tt reset}resets the state of the database and all variables in \epilog{} totheir initial values.\medskip\beginverbatimUser: *theories*Lisp: (ANOTHER MYTHEORY GLOBAL)User: (empty 'global)Lisp: DONEUser: *theories*Lisp: (ANOTHER MYTHEORY)User: (reset)Lisp: DONE\endverbatim\sect{Inference}The basic reasoning program in \epilog{} is an efficient implementationof the model elimination proof procedure.  The procedure is enhanced to handlemetalevel information, and there are also some extensions to support proceduralattachment and nonmonotonic reasoning.  In this section, we take a look at thebasic first order reasoning capabilities;  the metalevel reasoning ability isdescribed in the next section; and procedural attachments and nonmonotonicreasoning are discussed in the section thereafter.The special strength of the inference subroutines is their ability to doinference with logical information encoded as implications.  Here, we enter adefinition for the {\tt grandparent} relation, and we enter some facts aboutArt's family.  Although, according to our definitions, Art is the grandparent ofCal, {\tt knownp} answers {\tt nil}.  This is the correct answer for {\tt knownp}-- after all, the fact is not stored explicitly in the theory.  By contrast, {\ttfindp} is able to prove the fact.  The {\tt findx} subroutine is able to find agrandparent of Cal and a grandchild of Art.  The {\tt finds} subroutine isable to find all of the grandchildren of Art.  The {\tt findg} subroutinereturns a generator.\medskip\beginverbatimUser: (save '(<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))            'global)Lisp: (<= (GRANDPARENT ?X ?Z) (PARENT ?X ?Y) (PARENT ?Y ?Z))User: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent bob cal) 'global)Lisp: (PARENT BOB CAL)User: (save '(parent bob coe) 'global)Lisp: (PARENT BOB COE)User: (knownp '(grandparent art cal) 'global)Lisp: NILUser: (findp '(grandparent art cal) 'global)Lisp: TUser: (findx '?x '(grandparent ?x cal) 'global)Lisp: ARTUser: (findx '?y '(grandparent art ?y) 'global)Lisp: CALUser: (finds '?y '(grandparent art ?y) 'global)Lisp: (CAL COE)User: (setq gen (findg '?y '(grandparent art ?y) 'global))Lisp: #<continuation24>User: (funcall gen)Lisp: CALUser: (funcall gen)Lisp: COEUser: (funcall gen)Lisp: NIL\endverbatim\medskipThe inference subroutines introduced so far illustrate backward reasoning (fromthe goal to premises using backward implications).  \epilog{} is alsocapable of forward reasoning (from premises to conclusions using forwardimplications).As an example, consider the following interaction.  By setting {\tt *saves*} to{\tt (family)}, the user directs the system to save literals involving the {\ttfamily} relation.  The forward implication asserts that, if a person is in aparticular family, then all of his children are in that family as well.  Bywriting it as a forward implication, we are saying that the implication should betriggered whenever we get information about a person's family.  The subroutine{\tt assume} is used to add sentences to the database and conduct all suchforward chaining.  If we discover that Art is a Garfunkel, then we immediatelyconclude that Bob and Cal and Coe are Garfunkels as well and these facts arestored explicitly in the database.\medskip\beginverbatimUser: (setq *saves* '(family))Lisp: (FAMILY)User: (save '(=> (family ?x ?z) (parent ?x ?y) (family ?y ?z)) 'global)Lisp: (=> (FAMILY ?X ?Z) (PARENT ?X ?Y) (FAMILY ?Y ?Z))User: (assume '(family art garfunkel) 'global)Lisp: DONEUser: (knowns '?x '(family ?x garfunkel) 'global)Lisp: (ART BOB CAL COE)\endverbatim\medskipSo far, we have concentrated exclusively on relations.  Much, if not most, ofour conceptualization of the world naturally takes the form of functions.  Forfunctional information, we use a notation much closer to that of \lisp{}.  If alist is empty, the result of appending the list onto a second list is justthe second list; otherwise, the result is obtained by adding the first elementof the list to the result of appending the rest of the list to the second list.\medskip\beginverbatimUser: (save '(= (append (listof) ?m) ?m) 'global)User: (save '(<= (= (append (listof ?x @l) ?m) (listof ?x @n))                 (= (append (listof @l) ?m) (listof @n)))            'global)\endverbatim\medskipNow it is possible to append two lists by making a call to the {\tt findx}routine.\medskip \beginverbatimUser: (findx '?z '(= (append (listof 1 2) (listof 3 4)) ?z) 'global)Lisp: (listof 1 2 3 4)\endverbatim\medskipThe inference subroutines also include a subroutine, called {\tt findval},capable of evaluating terms directly.\medskip \beginverbatimUser: (findval '(append (listof 1 2) (listof 3 4)) 'global)Lisp: (listof 1 2 3 4)\endverbatim\medskipHere, we have a more interesting example of automated reasoning.  Given theaxioms of equality (reflexivity, symmetry, and transitivity) and the groupaxioms (left and right identities for the {\tt *} function, right inverse, andassociativity), we ask the system to prove that the right inverse is also a leftinverse.\medskip \beginverbatimUser: (deftheory equality        (<= (= ?x ?y) (== ?x ?y))        (= ?x ?x)        (<= (= ?x ?y) (= ?y ?x))        (<= (= ?x ?z) (= ?x ?y) (= ?y ?z)))Lisp: EQUALITYUser: (deftheory group        (<= (= (* ?x ?y) ?x) (= ?y e))        (<= (= (* ?y ?x) ?x) (= ?y e))        (<= (= (* ?x ?y) e) (= ?y (inv ?x)))        (<= (= (* ?x ?v) ?w)            (= (* ?y ?z) ?v)            (= (* ?x ?y) ?u)            (= (* ?u ?z) ?w)))Lisp: GROUPUser: (includes 'group 'equality)Lisp: DONEUser: (setq *depth* 5)Lisp: 5User: (findp '(= (* (inv x) x) e) 'group)Lisp: T\endverbatim\medskipProblems like this one are much more complicated than the simpler examples shownearlier.  While \epilog{} can handle such cases, the computationalcost can be quite large.  For example, the computational cost for the previousexamples is just a few milliseconds apiece, whereas the cost in this case isabout a second, and the cost to prove more complicated theorems can be muchhigher.  Fortunately, the inference algorithm used in \epilog{} isquite simple; and, as a result, it is usually possible to predict itscomputational performance on a given knowledge base and to control thatperformance by writing sentences in a judicious manner.\sect{Metaknowledge}One of the distinctive features of SIF is that it allows us to express knowledgeabout knowledge.  In order to encode such {\it metaknowledge}, we use aconceptualization in which expressions in the language are treated as objects inthe universe of discourse and in which there are functions and relationsappropriate to these objects.  In SIF, atoms are treated as primitive objects(i.e. having no subparts).  Complex expressions (i.e. non-atoms) are treatedas lists of subexpressions (either atoms or other complex expressions).  Inparticular, every complex expression is viewed as a list of its immediatesubexpressions.In order to assert properties of expressions in the language, we need a way ofreferring to those expressions.  There are two ways of doing this in SIF.  Oneway is to use the {\tt quote} operator in front of an expression.  For example,to refer to the symbol {\tt john}, we use the term {\tt 'john} or, equivalently,{\tt (quote john)}.  To refer to the expression {\tt (p a b)}, we use the term{\tt '(p a b)} or, equivalently, {\tt (quote (p a b))}.With a way of referring to expressions, we can assert their properties.  Forexample, the following sentence ascribes to the individual named {\tt john} thebelief that the moon is made of a particular kind of blue cheese.\medskip\beginverbatimUser: (save '(believes john '(material moon stilton)) 'global)Lisp: (BELIEVES JOHN '(MATERIAL MOON STILTON))\endverbatim\medskipSince expressions are first-order objects, we can quantify over them, therebyasserting properties of whole classes of sentences.  For example, we could saythat Mary believes everything that John believes.  This fact together with thepreceding fact allows us to conclude that Mary also believes the moon to be madeof blue cheese.\medskip\beginverbatimUser: (save '(<= (believes mary ?p) (believes john ?p)) 'global)Lisp: (<= (BELIEVES MARY ?P) (BELIEVES JOHN ?P))User: (findp '(believes mary '(material moon stilton)) 'global)Lisp: T\endverbatim\medskipThe second way of referring to expressions is SIF is to use the {\tt listof}operator.  We can denote a complex expression like {\tt (p a b)} by a term ofthe form {\tt (listof 'p 'a 'b)}, as well as {\tt '(p a b)}.  All of \epilog{}'ssubroutines treat the {\tt quote} and {\tt listof} forms of denotation asequivalent.  If variables are included in the list form, then any attempt tomatch the two forms will result in the variables being bound to the appropriatesubexpressions.\medskip\beginverbatimUser: (findp '(believes mary (listof 'material 'moon 'stilton)) 'global)Lisp: TUser: (findx '?y '(believes mary (listof 'material 'moon ?y)) 'global)Lisp: 'STILTON\endverbatim\medskipUnfortunately, these {\tt listof} expressions can be quite cumbersome.  In orderto reduce this complexity, SIF defines the read macro characters {\tt \up} and{\tt ,} to assist the user in writing such expressions in a more natural form. The use of {\tt \up} signals thats the following expression is to be quoted {\itexcept} for those components preceded by commas.\medskip\beginverbatimUser: (findx '?y '(believes mary ^(material moon ,?y)) 'global)Lisp: 'STILTON\endverbatim\medskipThe advantage of the {\tt listof} representation over the {\tt quote}representation is that it allows us to quantify over parts of expressions.  Forexample, let us say that Lisa is more skeptical than Mary.  She agrees withJohn, but only on the composition of the moon.  The first sentence below assertsthis fact without specifically mentioning {\tt stilton}.  Thus, if we were tolater discover that John thought the moon to be made of rocks, then Lisa wouldbe constrained to believe this as well.  The second sentence relates ourassertion about Lisa's beliefs to the world of real objects, not just symbols.\medskip\beginverbatimUser: (save '(<= (believes lisa ^(material moon ,?y))                 (believes john ^(material moon ,?y))) 'global)User: (findp '(believes lisa '(material moon stilton)) 'global)Lisp: T\endverbatim\medskipAnother use of {\tt quote} and {\tt listof} is in the formalization of rules ofinference.  For example, the following sentence formalizes the ordered resolutionrule of inference for ground clauses.  If the first literals in two clauses arecomplementary, then it is legal to conclude the clause consisting of theremaining literals of each clause.  (Adding unification to this formalization tohandle non-ground clauses presents no serious problems.)\medskip\beginverbatimUser: (save '(<= (resolution ^(or ,?p ,@l)                             ^(or (not ,?p) ,@m)                             ^(or ,@n))                 (= (append (listof @l) (listof @m)) (listof @n)))            'global)\endverbatim\medskipWith this information, it is possible for the system to answer metalevelquestions about resolution, like the one shown.\medskip\beginverbatimUser: (findx '?r '(resolution '(or p q) '(or (not p) (not r)) ?r) 'global)Lisp: (LISTOF 'OR 'Q '(NOT R))\endverbatim\medskipWhile there is little practical value to defining resolution in this way, thisexample illustrates the power of the representation and the \epilog{} routines. More practical examples of this include representation of knowledge aboutthe beliefs, goals, interests, and capabilities of agents and metainformationuseful in the control of reasoning.\sect{Procedural Attachments}The knowledge base manipulation routines in \epilog{} are unable to answereven the simplest questions of arithmetic or equality (unless those facts areexplicitly stored).  By contrast, the inference subroutines have knowledge ofmany basic concepts of SIF, e.g the {\tt >} concept.\medskip\beginverbatimUser: (findp '(> 3 2) 'global)Lisp: T\endverbatim\medskipPredefined terms are evaluated using the {\tt ==} relation.  In this case, thesecond argument to {\tt ==} may be a variable.\medskip \beginverbatimUser: (findp '(== (+ 2 2) 4) 'global)Lisp: TUser: (findx '?x '(== (+ 2 2) ?x) 'global)Lisp: 4\endverbatim\medskipIn addition to these concept-specific attachments, there is a simple but powerfulprocedural attachment mechanism.  The function constant {\tt execute} takes asargument a fragment of \lisp{}.  Whenever an equation with an {\tt execute} termas first argument is evaluated, the specified procedure is called on the specifiedarguments and the a description of the value is unified with the term occurringas the second argument of the equation.  The following examples illustrate thismechanism.\medskip\beginverbatimUser: (findp '(== (execute (listp '(a b c))) 't) 'global)Lisp: T\endverbatim\medskipNote that calls can be made to the inference routine itself and thus implement akind of nonmonotonic reasoning.\medskip\beginverbatimUser: (deftheory global        (parent art bob)        (parent art bea)        (parent art bess)        (= (length (listof)) 0)        (<= (= (length (listof ?x @l)) ?n)               (= (length (listof @l)) ?n1)               (== (+ ?n1 1) ?n))        (<= (= (numchildren ?x) ?z)            (== (execute (finds '?y '(parent art ?y) 'global)) ?y)            (= (length ?y) ?z)))Lisp: DONEUser: (findval '(numchildren art) 'global)Lisp: 3\endverbatim\medskip\sect{Conclusion}\epilog{} also includes a full range of utilities (e.g. secondarystorage handling) and debugging aids (e.g. for tracing inference routines).Please remember that this document is just an introduction to \epilog{}. It is intended to be suggestive, not exhaustive.  Although the subroutinespresented here illustrate the key features of \epilog{}, there are manyother subroutines as well.  Although the examples used here are quite simple (inkeeping with the introductory nature of the presentation), \epilog{} iscapable of and intended for use in the construction of very complexknowledge-based systems.\bye%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%