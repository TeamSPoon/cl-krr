%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\font\eightrm=cmr10 scaled 800\font\twelverm=cmr10 scaled \magstep1\font\twelvebf=cmbx10 scaled \magstep1\font\fourteenrm=cmr10 scaled \magstep2\font\fourteenbf=cmbx10 scaled \magstep2\def\chapter#1#2{\bigskip\hfil{\twelvebf Chapter #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1}\sectioncount=0}\def\appendix#1#2{\bigskip\hfil{\twelvebf Appendix #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1\sectioncount=0}}\def\nochapter#1{\centerline{\fourteenbf #1}\bigskip\sectioncount=0}\def\thechapter{1}\countdef\sectioncount=11\countdef\subsectioncount=13\countdef\subsubsectioncount=15\sectioncount=0\subsectioncount=0\subsubsectioncount=0\def\section#1{\advance\sectioncount by 1\subsectioncount=1\bigskip\noindent{\bf\S\thechapter.\the\sectioncount\ #1}\par\nobreak\medskip}\def\subsection#1{\advance\subsectioncount by 1\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\nosection#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\sect#1{\advance\sectioncount by1\subsectioncount=0\bigskip\noindent{\bf\the\sectioncount. #1}\par\medskip}\def\subsect#1{\advance\subsectioncount by 1\subsubsectioncount=0\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount\ #1}\par\nobreak\medskip}\def\subsubsect#1{\advance\subsubsectioncount by 1\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount.\the\subsubsectioncount\ #1}\par\nobreak\medskip}\def\nosect#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\heading#1{\bigskip\noindent{\bf#1}\par\medskip}\countdef\equationcount=17\equationcount=0\def\equation{\global\advance\equationcount by 1\thechapter.\the\equationcount}\def\eq{\global\advance\equationcount by 1\the\equationcount}\countdef\count=19\count=0\def\theorem#1#2{\bigskip\noindent{\bf#1:\ }{\it#2}\par\medskip}\def\proof{\medskip\noindent{\bf Proof:\ }}\def\qed{\vtop{\hrule height 10pt width 5pt\bigskip}}\def\uncatcodespecials{\def\do##1{\catcode`##1=12}\dospecials}\def\setupverbatim{\tt\def\par{\leavevmode\endgraf}\catcode`\`=\active\obeylines\uncatcodespecials\obeyspaces}{\catcode`\`=\active \gdef`{\relax\lq}}{\obeyspaces\global\let =\ }{\obeylines\global\let^^M=\par}\def\beginverbatim{\par\begingroup\parindent=0pt\setupverbatim\doverbatim}{\catcode`|=0 \catcode`\\=12 |obeylines|gdef|doverbatim^^M#1\endverbatim{#1|endgroup}}\def\verbatim{\begingroup\setupverbatim\doverb}\def\doverb#1{\def\next##1#1{##1\endgroup}\next}\def\start{\ }\def\bibitem#1#2{\medskip\noindent}\def\cite#1{[#1]}\def\date{\the\day\ \ifcase\month\or January\or February\or March\orApril \or May\or June\or July\or August\or September\or October\or November\or December\fi\ \the\year}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\magnification=\magstep1\font\bigrm=cmr10 scaled \magstep1\def\epilog{E{\eightrm PILOG}}\def\prolog{P{\eightrm ROLOG}}\def\lisp{C{\eightrm OMMON} L{\eightrm ISP}}\def\up{$\uparrow$}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\centerline{\bf Converting KIF to SIF}\centerline{\bf Epistemics Inc.}\bigskipSimplified Interchange Format (SIF) is a proper subset of Knowledge InterchangeFormat (KIF).  Every expression in SIF is an expression in KIF, but not everyexpression in KIF is an expression in SIF.By and large, SIF is much simpler than KIF.  (Hence the name.)  There are nodefinitions and no nonmonotonic rules; there are no explicit quantifiers; thereare no embedded implications; and there are no complicated operators (like {\ttsetofall}, {\tt lambda}, and so forth).  Nested terms are also prohibited, withthe exception of equations and terms that are unique ``designators'' (asdescribed below). These restrictions dramatically simplify the task of automated reasoning.  Inparticular, they allow us to implement an inference procedure that is bothefficient and easily understandable.Despite the subset relationship between SIF and KIF, SIF is every bit asexpressive as KIF, i.e. for any set of KIF sentences, there is an equivalent setof SIF sentences.  \epilog{} provides subroutines capable of transforming KIFsentences into equivaent SIF sentences.The {\tt sif} subroutine converts arbitrary KIF sentences into SIF sentences inboolean form (i.e. without occurrences of {\tt <=} or {\tt =>}).  It skolemizes,converts non-primitive nested terms into equational conditions, and thenconverts to boolean form.  This is especially usefully for converting negatedgoals to SIF.  The following example assumes that {\tt b} is a nameand that {\tt f} and {\tt g} are pseudofunctionals.\medskip\beginverbatimUser: (sif '(not (r (f (g ?x)) b)))Lisp: (OR (NOT (= (G ?X) ?X1)) (NOT (= (F ?X1) ?X2)) (NOT (R ?X2 B)))\endverbatim\medskipThe {\tt rules} subroutine converts arbitrary KIF sentences into SIF rules.  Itskolemizes, converts non-primitive nested terms into equational conditions, andthen converts to backward rule form.  In the following examples, we again assumethat {\tt b} is a name and that {\tt f} and {\tt g} are pseudofunctionals.\medskip\beginverbatimUser: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R ?X2 B) (= (F ?X1) ?X2) (= (G ?X) ?X1))User: (car (rules '(<= (r (f ?x) ?y) (p ?x) (q (g ?y))))Lisp: (<= (R ?X1 ?Y) (= (F ?X) ?X1) (P ?X) (= (G ?Y) ?Y1) (Q ?Y1))\endverbatim\medskipThe {\tt rules} subroutine is guided by the settings of the variables {\tt*names*} (default {\tt t}) and {\tt *functionals*} (default {\tt nil}).  If{\tt *names*} is {\tt t}, all object constants are assumed to be {\itprimitive}.  If it is a list, only those object constants on the list areassumed to be primitive.  If {\tt *functionals*} is {\tt t}, all function constantsare assumed to produce primitive terms when applied to primitive arguments.  Ifit is a list, only those function constants on the list are assumed to produceprimitive terms.  {\tt sif} and {\tt rules} do not modify terms that, accordingto the settings of these variables, are determined to be primitive.\medskip\beginverbatimUser: (setq *functionals* '(f))Lisp: (F)User: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R (F ?X1) B) (= (G ?X) ?X1))User: (setq *functionals* '(g))Lisp: (G)User: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R ?X1 B) (= (F (G ?X)) ?X1))User: (setq *functionals* '(f g))Lisp: (F G)User: (car (rules '(r (f (g ?x)) b)))Lisp: (R (F (G ?X)) B)User: (setq *names* nil)Lisp: NILUser: (car (rules '(r (f (g a)) b)))Lisp: (<= (R (F (G ?X)) ?Y) (= B ?Y) (= A ?X))\endverbatim\medskip\bye%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%