%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\font\eightrm=cmr10 scaled 800\font\twelverm=cmr10 scaled \magstep1\font\twelvebf=cmbx10 scaled \magstep1\font\fourteenrm=cmr10 scaled \magstep2\font\fourteenbf=cmbx10 scaled \magstep2\def\chapter#1#2{\bigskip\hfil{\twelvebf Chapter #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1}\sectioncount=0}\def\appendix#1#2{\bigskip\hfil{\twelvebf Appendix #1}\medskip\hfil{\fourteenbf #2}\bigskip\def\thechapter{#1\sectioncount=0}}\def\nochapter#1{\centerline{\fourteenbf #1}\bigskip\sectioncount=0}\def\thechapter{1}\countdef\sectioncount=11\countdef\subsectioncount=13\countdef\subsubsectioncount=15\sectioncount=0\subsectioncount=0\subsubsectioncount=0\def\section#1{\advance\sectioncount by 1\subsectioncount=1\bigskip\noindent{\bf\S\thechapter.\the\sectioncount\ #1}\par\nobreak\medskip}\def\subsection#1{\advance\subsectioncount by 1\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\nosection#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\sect#1{\advance\sectioncount by1\subsectioncount=0\bigskip\noindent{\bf\the\sectioncount. #1}\par\medskip}\def\subsect#1{\advance\subsectioncount by 1\subsubsectioncount=0\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount\ #1}\par\nobreak\medskip}\def\subsubsect#1{\advance\subsubsectioncount by 1\bigskip\noindent{\bf\the\sectioncount.\the\subsectioncount.\the\subsubsectioncount\ #1}\par\nobreak\medskip}\def\nosect#1{\bigskip\noindent{\bf#1}\par\nobreak\medskip}\def\heading#1{\bigskip\noindent{\bf#1}\par\medskip}\countdef\equationcount=17\equationcount=0\def\equation{\global\advance\equationcount by 1\thechapter.\the\equationcount}\def\eq{\global\advance\equationcount by 1\the\equationcount}\countdef\count=19\count=0\def\theorem#1#2{\bigskip\noindent{\bf#1:\ }{\it#2}\par\medskip}\def\proof{\medskip\noindent{\bf Proof:\ }}\def\qed{\vtop{\hrule height 10pt width 5pt\bigskip}}\def\uncatcodespecials{\def\do##1{\catcode`##1=12}\dospecials}\def\setupverbatim{\tt\def\par{\leavevmode\endgraf}\catcode`\`=\active\obeylines\uncatcodespecials\obeyspaces}{\catcode`\`=\active \gdef`{\relax\lq}}{\obeyspaces\global\let =\ }{\obeylines\global\let^^M=\par}\def\beginverbatim{\par\begingroup\parindent=0pt\setupverbatim\doverbatim}{\catcode`|=0 \catcode`\\=12 |obeylines|gdef|doverbatim^^M#1\endverbatim{#1|endgroup}}\def\verbatim{\begingroup\setupverbatim\doverb}\def\doverb#1{\def\next##1#1{##1\endgroup}\next}\def\start{\ }\def\bibitem#1#2{\medskip\noindent}\def\cite#1{[#1]}\def\date{\the\day\ \ifcase\month\or January\or February\or March\orApril \or May\or June\or July\or August\or September\or October\or November\or December\fi\ \the\year}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\magnification=\magstep1\font\bigrm=cmr10 scaled \magstep1\def\epilog{E{\eightrm PILOG}}\def\prolog{P{\eightrm ROLOG}}\def\lisp{C{\eightrm OMMON} L{\eightrm ISP}}\def\up{$\uparrow$}\def\label#1{}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\start\hfill\date\vfill\centerline{{\fourteenbf EPILOG 2.0 for LISP}}\par\vfill\centerline{{\fourteenbf Draft}}\par\vfill\noindent (c) Copyright 1993-1995 Epistemics.  Permission ishereby granted to anyone to make copies for any non-commercial use.\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\centerline{\twelvebf Table of Contents}\def\chap#1#2{\bigskip\noindent{\bf #1}\leaders\hbox to 1em{\hss.\hss}\hfill#2\par}\def\sect#1#2{#1\leaders\hbox to 1em{\hss.\hss}\hfill#2\par}\chap{1. Introduction}{n}\sect{Overview}{n}\sect{Loading \epilog{}}{n}\sect{Reader's Guide}{n}\chap{2. Simplified Interchange Format}{n}\sect{Overview}{n}\sect{Atoms}{n}\sect{Terms}{n}\sect{Sentences}{n}\chap{3. Categorizing and Manipulating Expressions}{n}\chap{4. Pattern Matching}{n}\chap{5. Theories}{n}\sect{Overview}{n}\sect{Indexing Subroutines}{n}\sect{Theory Manipulation Subroutines}{n}\sect{Composite Theories}{n}\sect{Theory Composition Subroutines}{n}\sect{Manipulation Subroutines for Composite Theories}{n}\sect{Viewing Theories}{n}\sect{Secondary Storage}{n}\chap{6. Inference}{n}\sect{Backward Chaining}{n}\sect{Forward Chaining}{n}\sect{Search Control}{n}\sect{Reasoning with Equality}{n}\sect{Procedural Attachments}{n}\sect{Tracing}{n}\chap{7. Miscellaneous}{n}\chap{Bibliography}{n}\chap{EPILOG Variables}{n}\chap{EPILOG Subroutines}{n}\chap{Index}{n}\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{1}{Introduction}\section{Overview}\epilog{} is a library of \lisp{} subroutines that implement an efficientinference procedure for information encoded in SIF (Simplified InterchangeFormat).The inference procedure used in \epilog{} is based on a reasoning techniquecalled {\it model elimination}.  The procedure closely resembles that of\prolog{}; but, unlike that that of \prolog{}, the procedure used in \epilog{}is sound and complete for the entire language, i.e. all consequences theprocedure derives are correct and the procedure can derive all correctconsequences of the information it is given.SIF, the language supported by \epilog{}, is a subset of KIF (KnowledgeInterchange Format), i.e. all expressions in SIF are expressions in KIF, but thereverse is not true.  Despite this relationship, SIF is every bit as expressiveas KIF, i.e. for any set of KIF sentences, there is an equivalent set of SIFsentences.  Furthermore, this set of sentences can be derived automatically, and\epilog{} includes subroutines capable of performing this transformation.Given the inference procedure defined in \epilog{} and these transformationsubroutines, it is possible to build a sound and complete inference procedurefor all of KIF.  \epilog{} also includes a sound and complete informationprocedure for KIF implemented in this way.\section{Loading EPILOG}The code for \epilog{} is contained in a single file in the {\tt code}subdirectory on the \epilog{} disk.  This subdirectory contains different filesfor different implementations of \lisp{}.  The filename extension designatesthe implementation for which the file is appropriate.  For example, thefilename {\tt epilog.mcl} is the M{\eightrm ACINTOSH} \lisp{} version.  Althoughthe object code is different for each implementation of \lisp{}, thefunctionality of the library is the same in all cases.As a subroutine library, \epilog{} does not run in standalone fashion.  It isdesigned to be loaded into a running version of \lisp{} using \lisp{}'s{\tt load} routine.  Once the library is loaded, all of the variables andsubroutines are available for use; no further set up is required.Note, however, that \epilog is an extension of the \epilog{} subroutine libraryand, as such, requires that that library be loaded in order to functionproperly.  Although in some implementations it is possible to load these twolibraries in either order, it is recommended that the \epilog{} library be loadedfirst.\section{Reader's Guide}This manual provides full details on the \epilog{} library.  Chapter~2defines SIF.  Chapter~3 describes the \epilog{} facilities for transforming KIFsentences into SIF sentences.  Chapter~4 describes the SIF inference subroutinesprovided by \epilog{}.  There are two appendices.  The first gives analphabetical listing of all variables in \epilog{} together with briefdescriptions.  The first gives an alphabetical listing of all subroutiness in\epilog{}, also with brief descriptions.\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{2}{Simplified Interchange Format}\section{Overview}SIF is a prefix version of the language of first order predicate calculus withvarious extensions to enhance its expressiveness.  In \epilog{}, SIF expressionsare represented as \lisp{} atoms and lists (but not dotted pairs).First and foremost, SIF provides for the expression of simple data.  For example,the sentences shown below encode three tuples in a personnel database.  The firstelement in each list is the name of the relation (in this case {\tt salary}).Next comes the social security number of each individual, then the departmentwithin which the individual works, and, finally, the individual's salary.\medskip{\tt (salary 015-46-3946 widgets 72000)}\par{\tt (salary 026-40-9152 grommets 36000)}\par{\tt (salary 415-32-4707 fidgets 42000)}\par\medskipSIF includes a variety of logical operators to assist in the encoding of logicalinformation (such as negations, disjunctions, rules, and so forth).  Theexpression shown below is an example of a logical sentence in SIF.  It definesa grandparent as a parent of a parent.\medskip{\tt (<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))}\par\medskipOne of the distinctive features of SIF is its ability to encode knowledge aboutknowledge, using the \up{} and {\tt ,} operators and related vocabulary.  Forexample, the following sentence asserts that Joe is interested in receivingtriples in the salary relation.  The use of commas signals that the variablesshould not be taken literally.  Without the commas, this sentence would say thatJoe is interested in the sentence {\tt (salary ?x ?y ?z)} literally instead ofits instances.\medskip{\tt (interested joe \up(salary ,?x ,?y ,?z))}\par\medskipIn this chapter, we examine SIF in detail. We first look at variouscategorizations of atoms in SIF.  Given these categorizations, we then definethe terms of the language.  Finally, we define the sentences of thelanguage.  (Terms are used to denote objects in the world being described;sentences and forms are used to express facts about the world.)\section{Atoms}In SIF, all \lisp{} atoms are assigned to exactly one of three catagories:variables, operators, and constants.There are two types of variables.  {\it Individual variables} are symbols thatbegin with {\tt ?}.  {\it Sequence variables} are symbols that begin with {\tt@}.  Individual variables are used in quantifying over individual objects. Sequence variables are used in quantifying over sequences of objects.{\it Operators} are used in forming complex expressions of various sorts.  Thereare three types of operators -- term operators (the symbols in the first columnbelow), sentences operators (the symbols in the second column), and KIFoperators (the symbols in the third and fourth columns).\medskip\centerline{\vbox{\halign{\strut{\tt #}\hfil\crlistof\crquote\cr\cr\cr\cr\cr\cr\cr\cr\cr}}\hfil\vbox{\halign{\strut{\tt #}\hfil\cr=\cr/=\crnot\crand\cror\cr=>\cr<=\cr\cr\cr\cr}}\hfil\vbox{\halign{\strut{\tt #}\hfil\crsetof\crif\crcond\crthe\crsetof\crsetofall\crkappa\crlambda\crforall\crexists\cr}}\hfil\vbox{\halign{\strut{\tt #}\hfil\crdefobject\crdeffunction\crdefrelation\cr<<=\cr=>>\cr\cr\cr\cr\cr\cr}}}\medskipTerm operators and sentence operators are used in forming complex SIFepxressions.  Term operators are used in forming complex terms.  Sentenceoperators are used in forming complex sentences.  Operators of the third type,KIF operators, are not used in SIF.  The reason is a subtle.  The inferencesubroutines in \epilog{} do not give these operators any special treatment, andso they {\it can} in practice be used as constants in expressions withoutuntoward consequences.  But then we would have expressions that are illegal inKIF and that might not be acceptable to other programs.  By legislating them outof the language, we guarantee that any legal expression in SIF is a legalexpression in KIF.By convention, constants are divided into four categories -- {\it objectconstants}, {\it function constants}, {\it relation constants}, and logicalconstants.  Object constants denote objects in the world being described. Function constants denote mappings from those objects into those objects. Relation constants denote relations on those objects.  Logical constantsare similar to relation constants but have no ``arguuments''.  The types ofconstants need not be declared before they are used; those types are determinedimplicitly by the places in which they are used.SIF further subdivides objects constants into two types -- {\it names} and {\itpseudonyms}.  Intuitively, a name is a unique designator for an object in theworld being described.  An object can have at most one name; and so, if twonames are distinct, they must by definition denote distinct objects.  Bycontrast, an object can have any number of pseudonyms.In \epilog{}, all characters, strings, and numbers are names.  The status ofother constants is determined by the value of the variable {\tt *names*}.  Ifthe value of {\tt *names*} is a list, the elements of the list are considerednames as well.  If the value is a non-list, all object constants are treated asnames.  The initial value is {\tt t}, i.e. all object constants areconsidered names.SIF also subdivides function constants into two types -- {\it functionals} and{\it pseudofunctionals}.  Intuitively, a functional is used to form complexdesignators for objects, as described a few paragraphs below.  In analogy withnames and pseudonyms, the categorization of constants into functionals andpseudofunctionals is determined by the value of a variable, in this case {\tt*functionals*}.  The initial value in this case is {\tt nil}, i.e. all functionconstants are considered to be pseudofunctionals.\section{Terms}There are two types of terms -- {\it designators} and {\it descriptors}.  Thedistinction here is {\it roughly} equivalent to the distinction between namesand pseudonyms.  There are five types of designators -- individual variables,names, quotations, list terms, and functional designators.  There are two typesof descriptors -- pseudonyms and functional descriptors.{\it Quotations} involve the {\tt quote} operator and an arbitrary listexpression.  The embedded expression can be an arbitrary list structure; it need{\it not} be a legal expression in SIF.  Remember that the \lisp{} readerconverts strings of the form {\tt '$\epsilon$} into {\tt (quote $\epsilon$)}. The following are legal quotations.\medskip{\tt (quote a)}\par{\tt (quote (p (f a) b))}\par{\tt (quote (p ?x b))}\par{\tt (quote (p (quote a) b))}\par{\tt (quote (<= (>= ?x ?y) (> ?x ?y)))}\par\medskipA {\it list term} consists of the {\tt listof} operator and a finite list ofterms, terminated by an optional sequence variable.  Note that the \epilog{}subroutine library used by \epilog{} redefines the \lisp{} readtable so thatexpressions starting with the uparrow character (\up) are tranformedinto quoted symbols and lists, in a manner analogous to that of expressionsinvolving backquote ({\tt `}).  See the \epilog{} manual for more details.  Thefollowing are list terms.\medskip{\tt (listof a b c)}\par{\tt (listof a (quote b) c)}\par{\tt (listof (quote a) ?x c)}\par{\tt (listof a (listof ?x ?y ?z) c)}\par\medskipA {\it functional designator} consists of a functional and an arbitrary numberof designators, terminated by an optional sequence variable.  Note that there isno syntactic  restriction on the number of argument terms -- the same functionconstant can be applied to any number of arguments.  If {\tt a} and {\tt b} arenames and {\tt f} is a functional, then the following are functionaldesignators.\medskip{\tt (f a b)}\par{\tt (f ?x b)}\par{\tt (f (f ?x b) b)}\par\medskipA {\it functional descriptor} consists of a pseudofunctional and an arbitrarynumber of terms of any sort, terminated by an optional sequence variable. Again there is no syntactic  restriction on the number of argument terms -- thesame function constant can be applied to any number of arguments.  If {\tt a}and {\tt b} are names, {\tt f} is a functional, and {\tt g} is apseudofunctional, then the following are functional designators.\medskip{\tt (g a b)}\par{\tt (g ?x b)}\par{\tt (g (f ?x b) b)}\par\medskipNote that, while functional designators may be nested within other expressions,functional descriptors may not.  For example, if {\tt g} is a pseudofunctional,the expression {\tt (g (g ?x))} is illegal.  Fortunately, such expressions {\itcan} be written in ``expanded'' form, as described in the next chapter.\section{Sentences}From terms, we can build sentences.  There are nine types of sentences --logical constants, equations, inequalities, relational sentences, negations,conjunctions, disjunctions, forward rules, and backward rules.{\it Logical constants} are simple constants.  They are used without argumentsor other syntax to denote conditions in the world.  The following examples aresuggestive.\medskip{\tt london-is-rainy}\par{\tt san-francisco-is-foggy}\par{\tt los-angeles-is-sunny}\par\medskipAn {\it equation} is an expression of the form {\tt (= $\tau_1$ $\tau_2$)},where $\tau_1$ is an arbitrary term and $\tau_2$ is a designator.  If {\tt a}and {\tt b} are names, {\tt f} is a functional, and {\tt g} is apseudofunctional, then the following are legal equations.\medskip{\tt (= (g a) b)}\par{\tt (= (g a) (f b))}\par{\tt (= (g ?x) ?x)}\par{\tt (= (g (f ?x)) ?x)}\par\medskipAn {\it inequality} is an expression of the form {\tt (/= $\tau_1$ $\tau_2$)},where $\tau_1$ is an arbitrary term and $\tau_2$ is a designator.   If {\tt a}and {\tt b} are names, {\tt f} is a functional, and {\tt g} is apseudofunctional, then the following are legal inequalities.\medskip{\tt (/= (g a) b)}\par{\tt (/= (g a) (f b))}\par{\tt (/= (g ?x) ?x)}\par{\tt (/= (g (f ?x)) ?x)}\par\medskipA {\it relational sentence} consists of a relation constant and an arbitrarynumber of designators, terminated by an optional sequence variable.  As withfunctional designators, there is no syntactic restriction on the number ofargument terms in a relation sentence -- the same relation constant can beapplied to any finite number of arguments.  If {\tt a} and {\tt b} arenames, {\tt f} is a functional, and {\tt r} is a relation constant, then thefollowing are relational sentences.\medskip{\tt (r a b)}\par{\tt (r ?x b)}\par{\tt (r (f ?x b) b)}\par\medskipA {\it negation} is a sentence of the form {\tt (not $\sigma$)}, where $\sigma$is a relational sentence.   Note that negations cannot be nested.  If {\tt a}and {\tt b} are names, {\tt f} is a functional, and {\tt r} is a relationconstant, then the following are negations.\medskip{\tt (not (r a b))}\par{\tt (not (r ?x b))}\par{\tt (not (r (f ?x b) b))}\par\medskipA {\it conjunction} is a sentence of the form {\tt (and $\sigma_1$ ...$\sigma_n$)}, where the $\sigma_i$ are sentences of any sort except forwardrules or backward rules.  If {\tt a}, {\tt b}, and {\tt c} are names, {\tt f} isa functional, and {\tt r} is a relation constant, then the following areconjunctions.\medskip{\tt (and (r a b) (r b c))}\par{\tt (and (and (r a b) (r b c)) (r a c)}\par\medskipA {\it disjunction} is a sentence of the form {\tt (and $\sigma_1$ ...$\sigma_n$)}, where the $\sigma_i$ are sentences of any sort except forwardrules or backward rules.  If {\tt a}, {\tt b}, and {\tt c} are names, {\tt f} isa functional, and {\tt r} is a relation constant, then the following aredisjunctions.\medskip{\tt (or (r a b) (r b c))}\par{\tt (or (and (r a b) (r b c)) (r a c)}\par{\tt (or (or (r a b) (r b c)) (r a c)}\par\medskipA {\it forward rule} is a sentence of the form {\tt (=> $\sigma$ $\sigma_1$ ...$\sigma_n$ $\sigma'$)}, where $\sigma$ is an equation, inequality, relationalsentence, or negation, where $\sigma'$ is an equation, inequality, relationslsentence, or negation, and where the $\sigma_i$ are sentences of any sort exceptforward rules or backward rules.\medskip{\tt (=> (m ?x) (p ?x))}\par{\tt (=> (m ?x) (p ?x) (= (h ?x) 2))}\par\medskipA {\it backward rule} is a sentence of the form {\tt (<= $\sigma$ $\sigma_1$ ...$\sigma_n$)}, where $\sigma$ is an equation, inequality, relational sentence,or negation, where the $\sigma_i$ are sentences of any sort except forward rulesor backward rules.\medskip{\tt (<= (p ?x @l) (q ?x) (p @l))}\par{\tt (<= (r ?x) (p ?x) (q ?x))}\par{\tt (<= (r ?x) (and (p ?x) (q ?x)))}\par{\tt (<= (not (r ?x)) (or (not (p ?x)) (not (q ?x))))}\par{\tt (<= (= (g ?x) a) (r ?x))}\par\medskip\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{3}{Pattern Matching}This section describes the different matching subroutines provided in \epilog{}. Inaddition it describes the subroutines for: checking if an expression is avariable, standardizing the variables in an expression, and instantiating anexpression for some variable bindings. It is important to understand the differentmatching subroutines since the behavior of many \epilog{} subroutines can beparameterized by selecting different matching subroutines.Given two expressions, a matching operation identifies if the two expressionsare similar. The matching subroutines are ordered hierarchically, from thevery specific to the most general. Below is the set of matching subroutinesprovided in \epilog{}, listed from the most specific to the most general:\medskip\beginverbatimeqlequalidentpsamepsamelistmatchpmatcherinstpinstantiatormgupmguunifyp\endverbatim\medskipThe semantics of the first two matching operations should be clear to thosefamiliar with Lisp.  The operation {\tt eql} tests whether the two expressionsare the same object, while the operation {\tt equal} tests whether the twoexpressions have the identical structure and have the same objects at theirleaves.\medskip\beginverbatimUser: (setq a '(one two))Lisp: (ONE TWO)User: (setq b '(one two))Lisp: (ONE TWO)User: (eql a a)Lisp: TUser: (equal a a)Lisp: TUser: (eql a b)Lisp: NILUser: (equal a b)Lisp: T\endverbatim\medskipThe subroutine {\tt identp} is used to check whether two quoted expressionsdenote the same object.  Recall from the previous chapter that the KIFlanguage restricts the interpretation of quoted expressions to be theexpression that is quoted. For example, the term {\tt (quote (=> (apple ?x)(fruit ?x)))} denotes the sentence {\tt (=> (apple ?x) (fruit ?x))}. Thefunction constant {\tt quote} is opaque, and treats its arguments literally. So{\tt identp} is similar to {\tt equal}, however, there is one generalization-- aquoted list with elements $\alpha_{i}$ matches a sequence of quoted expressions$\alpha_{i}$. The following examples illustrate this.\medskip\beginverbatimUser: (identp '?x '?x)Lisp: TUser: (identp '@y '@y)Lisp: TUser: (identp '(quote ?x) '(quote ?y))Lisp: NILUser: (identp nil '(quote nil))Lisp: NILUser: (identp '(p '(g a) b) '(p (listof 'g 'a) b))Lisp: TUser: (identp '(p ?x b) '(p a b))Lisp: NIL\endverbatim\medskipThe routine {\tt identp} returns {\tt T} if the two expressions are meta-identical,and returns {\tt NIL} otherwise. Note that the quoted expression {\tt '(brothersam joe)} is meta-identical to the expression {\tt (listof 'brother 'sam 'joe)}. Thesecond expression is a sequence of the elements of the first expression quoted.The remaining matching routines {\tt samep, samelist, matchp, matcher, instp,mgup, mgu} and {\tt unifyp} are generalizations of the {\tt identp} matchingsubroutine; i.e., they support the matching operations illustrated above.\label{samep}The matching subroutine {\tt samep} is used to check whether two expressions arethe same up to variable renaming.  That is, the structures of the twoexpressions are identical, and an atom at a leaf in one expression is identicalto the atom at the corresponding leaf in the second expression, and thevariable at a leaf in one expression is mapped to a unique variable at thecorresponding leaf in the second expression.  The mapping between thevariables of the two expressions must be one-to-one. The variables of the twoexpressions are considered disjoint.\medskip\beginverbatimUser: (samep '(p ?x b) '(p ?y b))Lisp: TUser: (samep '(p ?x b) '(p a b))Lisp: NILUser: (samep '(p ?x ?y) '(p ?y ?x))Lisp: TUser: (samep '(p ?x ?y) '(p ?w ?w))Lisp: NILUser: (samep '(p ?x @y) '(p ?x ?y))Lisp: NILUser: (samep '(p ?x @y) '(p ?y @x))Lisp: T\endverbatim\medskip\label{samelist}The matching subroutine {\tt samelist} is an extension of {\tt samep}, which returnsa binding list if the two expressions are the same. It returns {\tt NIL} if thetwo expressions are not the same, and otherwise it returns a binding list. A{\tt binding list} defines the substitutions for some variables. A binding listis a Lisp {\tt alist}, where the first element of each pair is the variable whosesubstitution is being defined, and the second element of the pair is its binding.The default binding list with no substitutions is {\tt ((T . T))}.\medskip\beginverbatimUser: (samelist '(q e d) '(q e d))Lisp: ((T . T))User: (samelist '(p ?x b) '(p ?y b))Lisp: ((?X . ?Y) (T . T))User: (samelist '(p ?x b) '(p a b))Lisp: NILUser: (samelist '(p ?x ?y) '(p ?y ?x))Lisp: ((?Y . ?X) (?X . ?Y) (T . T))User: (samelist '(p ?x ?y) '(p ?a ?b))Lisp: ((?Y . ?B) (?X . ?A) (T . T))User: (samelist '(p ?x ?y) '(p ?w ?w))Lisp: NILUser: (samelist '(p ?x @y) '(p ?x ?y))Lisp: NILUser: (samelist'(p ?x @y) '(p ?y @x))Lisp: ((@Y . @X) (?X . ?Y) (T . T))\endverbatim\medskipThe routine returns {\tt NIL} if the two expressions are not the same, andotherwise it returns a binding list for the variables in the first expression.If the variables in the first expression are instantiated with this binding list,then the two expressions are meta-equivalent.\label{matchp}The routine {\tt matchp} checks if the second expression is an instance of thefirst expression, ignoring one-to-one variable renaming. The two expressions canbe matched if there is a binding list for the first expression, such that theinstantiation of the first expression by this binding list is the {\tt same} asthe second expression. The subroutine returns {\tt NIL} if the two expressions donot match, and otherwise it returns {\tt T}. The following examples illustratethe operation of the {\tt matchp} routine.\medskip\beginverbatimUser: (matchp '(p ?x b) '(p a b))Lisp: TUser: (matchp '(p ?x ?y) '(p ?y x))Lisp: TUser: (matchp '(parents bill @x) '(parents bill ralph mary))Lisp: TUser: (matchp '(p a b) '(p ?x b))Lisp: NILUser: (matchp '(p a b) '(p c ?x))Lisp: NILUser: (matchp '(p ?x b) '(p a ?x))Lisp: NILUser: (matchp '(p ?x b) '(p ?x b))Lisp: T\endverbatim\medskip\label{matcher}The matching subroutine {\tt matcher} is an extension of {\tt matchp}, whichreturns a binding list if the two expression match. The two expressions can bematched if there is a binding list for the first expression, such that theinstantiation of the first expression by this binding list is the {\tt same} asthe second expression. The subroutine returns {\tt NIL} if the two expressions donot match, and otherwise it returns the binding list for the first expression.The following examples illustrate the operation of the {\tt matcher} routine.\medskip\beginverbatimUser: (matcher '(p ?x b) '(p a b))Lisp: ((?X . A) (T . T))User: (matcher '(p ?x ?y) '(p ?y x))Lisp: ((?Y . X) (?X . ?Y) (T . T))User: (matcher '(parents bill @x) '(parents bill ralph mary))Lisp: ((@X RALPH MARY) (T . T))User: (matcher '(p a b) '(p ?x b))Lisp: NILUser: (matcher '(p a b) '(p c ?x))Lisp: NILUser: (matcher '(p ?x b) '(p a ?x))Lisp: NILUser: (matcher '(p ?x b) '(p ?x b))Lisp: ((?X . ?X) (T . T))\endverbatim\medskip\label{instp}The routine {\tt instp} is identical to {\tt matchp}, except that it checks ifthe first expression is an instance of the second expression, i.e., {\tt (instp<a> <b>)} is identical to {\tt (matchp <b> <a>)}. The routine returns {\tt T} ifthe first expression is an instance of the second expression (ignoring one-to-onevariable renaming), and otherwise it returns {\tt NIL}. The following examplesillustrate the {\tt instp} matching operation.\medskip\beginverbatimUser: (instp '(p a b) '(p ?x b))Lisp: TUser: (instp '(p ?x b) '(p a b))Lisp: NILUser: (instp '(p a b c)  '(p a @x))Lisp: T\endverbatim\medskip\label{instantiator}The matching subroutine {\tt instantiator} is an extension of {\tt instp}, whichreturns a binding list if the two expressions match. The following examplesillustrate the operation of the {\tt instantiator} routine.\medskip\beginverbatimUser: (instantiator '(p a b) '(p ?x b))Lisp: ((?X . A) (T . T))User: (instantiator '(p ?x b) '(p a b))Lisp: NILUser: (instantiator '(p a b c)  '(p a @x))Lisp: ((@x B C) (T . T))\endverbatim\medskip\label{mgup}The routine {\tt mgup} checks if there is a most general unifier of its twoarguments. Identical variables in the two expressions are treated as the sameobject; e.g., if {\tt ?x} occurs in both expressions, then it is the samevariable in both expressions. It is possible to unify the two expressions ifthere exists a binding list, such that the instantiation of the first expressionby the binding list is meta-equivalent to the instantiation of the secondexpression by the binding list. The routine returns {\tt NIL} if the twoexpressions cannot be unified, and otherwise it returns {\tt T}. The followingexamples illustrate the operation of the {\tt mgup} routine.\medskip\beginverbatimUser: (mgup '(p ?x b) '(p a ?y))Lisp: TUser: (mgup '(p ?x b) '(p a ?x))Lisp: NILUser: (mgup '(p ?x b) '(p ?x b))Lisp: TUser: (mgup '(p ?x (f ?y)) '(p (g ?u) ?v))Lisp: TUser: (mgup '(+ (2 ?x) @y) '(+ (?x ?z) 4 5))Lisp: TUser: (mgup '(+ (2 ?x) @y) '(+ (?x 3) 4 5))Lisp: NIL\endverbatim\medskip\label{mgu}The matching subroutine {\tt mgu} is an extension of {\tt mgup} which returns abinding list if its arguments unify. It is possible to unify the two expressionsif there exists a binding list, such that the instantiation of the firstexpression by the binding list is {\tt equal} to the instantiation of the secondexpression by the binding list. The routine returns {\tt NIL} if the twoexpressions cannot be unified, and otherwise it returns the binding list thatunifies the two expressions. The following examples illustrate the operation ofthe {\tt mgu} routine.\medskip\beginverbatimUser: (mgu '(p ?x b) '(p a ?y))Lisp: ((?Y . B) (?X . A) (T . T))User: (mgu '(p ?x b) '(p a ?x))Lisp: NILUser: (mgu '(p ?x b) '(p ?x b))Lisp: ((T . T))User: (mgu '(p ?x (f ?y)) '(p (g ?u) ?v))Lisp: ((?V F ?Y) (?X G ?U) (T . T))User: (mgu '(+ (2 ?x) @y) '(+ (?x ?z) 4 5))Lisp: ((@Y 4 5) (?Z . 2) (?X . 2) (T . T))User: (mgu '(+ (2 ?x) @y) '(+ (?x 3) 4 5))Lisp: NIL\endverbatim\medskipNote that {\tt mgu} returns the most general unifier of two expressions. For example, the expressions {\tt (p ?x b)} and {\tt (p ?x b)} can be unifiedwith the null binding list-- the most generalunifier. However, the two expressions can also be unified by the binding list{\tt ((?x .  $expression$) (T . T))}, where $expression$ is an arbitraryexpression.  Although the two expressions will still be meta-equivalent withthis instantiation, the resulting expression {\tt (p $expression$ b)} is not asgeneral as the original expression {\tt (p ?x b)}.The following example illustrates a potential problem in the unificationprocess.\medskip\beginverbatimUser: (let ((*occurcheck* nil)) (mgu '(p ?x (f ?x)) '(p (g ?y) ?y)))Lisp: ((?Y F ?X) (?X G ?Y) (T . T))\endverbatim\medskipAt first you might think that this answer is correct (this is what \epilog{} returns!).This is in fact what most \prolog{} systems do.  However, this answer isincorrect since the previous binding list is circular.  The variable {\tt ?x}is bound to the expression {\tt (g ?y)}, where the variable {\tt ?y} isitself bound to the expression {\tt (f ?x)}.  Thus, the variable {\tt ?x} isbound to the expression {\tt (g (f ?x))}.  This is not a valid binding listsince it is recursive-- a variable is bound to an expression containingitself.  The previous two expressions cannot be unified.\label{*occurcheck*}This is called the {\it occurs check} problem, and a more efficient algorithmcan be used if one is willing to live with the wrong answer with recursivevariable bindings (most \prolog{} systems make this tradeoff). In \epilog{} it ispossible for the user to select if the occurs check is to be performed or not.If the Lisp variable {\tt *occurcheck*} is bound to a non-nil value, then theoccurs check is performed; otherwise, it is not. The initial value of the variable{\tt *occurcheck*} is {\tt T}. The following example illustrates this.\medskip\beginverbatimUser: (mgu '(p ?x (f ?x)) '(p (g ?y) ?y))Lisp: NIL\endverbatim\medskip\label{unifyp}The routine {\tt unifyp} is similar to {\tt mgup}, except that the variablesin the two expressions are considered disjoint.  Instead of renaming thevariables in one of the expressions, the routine separates the variables inthe two expressions using additional internal data structures preventingthe potentially expensive need for copying expressions. The following examplesillustrate the operation of the {\tt unifyp} matching routine.\medskip\beginverbatimUser: (unifyp '(red ?x) '(red @x))Lisp: TUser: (unifyp '(p ?x) '(?x q))Lisp: TUser: (unifyp '(p (f x) (q y)) '(p ?x (q ?x)))Lisp: NILUser: (unifyp '(+ ?x 3 (* 2 y)) '(+ 2 3 (* 2 ?x)))Lisp: T\endverbatim\medskip\label{varp}The subroutine {\tt varp} takes one argument and returns {\tt T} if the argumentis a variable, and returns {\tt NIL} otherwise. Examples:\medskip\beginverbatimUser: (varp 'red)Lisp: NILUser: (varp '(p q))Lisp: NILUser: (varp '?x)Lisp: TUser: (varp '@x)Lisp: T\endverbatim\medskip\label{indvarp} \label{seqvarp}The subroutine {\tt indvarp} checks if its argument is a variable starting withthe character {\tt ?}. It returns {\tt T} if its argument is a variablestarting with {\tt ?}, and otherwise it returns {\tt NIL}. Similarly, thesubroutine {\tt seqvarp} checks if its argument is a sequence variable startingwith the character {\tt @}. It returns {\tt T} if its argument is a sequencevariable, and otherwise it returns {\tt NIL}.\label{stdize}The subroutine {\tt stdize} is used to standardize the variables in an expression.Standardization involves replacing every variable with a new variable of thesame type. Individual variables are replaced with new individual variables, andsequence variables are replaced with new sequence variables.\medskip\beginverbatimUser: (stdize '(forall (?x) (=> (apple ?x) (fruit ?x))))Lisp: (FORALL (?1) (=> (APPLE ?1) (FRUIT ?1)))User: (stdize '(red ?x @y))Lisp: (RED ?2 @1)\endverbatim\medskip\label{plug}The subroutine {\tt plug} takes an expression and a binding list as arguments. Itreturns a copy of the expression with its variables instantiated by the bindinglist. Note that the original expression is returned without copying if the bindinglist is empty. The following example illustrates the {\tt plug} routine:\medskip\beginverbatimUser: (mgu '(father ?x ?y) '(father fred sam))Lisp: ((?Y . SAM) (?X . FRED) (T . T))User: (plug '(parent ?x ?y) '((?Y . SAM) (?X . FRED) (T . T)))Lisp: (PARENT FRED SAM)User: (plug '(parent ?u jackson) '((?Y . SAM) (?X . FRED) (T . T)))Lisp: (PARENT ?Z JACKSON)\endverbatim\medskip\label{plugstdize}The subroutine {\tt plugstdize} takes an expression and a binding list as arguments.It returns a copy of the expression with its variables instantiated by the bindinglist.  The variables in the expression that are not bound in the binding list arereplaced with new names, as is done by {\tt stdize}. The following examplesillustrate the {\tt plugstdize} routine:\medskip\beginverbatimUser: (mgu '(father ?x ?y) '(father fred sam))Lisp: ((?Y . SAM) (?X . FRED) (T . T))User: (plugstdize '(parent ?x ?y) '((?Y . SAM) (?X . FRED) (T . T)))Lisp: (PARENT FRED SAM)User: (plugstdize '(parent ?u jackson) '((?Y . SAM) (?X . FRED) (T . T)))Lisp: (PARENT ?U JACKSON)\endverbatim\medskip\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{4}{Theories}\section{Overview}\epilog{} provides capabilities for creating, modifying, and destroying``theories'', i.e. sets of sentences encoded in KIF.  The library includes twolayers of subroutines -- indexing subroutines and theory manipulationsubroutines.The indexing subroutines provide support for theory access and modification. With these subroutines, it is possible to add sentences to a theory, deletesentences from a theory, and find all sentences containing a given atom.The theory manipulation subroutines provide similar capabilities, but they arebased on patterns rather than atoms.  For example, the {\tt save} routine checkswhether a matching sentence already exists in a theory before adding it to thetheory; the {\tt truep} routine determines whether the theory contains asentence that matches a given pattern; the {\tt drop} removes all sentencesmatching a given pattern.Theories are usually accessed and modified using the theory manipulationsubroutines.  However, in certain circumstances, it is sensible to use theindexing routines instead.  For example, a user might want to call the indexingsubroutines directly and thereby avoid the overhead of pattern matching; or theuser might want to redefine the indexing routines for those cases where thedefault indexing scheme is too inefficient and thereby enhance the efficiencyof the theory manipulation subroutines.Any symbol in \lisp{} can be a theory, and theories need not be declared.  It issufficient to pass a symbol to the indexing or theory manipulation subroutines.\section{Indexing Subroutines}\label{index}The subroutine {\tt index} is used to add sentences to a theory. The subroutinetakes two arguments, the sentence to be added and the theory to which thesentence is to be added.  Before adding the sentence to the theory, it checksthat no identical sentence is contained in the theory, as determined by {\tteq}.  Note that sentences that are {\tt equal} but not {\tt eq} are notdetected by this test; consequently, multiple calls to {\tt index} withsuch sentences will result in multiple copies being placed in the theory.  Thesubroutine always returns the first argument.\label{unindex}The subroutine {\tt unindex} is used to delete sentences from a theory. Thesubroutine takes two arguments, the sentence to be deleted and the theory fromwhich it is to be deleted.  All sentences in the theory that are {\tt eq} to thefirst argument are deleted from the theory.  The subroutine always returns thefirst argument.\label{indexps}The routine {\tt indexps} is used to return all sentences in a theory thathave subexpressions that might unify with the query. The subroutine takes twoarguments, the query expression and the theory in which to search for sentenceswith potentially matching subexpressions. However, the list returned may includesentences that do not unify with the query. The order of the sentences in thelist is the same as the order in whihc the sentences were added to the theory.The following examples illustrate the behavior of these subroutines.\medskip\beginverbatimUser: (index '(brother ralph sue) 'global)Lisp: (BROTHER RALPH SUE)User: (index '(sister sue ralph) 'global)Lisp: (SISTER SUE RALPH)User: (index '(=> (father ?x ?y) (child ?y ?x)) 'global)Lisp: (=> (FATHER ?X ?Y) (CHILD ?Y ?X))User: (index '(sister sue ralph) 'global)Lisp: (SISTER SUE RALPH)User: (indexps 'brother 'global)Lisp: ((BROTHER RALPH SUE))User: (indexps 'ralph 'global)Lisp: ((BROTHER RALPH SUE) (SISTER SUE RALPH) (SISTER SUE RALPH))User: (indexps '(brother ralph sue) 'global)Lisp: ((BROTHER RALPH SUE))User: (indexps '(father jim bill) 'global)Lisp: ((=> (FATHER ?X ?Y) (CHILD ?Y ?X)))User: (indexps '?x 'global)Lisp: ((BROTHER RALPH SUE)       (SISTER SUE RALPH)       (=> (FATHER ?X ?Y) (CHILD ?Y ?X))       (SISTER SUE RALPH))User: (unindex (car (indexps '?x 'global)) 'global)Lisp: (BROTHER RALPH SUE)User: (indexps '?x 'global)Lisp: ((SISTER SUE RALPH)       (=> (FATHER ?X ?Y) (CHILD ?Y ?X))       (SISTER SUE RALPH))User: (unindex '(sister sue ralph) 'global)Lisp: (SISTER SUE RALPH)User: (indexps '?x 'global)Lisp: ((SISTER SUE RALPH)       (=> (FATHER ?X ?Y) (CHILD ?Y ?X))       (SISTER SUE RALPH))User: (unindex (car (indexps '?x 'global)) 'global)Lisp: (SISTER SUE RALPH)User: (indexps '?x 'global)Lisp: ((=> (FATHER ?X ?Y) (CHILD ?Y ?X))       (SISTER SUE RALPH))\endverbatim\medskip\label{contents}The subroutine {\tt contents} takes a theory as an argument and returns a listof sentences stored in the theory. The sentences are ordered from the earliest tothe latest in the returned list.\medskip\beginverbatimUser: (index '(mathematician eudoxus) 'global)Lisp: (MATHEMATICIAN EUDOXUS)User: (index '(astronomer menaechmus) 'global)Lisp: (ASTRONOMER MENAECHMUS)User: (contents 'global)Lisp: ((MATHEMATICIAN EUDOXUS) (ASTRONOMER MENAECHMUS))\endverbatim\medskip\label{empty}The subroutine {\tt empty} is used to delete all sentences from a theory.\medskip\beginverbatimUser: (index '(mathematician eudoxus) 'global)Lisp: (MATHEMATICIAN EUDOXUS)User: (index '(astronomer menaechmus) 'global)Lisp: (ASTRONOMER MENAECHMUS)User: (empty 'global)Lisp: DONEUser: (contents 'global)Lisp: NIL\endverbatimThe variable {\tt *theories*} contains a list of theories containing one or moresentences.  The variable is set automatically by \epilog{}'s indexing routines.\medskip\beginverbatimUser: *theories*Lisp: NILUser: (index 'sunny 'lax)Lisp: SUNNYUser: (index 'foggy 'sfo)Lisp: FOGGYUser: *theories*Lisp: (SFO LAX)User: (empty 'LAX)Lisp: DONEUser: *theories*Lisp: (SFO)\endverbatim\medskip\label{define-theory}The subroutine {\tt define-theory} is used to define a theory with manysentences in one step.  The general form of the subroutine call is {\tt(define-theory $theory$ $string$ $list$)}. The contents of the theory aredeleted and replaced with the specified sentences using the subroutine {\ttindex}. The $string$ argument is a string that defines the {\tt concept}documentation for the theory. The subroutine always returns the theory argument.The documentation for a theory can be examined by using the Lisp subroutine {\ttdocumentation}, e.g., {\tt (documentation 'global 'concept)}.\label{deftheory}{\tt deftheory} is a macro that produces a call to {\tt define-theory}.  Ittakes a theory name, an optional documentation string, and a list of sentencesas arguments.  It empties the specified theory, indexes the specified sentences,and adds the specified documentation.\beginverbatimUser: (deftheory global        "The sentences for the Global theory"        (father jim ralph)        (father jim sue)        (=> (apple ?x) (fruit ?x)))Lisp: GLOBALUser: (contents 'global)Lisp: ((FATHER JIM RALPH)       (FATHER JIM SUE)       (=> (APPLE ?X) (FRUIT ?X)))User: (documentation 'global 'concept)Lisp: "The sentences for the Global theory"\endverbatim\section{Theory Manipulation Subroutines}The subroutine {\tt save} takes as argument a sentence, a theory, and anoptional equivalence checker.  If the theory contains a sentence that isequivalent (according to the specified equivalence checker), nothing happens,and {\tt save} returns {\tt nil}. Otherwise, the specified sentence is added tothe end of the theory.\medskip\beginverbatimUser: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent art bob) 'global)Lisp: NILUser: (contents 'global)Lisp: ((PARENT ART BOB))User: (save '(loves ?x ?x) 'global)Lisp: (LOVES ?X ?X)User: (save '(loves jill jill) 'global)Lisp: (LOVES JILL JILL)User: (save '(loves joe joe) 'global 'unifyp)Lisp: NILUser: (save '(loves joe jill) 'global 'unifyp)Lisp: (LOVES JOE JILL)User: (contents 'global)Lisp: ((PARENT ART BOB) (LOVES ?X ?X) (LOVES JILL JILL) (LOVES JOE JILL))\endverbatim\medskipThe subroutine {\tt drop} takes as argument a sentence, a theory, and anoptional equivalence checker.  It removes from the specified theory allsentences equivalent to the specified sentence (according to the specifiedequivalence checker).  It returns {\tt done} as value.\medskip\beginverbatimUser: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent art bea) 'global)Lisp: (PARENT ART BEA)User: (save '(parent art bess) 'global)Lisp: (PARENT ART BESS)User: (contents 'global)Lisp: ((PARENT ART BOB) (PARENT ART BEA) (PARENT ART BESS))User: (drop '(parent art bess) 'global)Lisp: DONEUser: (contents 'global)Lisp: ((PARENT ART BOB) (PARENT ART BEA))User: (drop '(parent ?x ?y) 'global)Lisp: DONEUser: (contents 'global)Lisp: ((PARENT ART BOB) (PARENT ART BEA))User: (drop '(parent ?x ?y) 'global 'unifyp)Lisp: DONEUser: (contents 'global)Lisp: NIL\endverbatim\medskip\label{kill}The subroutine {\tt kill} takes a single expression argument, and is used todelete all sentences in the current theory that have subexpressions that matchthe argument. Independent of the sentences that are deleted, the routine alwaysreturns {\tt done}.  The subroutine {\tt kill} takes a matching subroutine asoptional third argument, which defaults to {\tt samep}. \medskip\beginverbatimUser: (deftheory global        (father jim ralph)        (father jim sue)        (mother jill ralph)        (=> (apple ?x) (fruit ?x)))Lisp: GLOBALUser: (kill 'father 'global)Lisp: DONEUser: (contents 'global)Lisp: ((MOTHER JILL RALPH)       (=> (APPLE ?X) (FRUIT ?X)))User: (kill '(apple mac) 'global 'unifyp)Lisp: DONEUser: (contents 'global)Lisp: ((MOTHER JILL RALPH))\endverbatim\medskipThe {\tt truex} command takes an expression, a sentence, and a theory asarguments.  If the theory contains a matching sentence, {\tt truex} plugs thevariable bindings (if any) into the specified expression and returns the answer. There is no restriction on the position of the variables in the query.  The {\tttruex} subroutine always returns the first answer it finds.The {\tt truep} subroutine is equivalent to {\tt truex} with {\tt t} as thefirst argument.The {\tt trues} subroutine is similar to {\tt truex} except that it returns alist of all possible answers.  The order of answers on the list is the order inwhich they are found in the theory.The {\tt trueg} subroutine takes the same arguments as {\tt truex} and {\tttrues} and returns an answer generator as value.  Each time this generator iscalled, it returns a different answer to the orginal question.  When allanswers have been exhausted, it return {\tt nil}. \medskip\beginverbatimUser: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent art bea) 'global)Lisp: (PARENT ART BEA)User: (save '(parent art bess) 'global)Lisp: (PARENT ART BESS)User: (save '(=> (parent ?x ?y) (not parent ?y ?x)) 'global)Lisp: (=> (PARENT ?X ?Y) (NOT PARENT ?Y ?X))User: (truep '(parent art bob) 'global)Lisp: TUser: (truep '(parent ?x bob) 'global)Lisp: TUser: (truep '(parent @l) 'global)Lisp: TUser: (truex '?x '(parent ?x bob) 'global)Lisp: ARTUser: (truex '?y '(parent art ?y) 'global)Lisp: BOBUser: (truex '(related @l) '(parent @l) 'global)Lisp: (RELATED ART BOB)User: (trues '?y '(parent art ?y) 'global)Lisp: (BOB BEA BESS)User: (trues '(related ?x ?y) '(parent ?x ?y) 'global)Lisp: ((RELATED ART BOB) (RELATED ART BEA) (RELATED ART BESS))User: (setq gen (trueg '?y '(parent art ?y) 'global))Lisp: #<continuation23>User: (funcall gen)Lisp: BOBUser: (funcall gen)Lisp: BEAUser: (funcall gen)Lisp: BESSUser: (funcall gen)Lisp: NIL\endverbatim\medskip\section{Composite Theories}Often in working with theories, it is useful to include the facts from onetheory inside of another theory.  One way to do this is to use the {\tt save}command to add the sentences to the other theory as well, but this can bewasteful.  An alternative is to create an {\it inclusion} link between onetheory and another, thereby implicitly including the sentences of the firsttheory in the second theory.The \epilog{} {\it theory heterarchy} is a directed acyclic graph in which thenodes are theories and the arcs are inclusion links.  The graph must be acyclicin order to avoid infinite loops in the lookup routines.  {\it Warning: the useris responsible for ensuring that the graph is cycle-free; \epilog{}'s subroutinesdo not test for this condition.}As an example of the use of the theory mechanism, consider an application withfive theories: a theory of a theory of physics, a theory of economics, a theoryof mathematics, a theory of algebra, and a theory calculus.  We might want toinclude our theory of mathematics in our theory of physics and our theory ofeconomics; and we might want to include our theories of algebra and calculus inour theory of mathematics.  This can be done by setting up a theory heterarchylike the one shown below.  The arrows here point from the including theory tothe included theory.  Note that the theory of mathematics includes two othertheories and is in turn included by two other theories.\vbox to0.97in{}\centerline{\special{picture heterarchy}\hskip2.00in}\medskipIn this chapter, we first discuss the subroutines for managing the theoryheterarchy, and then we look at the \epilog{} subroutines for accessing andmodifying {\it composite theories}, i.e. theories with included theories.\section{Theory Composition Subroutines}\label{includes}The subroutine {\tt includes} takes two theories as arguments and modifies thetheory heterarchy so that the first theory includes the second.  {\tt includes}returns {\tt DONE} as value.\label{unincludes}The subroutine {\tt unincludes} takes two theories as arguments and modifiesthe theory heterarchy so that the first theory does not include the second.  Theroutine always returns {\tt DONE} as value.\label{decludes}The subroutine {\tt decludes} is used to remove all includes links for a theory.The routine returns {\tt DONE} as value.\label{includees}The subroutine {\tt includees} takes a theory as argument and returns a list oftheories that it includes. \label{includers}The subroutine {\tt includers} takes a theory as argument and returns a list oftheories in which it is included. The following examples illustrate the behavior of these subroutines.\medskip\beginverbatimUser: (includes 'c 'global)Lisp: DONEUser: (includes 'd 'global)Lisp: DONEUser: (includes 'a 'c)Lisp: DONEUser: (includes 'a 'd)Lisp: DONEUser: (includes 'b 'd)Lisp: DONEUser: (includees 'a)Lisp: (C D)User: (includees 'b)Lisp: (D)User: (includees 'c)Lisp: (GLOBAL)User: (includees 'd)Lisp: (GLOBAL)User: (includees 'global)Lisp: NILUser: (includers 'a)Lisp: NILUser: (includers 'b)Lisp: NILUser: (includers 'c)Lisp: (A)User: (includers 'd)Lisp: (A B)User: (includers 'global)Lisp: (C D)\endverbatim\medskip\label{*includers*}The variable {\tt *includers*} is a list of all theories that include oneor more subtheories.  For the graph created earlier, this variable will bebound to the list {\tt (B A D C)}.\section{Manipulation Subroutines for Composite Theories}The theory manipulation subroutines described in the preceding chapter operateonly on individual theories; inclusion links are ignored.  This allows one toexamine and modify individual theories without affecting or being affected bythe theory heterarchy.In order to allow the user to take advantage of the theory heterarchy, \epilog{}provides a series of analogous subroutines for accessing composite theories. The {\tt knownp} subroutine takes arguments and returns values in a manneranalogous to that of {\tt truep}; {\tt knownx} is analogous to {\tt truex}; {\ttknowns} is analogous to {\tt trues}; {\tt knowng} is analogous to {\tt trueg}. All of these subroutines treat the sentences in included theories as thoughstored explicitly in the including theories.\medskip\beginverbatimUser: (includes 'top 'left)Lisp: DONEUser: (includes 'top 'right)Lisp: DONEUser: (includes 'left 'bottom)Lisp: DONEUser: (save '(p a) 'top)Lisp: (P A)User: (save '(q a) 'left)Lisp: (Q A)User: (save '(r a) 'right)Lisp: (R A)User: (save '(s a) 'bottom)Lisp: (S A)User: (truep '(p a) 'top)Lisp: TUser: (truep '(q a) 'top)Lisp: NILUser: (knownp '(p a) 'top)Lisp: TUser: (knownp '(q a) 'top)Lisp: TUser: (knownp '(r a) 'top)Lisp: TUser: (knownp '(s a) 'top)Lisp: T\endverbatim\medskipIn looking up sentences in a composite theory, these subroutines first check thesentences stored explicitly in the theory.  They then look at sentences in allincluded theories, in the order in which the inclusion links were set up.  Thesearch is depth-first, so that theories included in an included theory areexamined before moving on to the next included theory.  This behavior isillustrated in the following example.\medskip\beginverbatimUser: (includes 'top 'left)Lisp: DONEUser: (includes 'top 'right)Lisp: DONEUser: (includes 'left 'bottom)Lisp: DONEUser: (save '(p a) 'top)Lisp: (P A)User: (save '(p b) 'left)Lisp: (P B)User: (save '(p c) 'right)Lisp: (P C)User: (save '(p d) 'bottom)Lisp: (P D)User: (knowns '?x '(p ?x) 'top)Lisp: (A B D C)\endverbatim\medskipNote that, if a theory is included in another theory more than once, itssentences may be examined a second time.  Hence, it is desirable to ensure thatthere is no reconvergent fanout in the theory heterarchy.  (It has beensuggested that the subroutines mark included theories so that they areprocessed only once.  This would also avoid infinite loops in the case ofcycles in the theory graph.  It is likely that this modification will be madein future versions of \epilog{}.)\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{7}{Utilities}\section{Viewing Theories}\label{show}The subroutine {\tt show} is used to {\it print} information about the sentencesin a theory. The subroutine takes as arguments a pattern (a KIF expression), atheory, and (optionally) a matching subroutine.  If no third argument issupplied, {\tt show} uses {\tt matchp}.The first argument is an expression that specifies the types of sentences in thetheory to be displayed.  All sentences that have subexpressions that match the firstargument are displayed in the order they appear in the theory.  The subroutinehas the side effect of printing the sentences with matching subexpressions andalways returns the value {\tt DONE}.\medskip\beginverbatimUser: (deftheory global        (father jim ralph)        (father jim sue)        (=> (apple ?x) (fruit ?x))        (> 16 3))Lisp: GLOBALUser: (show '?x 'global)Lisp: (FATHER JIM RALPH)      (FATHER JIM SUE)      (=> (APPLE ?X) (FRUIT ?X))      (> 16 3)      DONEUser: (show 'jim 'global)Lisp: (FATHER JIM RALPH)      (FATHER JIM SUE)      DONEUser: (show 'jill 'global)Lisp: DONEUser: (show '(father ?a sue) 'global)Lisp: (FATHER JIM SUE)      DONEUser: (show '(father ?a sue) 'global 'samep)Lisp: DONEUser: (show '(fruit ?z) 'global)Lisp: (=> (APPLE ?X) (FRUIT ?X))      DONEUser: (show '(fruit fred) 'global)Lisp: (=> (APPLE ?X) (FRUIT ?X))      DONE\endverbatim\section{Secondary Storage Subroutines}\label{load-theory}The subroutine {\tt load-theory} is used to load a set of sentences from afile into a theory. The sentences in the file can be created using a standardtext editor. The general form of the subroutine call is {\tt (load-theory$filename$ $theory$ $subroutine$)}.  The first argument specifies the pathnamefor the file that contains the sentences; the second is the theory to which thesentences are to be added; and the third is the subroutine to be used in adding thesentences to the theory.  The third argument is optional, and its default value is thesubroutine {\tt save}.The existing contents of the theory are deleted, and the sentences from the file areadded to the theory in the same order as they appear in the file. The subroutinealways returns {\tt DONE}. Since the previous contents of the theory are deleted, itmay be more efficient to use the subroutine {\tt index} to load the sentences from afile into a theory (instead of the default {\tt save}), but this should be done onlyif one is sure the file does not contain duplicate sentences.\label{load-sentences}The subroutine {\tt load-sentences} is identical to {\tt load-theory} exceptthat the existing sentences in the theory are not deleted before loading thesentences from the file.\label{dump-theory}The subroutine {\tt dump-theory} is used to save the entire contents of a theoryto a file. The general form of the subroutine call is {\tt (dump-theory $theory$$filename$)}. The sentences in the theory {\tt $theory$} are saved in the file$filename$. The sentences in the file will be in the order that theyappear in the theory.  The subroutine always returns {\tt DONE}.A useful sequence of operations to edit the contents of a theory is to savethe contents of the theory in a file using the subroutine {\tt dump-theory},edit the file using a text editor, and finally load the modified file usingthe subroutine {\tt load-theory}.\label{dump-sentences}The subroutine {\tt dump-sentences} is similar to {\tt dump-theory}, exceptthat its first argument is a list of sentences versus a theory. The general formof the subroutine call is {\tt (dump-sentences <list-of-sentences> $filename$)}.The sentences in the file will be in the same order as they are in the firstargument, and they are not transformed in any way.  The sentences are saved inthe file, and the subroutine returns {\tt DONE}.\section{Miscellaneous}The value of the variable {\tt *epilog-version*} is the currently loaded versionof \epilog{}.The subroutine {\tt reset} empties all theories, breaks all theory inclusionlinks, and setsall \epilog{} variables to their initial values.The subroutine {\tt demo} takes a file name as argument and demonstrates thecontents.  First, it instructs the user to type a carriage return to advance. When the carriage return is typed, {\tt demo} reads in one sexpression, printsit on the terminal, evaluates it, and prints the result on the terminal.  Itthen waits for the next carriage return from the user.  {\tt demo} returns {\ttdone} as value.The subroutine {\tt test} takes a filename as argument and executes each of thetests in the file.  The file consists of sequence of s-expressions. The oddnumbered s-expressions are the tests to evaluate, and the even numbereds-expressions are the expected results. An expected result of {\tt *} means thatany value is acceptable. The subroutine returns the total number of errors.\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{5}{Inference}\section{Backward Chaining}The basic reasoning method used in \epilog{} is an efficient implementationof the {\it model elimination} proof procedure \cite{Loveland} enhanced tohandle the extensions to first order logic defined in SIF (notably metalevelinformation).  There are also some extensions to support procedural attachmentand nonmonotonic reasoning.The backward chaining subroutines in \epilog{} take arguments and return valuesin a manner analogous to the lookup subroutines in \epilog{}.  {\tt findp} isanalogous to {\tt knownp}; {\tt findx} is analogous to {\tt knownx}; {\tt finds}is analogous to {\tt knowns}; and {\tt findg} is analogous to {\tt knowng}.The special strength of the inference subroutines is their ability to doinference with logical information encoded as implications.  Here, we enter adefinition for the {\tt grandparent} relation, and we enter some facts aboutArt's family.  Although, according to our definitions, Art is the grandparent ofCal, {\tt knownp} answers {\tt nil}.  This is the correct answer for {\ttknownp} -- after all, the fact is not stored explicitly in the theory.  Bycontrast, {\tt findp} is able to prove the fact.  The {\tt findx} subroutine isable to find a grandparent of Cal and a grandchild of Art.  The {\tt finds}subroutine is able to find all of the grandchildren of Art.  The {\tt findg}subroutine returns a generator.\medskip\beginverbatimUser: (save '(<= (grandparent ?x ?z) (parent ?x ?y) (parent ?y ?z))            'global)Lisp: (<= (GRANDPARENT ?X ?Z) (PARENT ?X ?Y) (PARENT ?Y ?Z))User: (save '(parent art bob) 'global)Lisp: (PARENT ART BOB)User: (save '(parent bob cal) 'global)Lisp: (PARENT BOB CAL)User: (save '(parent bob coe) 'global)Lisp: (PARENT BOB COE)User: (knownp '(grandparent art cal) 'global)Lisp: NILUser: (findp '(grandparent art cal) 'global)Lisp: TUser: (findx '?x '(grandparent ?x cal) 'global)Lisp: ARTUser: (findx '?y '(grandparent art ?y) 'global)Lisp: CALUser: (finds '?y '(grandparent art ?y) 'global)Lisp: (CAL COE)User: (setq gen (findg '?y '(grandparent art ?y) 'global))Lisp: #<continuation24>User: (funcall gen)Lisp: CALUser: (funcall gen)Lisp: COEUser: (funcall gen)Lisp: NIL\endverbatim\medskipSo far, we have concentrated exclusively on relations.  Much, if not most, ofour conceptualization of the world naturally takes the form of functions.  Forfunctional information, we use a notation much closer to that of \lisp{}.  If alist is empty, the result of appending the list onto a second list is justthe second list; otherwise, the result is obtained by adding the first elementof the list to the result of appending the rest of the list to the second list.\medskip\beginverbatimUser: (save '(= (append (listof) ?m) ?m) 'global)User: (save '(<= (= (append (listof ?x @l) ?m) (listof ?x @n))                 (= (append (listof @l) ?m) (listof @n)))            'global)\endverbatim\medskipNow it is possible to append two lists by making a call to the {\tt findx}routine.\medskip \beginverbatimUser: (findx '?z '(= (append (listof 1 2) (listof 3 4)) ?z) 'global)Lisp: (listof 1 2 3 4)\endverbatim\medskipThe inference subroutines also include a subroutine, called {\tt findval},capable of evaluating terms directly.\medskip \beginverbatimUser: (findval '(append (listof 1 2) (listof 3 4)) 'global)Lisp: (listof 1 2 3 4)\endverbatim\medskip\section{Forward Chaining}The inference subroutines introduced so far illustrate backward reasoning (fromthe goal to premises using backward implications).  \epilog{} is alsocapable of forward reasoning (from premises to conclusions using forwardimplications).As an example, consider the following interaction.  By setting {\tt *saves*} to{\tt (family)}, the user directs the system to save literals involving the {\ttfamily} relation.  The forward implication asserts that, if a person is in aparticular family, then all of his children are in that family as well.  Bywriting it as a forward implication, we are saying that the implication should betriggered whenever we get information about a person's family.  The subroutine{\tt assume} is used to add sentences to the database and conduct all suchforward chaining.  If we discover that Art is a Garfunkel, then we immediatelyconclude that Bob and Cal and Coe are Garfunkels as well and these facts arestored explicitly in the database.\medskip\beginverbatimUser: (setq *saves* '(family))Lisp: (FAMILY)User: (save '(=> (family ?x ?z) (parent ?x ?y) (family ?y ?z)) 'global)Lisp: (=> (FAMILY ?X ?Z) (PARENT ?X ?Y) (FAMILY ?Y ?Z))User: (assume '(family art garfunkel) 'global)Lisp: DONEUser: (knowns '?x '(family ?x garfunkel) 'global)Lisp: (ART BOB CAL COE)\endverbatim\medskip\section{Search Control}All \epilog{} subroutines use iterative deepening search, controlled by thevariables {\tt *start*}, {\tt *increment*}, and {\tt *depth*}.  The value of{\tt *start*} determines the starting depth cutoff.  On each cycle of iterativedeepening, this cutoff is increased by {\tt *increment*}.  The searchterminates when the cutoff exceeds {\tt *depth*}.  All subroutines set thevariable {\tt terminate*} to {\tt t} if they fail due to a depth cutoff.\medskip\beginverbatimUser: (deftheory global        (p a)        (p b)        (q b)        (<= (r ?x) (p ?x) (q ?x)))Lisp: GLOBALUser: (let ((*depth* 0)) (findp '(p a) 'global))Lisp: NILUser: *termination*Lisp: TUser: (let ((*depth* 1)) (findp '(p a) 'global))Lisp: TUser: (let ((*depth* 1)) (findp '(r b) 'global))Lisp: NILUser: *termination*Lisp: TUser: (let ((*depth* 2)) (findp '(r b) 'global))Lisp: TUser: (let ((*depth* 1)) (findp '(s b) 'global))Lisp: NILUser: *termination*Lisp: NIL\endverbatim\medskipThe value of the variable {\tt *ancestry*} determines whether or not variousinference routines save and check ancestries in processing subgoals.  In thefollowing examples, we see that, with {\tt *ancestry*} set to {\tt nil}, theinference is terminated by depth cutoff, whereas, with {\tt *ancestry*} set to{\tt t}, it is terminated quickly by an ancestry check.\medskip\beginverbatimUser: (save '(<= (t ?x) (t ?x)) 'global)Lisp: (<= (T ?X) (T ?X))User: (let ((*depth* 10) (*ancestry* nil)) (findp '(t a) 'global))Lisp: NILUser: *termination*Lisp: TUser: (let ((*depth* 10) (*ancestry* t)) (findp '(t a) 'global))Lisp: NILUser: *termination*Lisp: NIL\endverbatim\medskipUnder certain circumstances, \epilog{}'s inference routines can be guaranteedcomplete even if {\tt *ancestry*} is set to {\tt nil}, e.g. in the case oftheories consisting entirely of Horn clauses.  However, in general,completeness requires that {\tt *ancestry*} be set to {\tt t}.The logical constant {\tt cut} can be used within conjunctions, disjunctions,and rules.  The effect is that same as that of the cut in \prolog{}.  Thefollowing examples illustrate.\medskip\beginverbatimUser: (deftheory global        (p a)        (p b)        (q b)        (<= (r ?x) (p ?x) (q ?x))        (<= (s ?x) (p ?x) cut (q ?x))        (<= (s ?x) (q ?x)))Lisp: GLOBALUser: (findx '?x '(r ?x) 'global)Lisp: BUser: (findx '?x '(s ?x) 'global)Lisp: NIL\endverbatim\medskip\section{Reasoning with Equality}Equality reasoning requires that the equality axioms be provided explicitly. The primary advantage of SIF is that substitutions axioms are not necessary.As an example of reasoning with equality, consider the following theoremproving task from teh domain of abstract algebra. Given the axioms asserting theexistence of left and right identities and a right inverse for the {\tt *}operator, we ask \epilog{} to prove that the right inverse is also a leftinverse.\medskip \beginverbatimUser: (deftheory group        (<= (= (* ?x ?y) ?x) (= ?y e))        (<= (= (* ?y ?x) ?x) (= ?y e))        (<= (= (* ?x ?y) e) (= ?y (inv ?x)))        (<= (= (* ?x ?v) ?w)            (= (* ?y ?z) ?v)            (= (* ?x ?y) ?u)            (= (* ?u ?z) ?w)))Lisp: GROUPUser: (deftheory equality        (= ?x ?x)        (<= (= ?x ?y) (= ?y ?x))        (<= (= ?x ?z) (= ?x ?y) (= ?y ?z)))Lisp: EQUALITYUser: (includes 'group 'equality)Lisp: DONEUser: (setq *depth* 5)Lisp: 5User: (findp '(= (* (inv x) x) e) 'group)Lisp: T\endverbatim\medskip\section{Procedural Attachments}\epilog{} provides procedural attachments on all of KIF's arithmetic relations. These procedural attachments allow the inference routines to succeed wheneverworking on ground arithmetic literals.  They do {\it not} necessarily succeed onnon-ground literals, though it is relatively easy to implement generators for allsolutions to such problems.\medskip \beginverbatimUser: (findp '(> 3 2) 'global)Lisp: tUser: (findp '(not (> 2 3)) 'global)Lisp: tUser: (findx '?x '(> 3 ?x) 'global)Lisp: nil\endverbatim\medskipPredefined terms are evaluated using the {\tt ==} relation.  In this case, thesecond argument to {\tt ==} may be a variable.\medskip \beginverbatimUser: (findp '(== (+ 2 2) 4) 'global)Lisp: tUser: (findx '?x '(== (+ 2 2) ?x) 'global)Lisp: 4\endverbatim\medskipSuch terms are {\it not} evaluated when used in {\tt =} sentences, unless thedatabase contains an appropriate axiom linking {\tt =} to {\tt ==}.\medskip \beginverbatimUser: (findp '(= (+ 2 2) 4) 'global)Lisp: NILUser: (findx '?x '(= (+ 2 2) ?x) 'global)Lisp: NILUser: (save '(<= (= ?x ?y) (== ?x ?y)) 'global)Lisp: (<= (= ?X ?Y) (== ?X ?Y))User: (findp '(= (+ 2 2) 4) 'global)Lisp: TUser: (findx '?x '(== (+ 2 2) ?x) 'global)Lisp: 4\endverbatim\medskipIt is possible to ``implement'' arbitrary procedural attachments using the {\ttexecute} relation.  Whenever \epilog's inference procedure encounters an atomicsentence involving {\tt execute}, as either a goal or a conclusion, it uses\lisp{}'s {\tt eval} routine to evaluate the argument.  If the result isnon-null and the sentence is a goal, the goal succeeds.\medskip \beginverbatimUser: (findp '(execute (listp '(1 2 3))) 'global)Lisp: tUser: (findval '(execute (length '(1 2 3))) 'global)Lisp: 3User: (assume '(execute (princ "Hello!")) 'global)Lisp: Hello!Lisp: t\endverbatim\medskip\section{Tracing}This section describes the tracing subroutines in \epilog{}. These subroutinesare useful in acquiring justifications for conclusions and in debuggingunexpected behavior (by identifying incorrect facts).  These subroutines cannotidentify missing facts in the knowledge base directly, though it may be possibleto infer a missing fact from a trace.Whenever an \epilog{} subroutine attempts to prove a literal that matches atraced expression, the tracing routines print {\tt Call:} followed by theliteral.  An {\tt Exit:} is followed by an instance of the literal that isproved.  The inference routines try other choices if the proof attempt forone choice fails. This is indicated by a {\tt Redo:} which is followed by theliteral for which a new proof is attempted. If a proof for a sentence cannot befound, the tracing routines print {\tt Fail:} followed by the failing literal. \label{trace-expression}The subroutine {\tt trace-expression} takes any number of expressions asarguments. It sets up data structures so that \epilog{} subroutines print outappropriate messages whenever they attempt to prove literals that are {\itinstances} of the specified expressions.  Goal literals are matched with thetraced expressions using the {\tt matchp} subroutine of \epilog{}. It is possibleto trace several patterns in a single call to {\tt trace-expressions} orin separate calls.  If {\tt trace-expressions} is called without arguments, theresult is a list of the currently traced expressions.\label{untrace-expression}The subroutine {\tt untrace-expression} takes any number of expressions asarguments.  It deletes the specified expressions from the data structures setup by {\tt trace-expression} and thus turns off the corresponding tracing. Alltraced expressions are deleted if no arguments are passed, and a list of theuntraced expressions is returned.  It is possible to untrace several expressionsin a single call to {\tt untrace-expression} or in separate calls.\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\chapter{n}{Converting KIF to SIF}Simplified Interchange Format (SIF) is a proper subset of Knowledge InterchangeFormat (KIF).  Every expression in SIF is an expression in KIF, but not everyexpression in KIF is an expression in SIF.By and large, SIF is much simpler than KIF.  (Hence the name.)  There are nodefinitions and no nonmonotonic rules; there are no explicit quantifiers; thereare no embedded implications; and there are no complicated operators (like {\ttsetofall}, {\tt lambda}, and so forth).  What's more, nested terms areprohibited (except for designators, as described in the last chapter).These restrictions dramatically simplify the task of automated reasoning.  Inparticular, they allow us to implement an inference procedure that is bothefficient and easily understandable.Despite the subset relationship between SIF and KIF, SIF is every bit asexpressive as KIF, i.e. for any set of KIF sentences, there is an equivalent setof SIF sentences.  \epilog{} provides subroutines capable of transforming KIFsentences into equivaent SIF sentences.The {\tt sif} subroutine converts arbitrary KIF sentences into SIF sentences inboolean form (i.e. without occurrences of {\tt <=} or {\tt =>}).  It skolemizes,converts non-primitive nested terms into equational conditions, and thenconverts to boolean form.  This is especially usefully for converting negatedgoals to SIF.  The following example assumes that {\tt b} is a nameand that {\tt f} and {\tt g} are pseudofunctionals.\medskip\beginverbatimUser: (sif '(not (r (f (g ?x)) b)))Lisp: (OR (NOT (= (G ?X) ?X1)) (NOT (= (F ?X1) ?X2)) (NOT (R ?X2 B)))\endverbatim\medskipThe {\tt rules} subroutine converts arbitrary KIF sentences into SIF rules.  Itskolemizes, converts non-primitive nested terms into equational conditions, andthen converts to backward rule form.  In the following examples, we again assumethat {\tt b} is a name and that {\tt f} and {\tt g} are pseudofunctionals.\medskip\beginverbatimUser: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R ?X2 B) (= (F ?X1) ?X2) (= (G ?X) ?X1))User: (car (rules '(<= (r (f ?x) ?y) (p ?x) (q (g ?y))))Lisp: (<= (R ?X1 ?Y) (= (F ?X) ?X1) (P ?X) (= (G ?Y) ?Y1) (Q ?Y1))\endverbatim\medskipThe {\tt rules} subroutine is guided by the settings of the variables {\tt*names*} (default {\tt t}) and {\tt *functionals*} (default {\tt nil}).  If{\tt *names*} is {\tt t}, all object constants are assumed to be {\itprimitive}.  If it is a list, only those object constants on the list areassumed to be primitive.  If {\tt *functionals*} is {\tt t}, all function constantsare assumed to produce primitive terms when applied to primitive arguments.  Ifit is a list, only those function constants on the list are assumed to produceprimitive terms.  {\tt sif} does not modify terms that, accroding to the settingsof these variables are determined to be primitive.\medskip\beginverbatimUser: (setq *functionals* '(f))Lisp: (F)User: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R (F ?X1) B) (= (G ?X) ?X1))User: (setq *functionals* '(g))Lisp: (G)User: (car (rules '(r (f (g ?x)) b)))Lisp: (<= (R ?X1 B) (= (F (G ?X)) ?X1))User: (setq *functionals* '(f g))Lisp: (F G)User: (car (rules '(r (f (g ?x)) b)))Lisp: (R (F (G ?X)) B)User: (setq *names* nil)Lisp: NILUser: (car (rules '(r (f (g a)) b)))Lisp: (<= (R (F (G ?X)) ?Y) (= B ?Y) (= A ?X))\endverbatim\medskip\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nochapter{Bibliography}\def\bib#1{\bigskip\noindent#1\par}\bib{Epistemics: {\it EPIC 1.0 for LISP}, Epistemics Inc., 1994.}\bib{Genesereth, M. R., Fikes, R. E. et al.  Knowledge Interchange FormatVersion 3 Reference Manual, Logic-92-1, Stanford University Logic Group, 1992.}\bib{Loveland, D.}\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nochapter{EPILOG Variables}\def\variable#1#2{\bigskip\noindent\hangindent=\parindent{\tt #1}\hfil\break#2}\variable{*ancestry*}{The value of the variable {\tt *ancestry*} determineswhether or not various inference routines save and check ancestries inprocessing subgoals.  The initial value is {\tt nil}.}\variable{*depth*}{The variable {\tt *depth*} has as value a positive integerindicating the depth of search for iterative deepening.  The initial value is1000000.}\variable{*epilog-version*}{The value of {\tt *epilog-version*} is the versionof \epilog{} currently loaded.}\variable{*functionals*}{{\tt *functionals*} is a variable that determines whichfunction constants are taken as primitive.  If the value of {\tt *functionals*} isa list, the elements of the list are considered primitive.  If the value is anon-list, all atoms are treated as primitives.  The initial value is {\tt nil}.}\variable{*increment*}{The value of {\tt *increment*} is the amount by which thedepth cutoff is incremented on each round of iterative deepening.  The initialvalue is 1000.}\variable{*inferences*}{The variable {\tt *inferences*} records the number ofinference steps in the current inference process.  The value is setautomatically after each inference.}\variable{*names*}{{\tt *names*} is a variable that determines which objectconstants are taken as primitive.  Characters, strings, and numbers are alwaysprimitive.  If the value of {\tt *names*} is a list, the elements of the listare considered primitive as well.  If the value is a non-list, all atoms aretreated as primitives.  The initial value is {\tt t}.}\variable{*saves*}{The value of the variable {\tt *saves*} determines whichliterals are saved in forward chaining.  If the value of {\tt *saves*} is alist, then a derived literal is saved if and only if the first logical constant,function constant, or relation constant is an item on this list.  If the valueis anything other than a list, all derived literals are saved.  The initialvalue is {\tt nil}, i.e. nothing is saved.}\variable{*start*}{The value of {\tt *start*} is the initial depth cutoff foriterative deepening.  The initial value is 1000.}\variable{*termination*}{The variable {\tt *termination*} records whether themost recent depth-limited search attempt ended because of a depth cutoff.  Thisvalue is set automatically after each inference.}\variable{*trace-device*}{The value of the variable {\tt *trace-device*} is thedevice to which inference trace information is printed.  The default is {\tt t},which directs all inference routines to print traces on the terminal.}\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nochapter{EPILOG Subroutines}\def\routine#1#2{\bigskip\noindent\hangindent=\parindent{\tt #1}\hfil\break#2}\routine{(assume $sentence$ $theory$>)}{The subroutine {\tt assume} takes asentence and a theory as arguments.  The sentence is assumed to be a literal. {\tt assume} uses model elimination to derive conclusions from the specifiedsentence and the sentences in the specified theory and its included theories. The search is bottom-up, depth-first, and statically-ordered and uses {\tt*depth*} as a depth limit.  If it derives a literal with in which the principalconatsnt if on the list {\tt *saves*}, it saves the literal it derives into thespecified theory. {\tt assume} returns {\tt done} as value.}\routine{(discard $expression$ $theory$)}{The subroutine {\tt discard} takes anexpression and a theory as arguments and forgets all sentences containing aninstance of the specified expression from the specified theory.}\routine{(findg $term$ $sentence$ $theory$)}{The subroutine {\tt findg} takes asargument a term, a sentence, and a theory.  It returns a continuation that oneach call tries to prove the specified sentence from the specified theory andits included theories.  The search is done in iterative deepening fashion,controlled by the variables {\tt *start*}, {\tt *increment*}, and {\tt *depth*}. If the continuation is able to prove the sentence, it returns a copy of thespecified term with variables replaced by values obtained during the proofprocess.  After each successful attempt, the continuation can be called again toget the next answer.  Once all answers have been enumerated, the continuationreturns {\tt nil}.}\routine{(findp $sentence$ $theory$)}{The subroutine {\tt findp} takes a sentenceand a theory as arguments.  It tries to prove the sentence from the specifiedtheory and its included theories using model elimination.  The search is done initerative deepening fashion, controlled by the variables {\tt *start*}, {\tt*increment*}, and {\tt *depth*}.  If {\tt findp} is able to prove the sentence,it returns {\tt t}; otherwise, it returns {\tt nil}.}\routine{(finds $term$ $sentence$ $theory$)}{The subroutine {\tt finds} takes asargument a term, a sentence, and a theory.  It tries to prove the specifiedsentence from the specified theory and its included theories using modelelimination.  The search is done in iterative deepening fashion, controlled bythe variables {\tt *start*}, {\tt *increment*}, and {\tt *depth*}.  If {\ttfinds} succeeds in proving the sentence, it returns a list of copies of thespecified term, one for each way the sentence can be proved.  In each copy, thevariables are replaced by values obtained during the proof process.  If thesentence cannot be proved, {\tt finds} returns {\tt nil}.}\routine{(findx $term$ $sentence$ $theory$)}{The subroutine {\tt findx} takes asargument a term, a sentence, and a theory.  It tries to prove the specifiedsentence from the specified theory and its included theories using the modelelimination.  The search is done in iterative deepening  fashion, controlled bythe variables {\tt *start*}, {\tt *increment*}, and {\tt *depth*}.  If {\ttfindx} is able to prove the sentence, it returns a copy of the specified termwith variables replaced by values obtained during the proof process.  If itfails to prove the sentence, the value is {\tt nil}.}\routine{(findval $term$ $theory$)}{The {\tt findval} subroutine takes a term anda theory as argument.  It uses {\tt findg} to find a term that is provably equalto the specified term given the sentences in the specified theory.  If itsucceeds, it returns the primitive term as value; otherwise, it returns {\ttnil}.}\routine{(forget $sentence$ $theory$)}{The subroutine {\tt forget} takes asentence and a theory as arguments.  {\tt forget} uses model elimination toderive conclusions from the specified sentence and the sentences in thespecified theory and its included theories.  The search is bottom-up,depth-first, and statically-ordered and uses {\tt *depth*} as a depth limit. If it derives a literal with in which the principal constant is on the list{\tt *saves*}, it drops the literal from the specified theory.  {\tt forget}returns {\tt done} as value.}\routine{(primitivep $term$)}{The subroutine {\tt primitivep} takes a term asargument.  It returns {\tt t} if the term is primitive; otherwise, it returns{\tt nil}.}\routine{(pseudoprimitivep $term$)}{The subroutine {\tt pseudoprimitivep}takes a term as argument.  It returns {\tt t} if the term is pseudoprimitive;otherwise, it returns {\tt nil}.}\routine{(pseudosentencep $sentence$)}{The subroutine {\tt pseudosentencep}takes a sentence as argument.  It returns {\tt t} if the sentence is pseudoprimitive; otherwise, it returns {\tt nil}.}\routine{(rules $sentence$)}{The subroutine {\tt rules} takes a sentence asargument and returns a list of equivalent backward rules in simplifiedinterchange format.}\routine{(sif $sentence$)}{The subroutine {\tt sif} takes a sentence as argument,converts to a boolean sentence in simplified interchange format, and returns theresult.}\routine{(sifp $sentence$)}{The subroutine {\tt sifp} takes a sentence asargument.  It returns {\tt t} if the sentence is in simplified interchangeformat; otherwise, it returns {\tt nil}.}\routine{(trace-expression $expression_1$ ... $expression_n$)}{The subroutine{\tt trace-expression} takes any number of expressions as arguments.  It sets up data structures so that various proof procedures print out appropriate messageswhenever they examine expressions that are instances of the specifiedexpressions.  If no arguments are passed to {\tt trace-expression}, the resultis a list of currently traced expressions.  Otherwise, the value is {\tt done}.}\routine{(untrace-expression $expression_1$ ... $expression_n$)}{The subroutine{\tt untrace-expression} takes any number of expressions as arguments.  Iteliminates the specified expressions from the data structures set up by{\tt trace-expression} and thus turns off the corresponding tracing.  If noarguments are passed to{\tt untrace-expression}, all traced expressions aredeleted, and a list of the those expressions is returned as value.  Otherwise,the value is {\tt done}.}\vfill\eject%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nochapter{General Index}\def\index#1#2{\noindent #1\leaders\hbox to 1em{\hss.\hss}\hfill#2\par}\index{\tt *ancestry*}{n}\index{\tt *depth*}{n}\index{\tt *epilog-version*}{n}\index{\tt *functionals*}{n}\index{\tt *increment*}{n}\index{\tt *inferences*}{n}\index{\tt *names*}{n}\index{\tt *saves*}{n}\index{\tt *start*}{n}\index{\tt *termination*}{n}\index{\tt *trace-device*}{n}\index{\tt assume}{n}\index{\tt discard}{n}\index{\tt findg}{n}\index{\tt findp}{n}\index{\tt finds}{n}\index{\tt findval}{n}\index{\tt findx}{n}\index{\tt forget}{n}\index{Iterative deepening}{n}\index{Model elimination}{n}\index{Occur check}{n}\index{\tt primitivep}{n}\index{\tt pseudoprimitivep}{n}\index{\tt pseudosentencep}{n}\index{\tt rules}{n}\index{\tt sif}{n}\index{\tt trace-expression}{n}\index{\tt untrace-expression}{n}\bye%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%