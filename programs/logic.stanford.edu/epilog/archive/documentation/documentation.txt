*ANCESTRY* determines whether or not various inference routines save and  check ancestries in processing subgoals.  The default is NIL.*DEPTH* has as value a positive integer indicating the depth of search for  iterative deepening.  Its default is 1000000.*FUNCTIONALS* is a variable that determines which function constants are taken  as primitive.  If the value of *FUNCTIONALS* is a list, the elements of the  list are considered primitive.  If the value is a non-list, all atoms are  treated as primitives.  The default is NIL.*INCLUDERS* has as value a list of all theories with included subtheories.  It is updated by INCLUDES and UNINCLUDES.*INCREMENT* is the amount by which the depth cutoff is incremented on each  round of iterative deepening.*INFERENCES* records the number of inference steps in the current inference  process.*NAMES* is a variable that determines which object constants are taken  as primitive.  Numbers are always primitive.  If the value of *NAMES* is  a list, the elements of the list are considered primitive as well.  If the  value is a non-list, all atoms are treated as primitives.  The default is T.*OCCURCHECK* determines whether or not various matchers, in considering the  binding of a variable to a term, first check for occurrences of the variable  in the term.  The default value is T.*REDUCTION* determines whether or not reductions are performed.  The default  is T.*SAVES* is a variable that determines which literals are saved in forward  chaining.  If the value of *SAVES* is a list, then a derived literal is saved  if and only if its primary logical constant, function constant, or relation  constant is an item on this list.  If the value is anything other than a list,  all derived literals are saved.*START* is the initial depth cutoff for iterative deepening.*TERMINATION* records whether the most recent depth-limited search attempt  ended because of a depth cutoff.*THEORIES* has as value a list of all theories that contain sentences.*TRACE-DEVICE* is the device to which inference trace information is  printed.  The default is T, which directs all inference routines to print  traces on the terminal.(ADDCONTENT P TH)  ADDCONTENT takes a sentence and a theory as arguments and adds the specified  sentence to the sentences stored in the specified theory, updating thevariable  *THEORIES* appopriately.(ALTERNATIVEP P)  ALTERNATIVEP takes a sentence as argument.  It returns T if the sentence is   an alternative; otherwise, it returns NIL.(ALTERNATIVES P)  ALTERNATIVES takes a sentence as argument and returns the corresponding  alternatives.(ASSUME P *THEORY*)  ASSUME takes a sentence and a theory as arguments.  The sentence is assumed  to be a literal.  ASSUME uses model elimination to derive conclusions from the  specified sentence and the sentences in the specified theory and its included  theories.  The search is bottom-up, depth-first, and statically-ordered and  uses *DEPTH* as a depth limit.  If it derives a literal with relation constant  on the list *SAVES*, it saves the literal it derives into the specifiedtheory.  ASSUME returns DONE as value.(ATOMICP P)  ATOMICP takes a sentence as argument.  It returns T if the sentence is an   atomic sentence; otherwise, it returns NIL.(BIND X E1 Y E2)  BIND takes a variable, an environment, an expression, and another environment  as arguments.  It binds the specified variable in its specified environment  to have as value the sepcified expression with variable values defined in the  second specified environment.(BINDING X ENV)  BINDING takes a variable and an environmen as arguments ans returns as values  the expression associated with the variable and the environment in which its  variables are bound.  PLUG is a recursive version of BINDING.(BOOLEANIZE P)  BOOLEANIZE takes a sentence as argument, converts all logical operators  to boolean operators (i.e. NOT, AND, OR), and returns the result.(BOOLEANP P)  BOOLEANP takes a sentence as argument.  It returns T if the sentence is in   boolean form; otherwise it returns NIL.(BRF P)  BRF takes a forward or backward implication as argument, converts it into  a backward rule with the same literal ordering, and returns the result.(BRFP P)  BRFP takes a sentence as argument.  It returns T if the sentence is in   backward rule form; otherwise it returns NIL.(CLAUSEP P)  CLAUSEP takes a sentence as argument.  It returns T if the sentence is a  clause; otherwise, it returns NIL.(CLAUSES P)  CLAUSES takes a sentence as argument and returns the corresponding clauses.(CLEARCONTENT TH)  CLEARCONTENT takes a theory as argument and removes all sentences stored in  that theory.(CLEARINDEX X TH)  CLEARINDEX takes an atom and a theory as arguments and removes all sentences  indexed under the specified atom in the specified theory.(CNF P)  CNF takes a sentence as argument, converts to conjunctive normal form, and  returns the result.(CNFP P)  CNFP takes a sentence as argument.  It returns T if the sentence is in  conjunctive normal form; otherwise, it returns NIL.(CONTENTS TH)  CONTENTS takes a theory as argument and returns a list of the sentences stored  in that theory.(CONTRAPOSITIVES P)  CONTRAPOSITIVES takes a sentence as input and returns a list of all   contrapositives.(DECLUDES T1)  DECLUDES takes a theory as argument and eliminates all of its inclusion  links.  In effect, it calls UNINCLUDES on each included theory.(DEFCONCEPT NAME THEORY DOC &REST l)  DEFCONCEPT takes a concept name, a documentation string, and  a list of sentences as arguments.  It kills the concept in the  the current theory, saves the specified sentences, and adds  the specified documentation.  DEFCONCEPT is a macro and produces a call  to DEFINE-CONCEPT.(DEFINE-CONCEPT NAME THEORY DOC FACTS)  DEFINE-CONCEPT takes a concept name, a theory, a documentation string, and  a list of sentences as arguments.  It saves the specified sentences and adds  the specified documentation.  It return the name of the concept as value.(DEFINE-THEORY NAME DOC FACTS)  DEFINE-THEORY takes a theory name, a documentation string, and  a list of sentences as arguments.  It empties the specified theory,  saves the specified sentences, and adds the specified documentation.  It returns the name of the theory as value.(DEFTHEORY NAME DOC &REST l)  DEFTHEORY takes a theory name, an optional documentation string, and  a list of sentences as arguments.  It empties the specified theory,  saves the specified sentences, and adds the specified documentation.  DEFTHEORY is a macro that produces a call to DEFINE-THEORY.(DEMO f)  DEMO takes a file name as argument and demonstrates the contents.  First, it  instructs the user to type a carriage return to advance.  When the carriage  return is typed, DEMO reads in one sexpression, prints it on the terminal,  evaluates it, and prints the result on the terminal.  It then waits for the  next carriage return from the user.  DEMO returns DONE as value.(DISCARD X TH)  DISCARD takes an expression and a theory as arguments and forgets all  sentences containing an instance of the specified expression from the  specified theory.(DNF P)  DNF takes a sentence as argument, converts to disjunctive normal form, and  returns the result.(DNFP P)  DNFP takes a sentence as argument.  It returns T if the sentence is in  disjunctive normal form; otherwise, it returns NIL.(DROP P TH &OPTIONAL (F 'SAMEP))  DROP takes as argument a sentence, a theory, and an equivalence  checker.  It removes from the specified theory all sentences equivalent  to the specified sentence (according to the specified equivalence  checker).  It returns DONE as value.(DUMP-THEORY th filename)  DUMP-THEORY takes a theory and a file name as arguments.  It writes into  the specified file all of the sentences contained in the theory so that,  when loaded with LOAD-THEORY, the contents of the theory will be restored.  It returns DONE as value.(EBRFP P)  EBRFP takes a sentence as argument.  It returns T if the sentence is in   extended backward rule form; otherwise it returns NIL.(EFRFP P)  EFRFP takes a sentence as argument.  It returns T if the sentence is in   extended forward rule form; otherwise it returns NIL.(ENVINDEXPS P ENV TH)  ENVINDEXPS takes an expression, an environment, and a theory as arguments and  returns a list of sentences in the specified theory containing a component  that could potentially unify with the specified expression in the specified  environment.  ENVINDEXPS is used by all inference subroutines.  Users are free  to redefine ENVINDEXPS to implement specialized subroutines.  The default  implementation (INDEXPS P TH) ignores the environment.(FACTS X TH &OPTIONAL (F 'MATCHP))  FACTS takes as arguments an expression, a theory, an equivalence checker.  It returns a list of all sentences in the specified theory that contain  a subexpression equivalent to the specified expression (according to the  specified equivalence checker).  If no such sentences are found, it  returns NIL.(FINDG X P *THEORY*)  FINDG takes as argument a term, a sentence, and a theory.  It returns a  continuation that on each call tries to prove the specified sentence from the  specified theory and its included theories.  The search is done in iterative  deepening fashion, controlled by the variables *START*, *INCREMENT*, and  *DEPTH*.  If the continuation is able to prove the sentence, it returns a copy  of the specified term with variables replaced by values obtained during the  proof process.  After each successful attempt, the continuation can be called  again to get the next answer.  Once all answers have been enumerated, the  continuation returns NIL.(FINDP P TH)  FINDP takes a sentence and a theory as arguments.  It tries to prove the  sentence from the specified theory and its included theories using model  elimination.  The search is done in iterative deepening fashion, controlled by  the variables *START*, *INCREMENT*, and *DEPTH*.  If FINDP is able to prove  the sentence, it returns T; otherwise, it returns NIL.(FINDS X P *THEORY*)  FINDS takes as argument a term, a sentence, and a theory.  It tries to  prove the specified sentence from the specified theory and its included  theories using model elimination.  The search is depth-first and  statically-ordered and uses *DEPTH* as a depth limit.  If FINDS succeeds  in proving the sentence, it returns a list of copies of the specified term,  one for each way the sentence can be proved.  In each copy, the variables are  replaced by values obtained during the proof process.  If the sentence cannot  be proved, FINDS returns NIL.(FINDVAL X TH)  is equivalent to (FINDX '?? `(AND (= ,X ??) (PRIMITIVE ??)) TH).(FINDVALS X TH)  is equivalent to (FINDS '?? `(AND (= ,X ??) (PRIMITIVE ??)) TH).(FINDX X P *THEORY*)  FINDX takes as argument a term, a sentence, and a theory.  It tries to prove  the specified sentence from the specified theory and its included theories  using the model elimination.  The search is done in iterative deepening  fashion, controlled by the variables *START*, *INCREMENT*, and *DEPTH*.  If  FINDX is able to prove the sentence, it returns a copy of the specified term  with variables replaced by values obtained during the proof process.  If it  fails to prove the sentence, the value is NIL.(FORGET P *THEORY*)  FORGET takes a sentence and a theory as arguments.  The sentence is assumed  to be a literal.  FORGET uses model elimination to derive conclusions from the  specified sentence and the sentences in the specified theory and its included  theories.  The search is bottom-up, depth-first, and statically-ordered and  uses *DEPTH* as a depth limit.  If it derives a literal with relation constant  on the list *SAVES*, it drops the literal it derives from the specifiedtheory.  FORGET returns DONE as value.(FRF P)  FRF takes a forward or backward implication as argument, converts it into  a forward rule with the same literal ordering, and returns the result.(FRFP P)  FRFP takes a sentence as argument.  It returns T if the sentence is in   forward rule form; otherwise it returns NIL.(GETVAL X TH &OPTIONAL (F 'MATCHP))  GETVAL takes an expression <x>, a theory, and a matcher as arguments.  It  examines the specified theory for a sentence of the form (= <u> <v>), where  <u> is equivalent to <x> according to the specified matcher.  If it finds one,  it returns an appropriate instance of <v>.  Otherwise, it returns NIL.(GROUNDP X)  GROUNDP takes an expression as argument.  It returns T if the expression is  ground; otherwise, it returns NIL.(IDENTIFYP X Y)  IDENTIFYP takes two expressions as arguments and checks whether they are  meta-equivalent. IDENTIFYP returns T if the check is successful, and it  returns NIL otherwise.(IDENTP X Y)  IDENTP takes two expressions as arguments and checks whether they are  meta-equal.  IDENTP returns T if the check is successful, and it  returns NIL otherwise.(INCLUDEES TH)  INCLUDEES takes a theory as argument and returns a list of its included  theories.(INCLUDERS TH)  INCLUDERS takes a theory as argument and returns a list of theories that  include it.(INCLUDES T1 T2)  INCLUDES takes two theories as arguments.  It sets up the knowledge  base so that the first theory includes the second theory.  The variable  *INCLUDERS* is updated accordingly.(INDEX X D TH)  INDEX takes an atom X, a sentence D, and a theory TH as arguments and adds D  to the indexees of X in theory TH.(INDEXEES X TH)  INDEXEES takes an atom and a theory as arguments and returns a list of  sentences indexed under the specified atom in the specified theory.(INDEXPS P TH)  INDEXPS takes an expression and a theory as arguments and returns a list of  sentences stored in the specified theory that could potentially unify with the  specified expression.  The default version simply calls INDEXEES on theleading  non-logical constant in P.(INDVARP X)  INDVARP takes any object as argument and returns T if and only if the  object is an individual variable.(INSERT P TH)  INSERT takes a sentence p and a theory TH as arguments.  The default version  indexes P on all atoms in P (except for NIL and variables) and adds P to the  contents of TH.(INSTANTIATOR X Y)  INSTANTIATOR takes two expressions as arguments and checks whether the first  expression is an instance of the second, i.e. whether there is an alist of  variable bindings that, when substituted into the second expression,  produces an expression meta-equal to the first expression.  If there is  such an alist, it is returned as result; otherwise, the result is NIL.(INSTP X Y)  INSTP takes two expressions as arguments and checks whether the first  expression is an instance of the second, i.e. whether there is a set of  variable bindings that, when substituted into the second expression,  produces an expression meta-equal to the first expression.  INSTP returns T if the check is successful, and it returns NIL otherwise.(KILL P TH &OPTIONAL (F 'SAMEP))  KILL takes as argument an expression, a theory, and an equivalence  checker.  It removes from the specified theory all sentences that  contain a subexpression equivalent to the specified expression (according  to the specified equivalence checker).  It returns DONE as value.(KNOWNG X P TH &OPTIONAL (F 'MATCHP))  KNOWNG takes as argument an expression, a sentence, a theory, and an  equivalence checker and returns a generator as value.  On each call, the  generator uses the specified equivalence checker to determine if there is an  equivalent sentence in the theory or its included theories and, if so,  returns a copy of the expression with variables replaced by values from the  first successful equivalence check.  When all such instances have been  enumerated, the generator returns NIL.(KNOWNP P TH &OPTIONAL (F 'MATCHP))  KNOWNP takes as argument a sentence, a theory, and an equivalence  checker.  It returns T if there is an equivalent sentence in the  specified theory or its included theories (according to the specified  equivalence checker) and otherwise returns NIL.(KNOWNS X P TH &OPTIONAL (F 'MATCHP))  KNOWNS takes as argument an expression, a sentence, a theory, and an  equivalence checker.  It uses the equivalence checker to find all equivalent  sentences in the theory and its included theories and returns a list of copies  of the specified expression with variables replaced by values from thesuccessful  equivalence checks.  It returns NIL if no equivalent expressions are found.(KNOWNX X P TH &OPTIONAL (F 'MATCHP))  KNOWNX takes as argument an expression, a sentence, a theory, and an  equivalence checker.  It uses the equivalence checker to determine if there  is an equivalent sentence in the theory or its included theories and, if so,  returns a copy of the expression with variables replaced by values from the  first successful equivalence check.  Otherwise, it returns NIL.LITERALP P)  LITERALP takes a sentence as argument.  It returns T if the sentence is a   literal; otherwise, it returns NIL.(LOAD-SENTENCES FILENAME TH &OPTIONAL (G 'SAVE))  LOAD-SENTENCES takes a filename, a theory, and a subroutine as arguments.  It reads the sentences in the specified file and uses the specified  subroutine to add them to the specified theory.  It returns DONE as value.(LOAD-THEORY FILENAME TH &OPTIONAL (G 'SAVE))  LOAD-THEORY takes a filename, a theory, and a subroutine as arguments.  It first empties the specified theory.  It then reads the sentences  in the specified file and uses the specified subroutine to add them to  the specified theory.  It returns DONE as value.(MAPAND-THEORIES F TH)  MAPAND-THEORIES takes as argument a function and a theory.  It applies  the function to the theory.  If the result is NIL, MAPAND-THEORIES  returns that result as value.  Otherwise, it calls itself recursively on  the included theories, halting as soon as it obtains a null value.  If no null value is found, it returns T.(MAPAPPEND-THEORIES F TH)  MAPAPPEND-THEORIES takes as arguments a function and a theory.  It applies  the function to the theory and calls MAPAPPEND-THEORIES on the functions and  the theories included in the specified theory.  It merges the values obtained  in this process using APPEND and returns the result.(MAPC-THEORIES F TH)  MAPC-THEORIES takes as arguments a function and a theory.  It applies  the function to the theory and calls MAPC-THEORIES on the function and  the theories included in the specified theory.  It returns the specified  theory as value.(MAPCAN-THEORIES F TH)  MAPCAN-THEORIES takes as arguments a function and a theory.  It applies  the function to the theory and calls MAPCAN-THEORIES on the functions and  the theories included in the specified theory.  It merges the values obtained  in this process using NCONC and returns the result.(MAPCAR-THEORIES F TH)  MAPCAR-THEORIES takes as arguments a function and a theory.  It applies  the function to the theory and calls MAPCAR-THEORIES on the functions and  the theories included in the specified theory.  It returns a list of the  values of these calls to the function.(MAPOR-THEORIES F TH)  MAPOR-THEORIES takes as argument a function and a theory.  It applies  the function to the theory.  If the result is non-null, MAPOR-THEORIES  returns that result as value.  Otherwise, it calls itself recursively on  the included theories, halting as soon as it obtains a non-null value.  If no non-null value is found, it returns NIL.(MATCHER X Y)  MATCHER takes two expressions as arguments and checks whether the second  expression is an instance of the first, i.e. whether there is an alist of  variable bindings that, when substituted into the first expression,  produces an expression meta-equal to the second expression.  If there is  such an alist, it is returned as result; otherwise, the result is NIL.(MATCHIFYP X Y)  MATCHIFYP takes two expressions as arguments and checks whether they are  meta-unifiable.  MATCHIFYP treats the variables in the second expression  as constants. MATCHIFYP returns T if the check is successful, and it  returns NIL otherwise.(MATCHP X Y)  MATCHP takes two expressions as arguments and checks whether the second  expression is an instance of the first, i.e. whether there is a set of  variable bindings that, when substituted into the first expression,  produces an expression meta-equal to the second expression.  MATCHP returns T if the check is successful, and it returns NIL otherwise.(MGU X Y)  MGU takes two expressions as arguments and checks whether they are  meta-unifiable.  MGU returns the unifier if the check is successful,  and it returns NIL otherwise.(MGUP X Y)  MGUP takes two expressions as arguments and checks whether they are  meta-unifiable.  MGUP returns T if the check is successful, and it  returns NIL otherwise.(PLUG X ENV)  PLUG takes an expression and an alist or environment as arguments, substitutes  the associated bindings into the expression, and returns the result.  WARNING:  If the environment is empty, the original expression is returned, i.e. no copy  is made in this case.(PRIMITIVEP X)  PRIMITIVEP takes a term as argument.  It returns T if the term is primitive;  otherwise, it returns NIL.(PSEUDOPRIMITIVEP X)  PSEUDOPRIMITIVEP takes a term as argument.  It returns T if the term is  pseudoprimitive; otherwise, it returns NIL.(PSEUDOSENTENCEP P)  PSEUDOSENTENCEP takes a sentence as argument.  It returns T if thesentence is  pseudoprimitive; otherwise, it returns NIL.(REMCONTENT P TH)  REMCONTENT takes a sentence and a theory as arguments and removes the  specified sentence from the sentences stored in the specified theory, updating  the variable *THEORIES* appopriately.(REMVAL X TH &OPTIONAL (F 'SAMEP))  REMVAL takes an expression <x>, a theory, and a matcher as arguments.  It  deletes from the specified theory all sentences of the form (= <u> <v>),  where <u> is equivalent to <x> according to the specified matcher.  REMVAL  returns DONE as value.(RESET)  RESET resets the data structures of Epilog to their initial state and then  returns DONE as value.(REVERSE-RULE P)  REVERSE-RULE takes a forward or backward implication as argument, reverses  its direction, and returns the result.(RULES P)  RULES takes a sentence as argument and returns a list of equivalent rules in  simplified interchange format.(SAMELIST X Y)  SAMELIST takes two expressions as arguments and checks whether they have the  same structure, i.e. they are meta-equal after variable renaming.  SAMELIST returns a list of variable bindings, if the check is successful;  and it returns NIL otherwise.(SAMEP X Y)  SAMEP takes two expressions as arguments and checks whether they have the  same structure, i.e. they are meta-equal after variable renaming.  SAMEP returns T if the check is successful, and it returns NIL otherwise.(SAVE P TH &OPTIONAL (F 'SAMEP))  SAVE takes as argument a sentence, a theory, and an equivalence  checker.  If the theory contains a sentence that is equivalent (according  to the specified equivalence checker), nothing happens, and SAVE returns NIL.  Otherwise, the specified sentence is added to the end of the theory.(SEQVARP X)  SEQVARP takes any object as argument and returns T if and only if the  object is a sequence variable.(SETVAL X Y TH &OPTIONAL (F 'SAMEP))  SETVAL takes an expression <x>, and expression <y>, a theory, and a matcher  as arguments.  It deletes from the specified theory all sentences of the  form (= <u> <v>), where <u> is equivalent to <x> according to the specified  matcher, and then saves (= <x> <y>).  SETVAL returns <y> as value.(SHOW X THEORY (F 'matchp))  SHOW takes an expression, a theory, and a matching subroutine as arguments.  It prints out on the terminal all sentences in the specified theory that match  the specified expression using the specified matcher.  It returns DONE as  value.  NB: SHOW does NOT print out the sentences in included theories; see  SHOW-ALL.(SHOW-ALL X THEORY (F 'matchp))  SHOW-ALL takes an expression, a theory, and a matching subroutine asarguments.  It prints out on the terminal all sentences in the specified theory and it  included theories that match the specified expression using the specified  matcher.  It returns DONE as value.(SIF P)  SIF takes a sentence as argument, converts to simplified interchange format,  and returns the result.(SIFP P)  SIFP takes a sentence as argument.  It returns T if the sentence is in  simplified interchange format; otherwise, it returns NIL.(SKOLEMIZE P)  SKOLEMIZE takes a sentence as argument, skolemizes, and returns the result.(SKOLEMP P)  SKOLEMP takes a sentence as argument.  It returns T if the sentence is   skolemized (i.e. contains no explicit quantifiers); otherwise it returns NIL.(STDIZE X)  STDIZE takes an expression as argument and produces an equivalent  expression in which all variables have been given new names.(TEST filename)  TEST takes a filename as argument and executes each of the tests in the  file.  The file consists of sequence of s-expressions. The odd numbered  s-expressions are the tests to evaluate, and the even numbered s-expressions  are the expected results. An expected result of * means that any value is  acceptable. The function returns the total number of errors.The value of *UNIFICATIONS* is the number of attempted unifications in the  most recent proof effort.(TRACE-EXPRESSION &REST l)  TRACE-EXPRESSION takes any number of expressions as arguments.  It sets up   data structures so that various proof procedures print out appropriate  messages whenever they examine expressions that are instances of the specified  expressions.  If no arguments are passed to TRACE-EXPRESSION, the result is a   list of currently traced expressions.  Otherwise, the value is DONE.(TRACE-FACT &REST l)  TRACE-FACT takes any number of expressions as arguments.  It sets up   data structures so that various proof procedures print out appropriate  messages whenever they use database facts that are instances of the specified  expressions.  If no arguments are passed to TRACE-FACT, the result is a   list of currently traced expressions.  Otherwise, the value is DONE.(TRUEG X P TH &OPTIONAL (F 'MATCHP))  TRUEG takes as arguments an expression, a sentence, a theory, and an optional  equivalence checker.  It returns a generator that uses the equivalence checker  to determine if there is an equivalent sentence in the theory.  Each time the  generator is called, it returns a copy of the expression with variables  replaced by values from a successful equivalence check.  When all instances  have been enumerated, the generator returns NIL.(TRUEP P TH &OPTIONAL (F 'MATCHP))  TRUEP takes as argument a sentence, a theory, and an equivalence  checker.  It returns T if there is an equivalent sentence in the  specified theory (according to the specified equivalence checker) and  otherwise returns NIL.(TRUES X P TH &OPTIONAL (F 'MATCHP))  TRUES takes as argument an expression, a sentence, a theory, and an  equivalence checker.  It uses the equivalence checker to find all equivalent  sentences in the theory and returns a list of copies of the specified  expression with variables replaced by values from the successful equivalence  checks.  It returns NIL if no equivalent expressions are found.(TRUEX X P TH &OPTIONAL (F 'MATCHP))  TRUEX takes as argument an expression, a sentence, a theory, and an  equivalence checker.  It uses the equivalence checker to determine if there  is an equivalent sentence in the theory and, if so, returns a copy of  the expression with variables replaced by values from the first successful  equivalence check.  Otherwise, it returns NIL.(UNBIND X ENV)  UNBIND takes a variable and an environment as arguments and removes the  binding of the specified variable from the specified environment.(UNIFYP X Y)  UNIFYP takes two expressions as arguments and checks whether they are  meta-unifiable.  UNIFYP differs from MGUP in that the variables in one  expression are treated as distinct from the variables in the other  expression.  UNIFYP returns T if the check is successful, and it  returns NIL otherwise.(UNINCLUDES T1 T2)  UNINCLUDES takes two theories as arguments.  It modifies the knowledge  base so that the first theory does not include the second theory.  The  variable *INCLUDERS* is updated accordingly.(UNINDEX X TH)  UNINDEX takes an atom X, a sentence D, and a theory TH as arguments and  removes D from the indexees of X in theory TH.(UNINSERT P TH)  UNINSERT takes a sentence P and a theory TH as arguments.  The default version  unindexes P from all atoms in P and removes P from the contents of TH.(UNTRACE-EXPRESSION &REST l)  UNTRACE-EXPRESSION takes any number of expressions as arguments.  Iteliminates  the specified expressions from the data structures set up by TRACE-EXPRESSION  and thus turns off the corresponding tracing.  If no arguments are passed to   UNTRACE-EXPRESSION, all traced expressions are deleted, and a list of thethose   expressions is returned as value.  Otherwise, the value is DONE.(UNTRACE-FACT &REST l)  UNTRACE-FACT takes any number of expressions as arguments.  It eliminates  the specified expressions from the data structures set up by TRACE-FACT  and thus turns off the corresponding tracing.  If no arguments are passed to   UNTRACE-FACT, all traced expressions are deleted, and a list of the those   expressions is returned as value.  Otherwise, the value is DONE.(VALUE X TH &OPTIONAL (F 'MATCHP))  VALUE takes an expression, a theory, and a matcher as arguments.  It uses  GETVAL on the  specified theory and its included theories until it finds a  value.  If no value is found, VALUE returns NIL.(VARIABLES ENV)  VARIABLES takes an environment as argument and returns a list of variables  with bindings in that environment.(VARP X)  VARP takes any object as argument and returns T if and only if the  object is a variable.(WORDS TH)  WORDS takes a theory as argument and returns a list of all words contained  is that theory's contents.