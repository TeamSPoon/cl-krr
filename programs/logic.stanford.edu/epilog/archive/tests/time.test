;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; This one should be fast because goal is ground.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(deftheory test  (p ?x b)  (<= (p ?x ?y) (execute (sleep 10))))*(time (findp '(and (p a b) (fail)) 'test))*(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Set up for tests below.  Be sure to compile.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod insert (p (th (eql 'prolog)))  (addcontent p th)  (prolog-insert p p th)  p)(defmethod uninsert (p (th (eql 'prolog)))  (prolog-uninsert p p th)  (remcontent p th)  p)(defmethod empty ((th (eql 'prolog)))  (do ((l (contents th) (cdr l)))      ((null l) (clearcontent 'prolog))      (prolog-clear (car l) 'prolog)));;;;(defun prolog-insert (p d th)  (cond ((atom p) (index p d th))        ((eq '=> (car p)) (prolog-insert (cadr p) d th))        ((eq '<= (car p)) (prolog-insert (cadr p) d th))	(t (prolog-insert (car p) d th))))(defun prolog-uninsert (p d th)  (cond ((atom p) (unindex p d th))        ((eq '=> (car p)) (prolog-uninsert (cadr p) d th))        ((eq '<= (car p)) (prolog-uninsert (cadr p) d th))	(t (prolog-uninsert (car p) d th))))(defun prolog-clear (x th)  (cond ((atom x) (clearindex x th))        ((eq 'not (car x)) (prolog-clear (cadr x) th))        ((eq '=> (car x)) (prolog-clear (cadr x) th))        ((eq '<= (car x)) (prolog-clear (cadr x) th))	(t (prolog-clear (car x) th))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq *occurcheck* nil *debug* nil)*(deftheory prolog  (<= (reverse (listof ?x @l) ?z)      (reverse (listof @l) ?y)      (append ?y (listof ?x) ?z))  (reverse (listof) (listof))  (<= (append (listof ?x @l) ?y (listof ?x @m))      (append (listof @l) ?y (listof @m)))  (append (listof) ?y ?y))*(time (findx '?x '(reverse (listof 1 2 3 4 5 6 7 8 9 10                                   11 12 13 14 15 16 17 18 19 20                                   21 22 23 24 25 26 27 28 29 30) ?x)             'prolog));;; subgoals:        496;;; unifications:    527 ;;; time:          0.536;;; space:        175544*(setq *reduction* nil)*(time (findx '?x '(reverse (listof 1 2 3 4 5 6 7 8 9 10                                   11 12 13 14 15 16 17 18 19 20                                   21 22 23 24 25 26 27 28 29 30) ?x)             'prolog));;; subgoals:        496;;; unifications:    527 ;;; time:          0.536;;; space:        175544*(setq *reduction* nil *ancestry* t)*(time (findx '?x '(reverse (listof 1 2 3 4 5 6 7 8 9 10                                   11 12 13 14 15 16 17 18 19 20                                   21 22 23 24 25 26 27 28 29 30) ?x)             'prolog));;; subgoals:        496;;; unifications:    527 ;;; time:          2.892;;; space:        182984*(setq *reduction* t *ancestry* t)*(time (findx '?x '(reverse (listof 1 2 3 4 5 6 7 8 9 10                                   11 12 13 14 15 16 17 18 19 20                                   21 22 23 24 25 26 27 28 29 30) ?x)             'prolog));;; subgoals:        496;;; unifications:  10447;;; time:          4.593;;; space:        341704 *(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq *occurcheck* nil *debug* nil)*(deftheory prolog  (<= (reverse ?l ?m) (revappend ?l (listof) ?m))  (revappend (listof) ?m ?m)  (<= (revappend (listof ?x @l) (listof @m) ?n)      (revappend (listof @l) (listof ?x @m) ?n)))*(time (findx '?x '(reverse (listof 1 2 3 4 5 6 7 8 9 10                                   11 12 13 14 15 16 17 18 19 20                                   21 22 23 24 25 26 27 28 29 30) ?x)             'prolog));;; subgoals:         32;;; unifications:     33 ;;; time:          0.034;;; space:         11592*(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(time (do ((i 1 (1+ i)))          ((> i 100))          (do ((j 1 (1+ j)))              ((> j 100))              (insert `(r ,i ,j) 'fancy))));;; subgoals:          0;;; unifications:      0 ;;; time:          3.684 msec;;; space:        564864*(time (do ((l (contents 'fancy) (cdr l))) ((null l)) (uninsert (car l) 'fancy)));;; subgoals:          0;;; unifications:      0 ;;; time:          3.516 msec;;; space:           248*(do ((i 1 (1+ i)))    ((> i 100))    (do ((j 1 (1+ j)))        ((> j 100))        (insert `(r ,i ,j) 'fancy)))*(time (empty 'fancy));;; subgoals:          0;;; unifications:      0 ;;; time:          3.516 msec;;; space:           576*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(do ((i 1 (1+ i)))    ((> i 100))    (insert `(p ,i) 'prolog))*(insert '(<= (r ?x ?y) (p ?x) (q ?y)) 'prolog)*(insert '(<= (q ?x) (p ?x)) 'prolog)*(time (finds '(r ?x ?y) '(r ?x ?y) 'prolog));;; subgoals:        202;;; unifications:  10201 ;;; time:          6.037 sec;;; space:       1336320*(empty 'prolog)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(setq *occurcheck* nil *debug* nil *saves* '(r))*(do ((i 1 (1+ i)))    ((> i 10))    (insert `(q ,i) 'prolog))*(save '(=> (p ?x) (q ?y) (r ?x ?y)) 'prolog)*(time (do ((i 1 (1+ i)))          ((> i 10))          (assume `(p ,i) 'prolog)));;; subgoals:        ???;;; unifications:    ???;;; time:          0.618;;; space:         33720*(reset)*;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;