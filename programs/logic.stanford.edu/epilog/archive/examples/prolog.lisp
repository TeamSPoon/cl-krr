;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1995 Epistemics Inc.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod index (p (th (eql 'prolog)))  (prolog-cntxt p th)  (prolog-index p p th)  p)(defmethod unindex (p (th (eql 'prolog)))  (prolog-unindex p p th)  (prolog-uncntxt p th)  p)(defmethod empty ((th (eql 'prolog)))  (do ((l (contents th) (cdr l)))      ((null l) (setf (contents 'prolog) nil) 'done)      (prolog-kill (car l) 'prolog)))(defun prolog-cntxt (p th)  (if (null (contents th)) (setq *theories* (cons th *theories*)))  (setf (contents th) (cons p (contents th)))  p)(defun prolog-uncntxt (p th)  (if (null (setf (contents th) (delete p (contents th) :count 1)))       (setq *theories* (delete th *theories* :count 1)))  p)(defun prolog-index (p d th)  (cond ((atom p) (setf (indexees p th) (cons d (indexees p th))))        ((eq '=> (car p)) (prolog-index (cadr p) d th))        ((eq '<= (car p)) (prolog-index (cadr p) d th))	(t (prolog-index (car p) d th))))(defun prolog-unindex (p d th)  (cond ((atom p) (setf (indexees p th) (delete d (indexees p th))))        ((eq '=> (car p)) (prolog-unindex (cadr p) d th))        ((eq '<= (car p)) (prolog-unindex (cadr p) d th))	(t (prolog-unindex (car p) d th))))(defun prolog-kill (p th)  (cond ((atom p) (cond ((null p))                        ((varp p))                        (t (setf (indexees p th) nil))))        ((eq 'not (car p)) (prolog-kill (cadr p) th))        ((eq '=> (car p)) (prolog-kill (cadr p) th))        ((eq '<= (car p)) (prolog-kill (cadr p) th))	(t (prolog-kill (car p) th))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;