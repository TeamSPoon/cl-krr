;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; find.lisp;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(eval-when (compile load eval)  (proclaim '(special *theory* *names* *functionals*                      *start* *increment* *depth* *termination*                      alist level tracecalls tracefacts traceexpressions)))(defvar *ancestry* nil "*ANCESTRY* determines whether or not various inference routines save and  check ancestries in processing subgoals.  The default is NIL.")(defparameter *saves* nil "*SAVES* is a variable that determines which literals are saved in forward  chaining.  If the value of *SAVES* is a list, then a derived literal is saved  if and only if its primary logical constant, function constant, or relation  constant is an item on this list.  If the value is anything other than a list,  all derived literals are saved.")(defvar *start* 1000 "*START* is the initial depth cutoff for iterative deepening.")(defvar *increment* 1000 "*INCREMENT* is the amount by which the depth cutoff is incremented on each  round of iterative deepening.")(defvar *depth* 1000000 "*DEPTH* has as value a positive integer indicating the depth of search for  iterative deepening.  Its default is 1000000.")(defvar *termination* nil "*TERMINATION* records whether the most recent depth-limited search attempt  ended because of a depth cutoff.")(defvar *inferences* 0 "*INFERENCES* records the number of inference steps in the current inference  process.")(defmethod assume (p *theory*) "(ASSUME P *THEORY*)  ASSUME takes a sentence and a theory as arguments.  The sentence is assumed  to be a literal.  ASSUME uses model elimination to derive conclusions from the  specified sentence and the sentences in the specified theory and its included  theories.  The search is bottom-up, depth-first, and statically-ordered and  uses *DEPTH* as a depth limit.  If it derives a literal with relation constant  on the list *SAVES*, it saves the literal it derives into the specified theory.  ASSUME returns DONE as value."  (let ((alist (environment)) (level 0) tracecalls)    (setq *termination* nil)    (assumedepth p alist 1 nil)    'done))(defun assumedepth (p al depth stack)  (cond ((greaterp depth *depth*) (setq *termination* t) nil)        (t (if traceexpressions (tracesave p al))           (assumeexp p al depth stack)           (if traceexpressions (tracedone p al)))))(defun assumeexp (p al depth stack)  (cond ((atom p) (assumeexpexit p al depth stack))        ((eq 'and (car p))          (mapc #'(lambda (x) (assumedepth x al depth stack)) (cdr p)))        (t (assumeexpexit p al depth stack))))(defun assumeexpexit (p al depth stack)  (setq p (plugstdexp p al))  (cond ((knownp p *theory* 'samep) nil)        ((and (listp p) (eq 'execute (car p))) (ignore-errors (eval (cadr p))))        ((and (savep p) (index p *theory*) nil))        (t (assumedb p al depth stack *theory*))))(defun savep (p)  (or (not (listp *saves*)) (memq (operator p) *saves*)))(defun assumedb (p al depth stack th)  (cond ((assumeth p al depth stack th))        (t (do ((l (includees th) (cdr l)))               ((null l) nil)               (assumedb p al depth stack (car l))))))(defun assumeth (p al depth stack th)  (do ((l (envindexps p al th) (cdr l)) (ol) (bl (environment)) (ans))      ((null l))      (when (and (listp (car l)) (eq (caar l) '=>) (not (null (cddar l)))                 (setq ol (unify (cadar l) bl p al)))        (if tracefacts (tracefact (car l)))        (setq ans (assumes '(failure) (car l) (butlast (cddar l)) (list bl depth stack)))        (backup ol)        (if ans (return ans)))))(defmethod envindexps (p al th) "(ENVINDEXPS P ENV TH)  ENVINDEXPS takes an expression, an environment, and a theory as arguments and  returns a list of sentences in the specified theory containing a component  that could potentially unify with the specified expression in the specified  environment.  ENVINDEXPS is used by all inference subroutines.  Users are free  to redefine ENVINDEXPS to implement specialized subroutines.  The default  implementation (INDEXPS P TH) ignores the environment."  (declare (ignore al))  (indexps p th))(defun assumes (next rule pl al-depth-stack)  (destructuring-bind (al depth stack) al-depth-stack    (cond ((null pl)           (assumedepth (car (last rule)) al (1+ depth) stack)           (profail nil next))          ((eq 'cut (car pl)) (assumes next rule (cdr pl) (list al depth stack)) t)          ((finddepth (car pl) al depth stack                      (list  next `(assumes ,rule ,(cdr pl) (,al ,depth ,stack))))))))(defun discard (x th) "(DISCARD X TH)  DISCARD takes an expression and a theory as arguments and forgets all  sentences containing an instance of the specified expression from the  specified theory."  (do ((l (facts x th) (cdr l)))      ((null l) 'done)      (forget (car l) th)))(defmethod forget (p th) "(FORGET P *THEORY*)  FORGET takes a sentence and a theory as arguments.  The sentence is assumed  to be a literal.  FORGET uses model elimination to derive conclusions from the  specified sentence and the sentences in the specified theory and its included  theories.  The search is bottom-up, depth-first, and statically-ordered and  uses *DEPTH* as a depth limit.  If it derives a literal with relation constant  on the list *SAVES*, it drops the literal it derives from the specified theory.  FORGET returns DONE as value."  (let ((alist (environment)) (*theory* 'forget) (level 0) tracecalls)    (setq *termination* nil)    (decludes 'forget)    (empty 'forget)    (includes *theory* th)    (forgetdepth p alist 1 nil)    'done))(defun forgetdepth (p al depth stack)  (cond ((greaterp depth *depth*) (setq *termination* t) nil)        (t (if traceexpressions (tracedrop p al))           (forgetexp p al depth stack)           (if traceexpressions (tracedone p al)))))(defun forgetexp (p al depth stack)  (cond ((atom p) (forgetexpexit p al depth stack))        ((eq 'and (car p))          (mapc #'(lambda (x) (forgetdepth x al depth stack)) (cdr p)))        (t (forgetexpexit p al depth stack))))(defun forgetexpexit (p al depth stack)  (setq p (plugstdexp p al))  (cond ((truep p *theory* 'samep) nil)        ((and (savep p) (drop p (car (includees *theory*)))              (index p *theory*) nil))        (t (forgetdb p al depth stack *theory*))))(defun forgetdb (p al depth stack th)  (cond ((forgetth p al depth stack th))        (t (do ((l (includees th) (cdr l)))               ((null l) nil)               (forgetdb p al depth stack (car l))))))(defun forgetth (p al depth stack th)  (do ((l (envindexps p al th) (cdr l)) (ol) (bl (environment)) (ans))      ((null l))      (when (and (listp (car l)) (eq (caar l) '=>) (not (null (cddar l)))                 (setq ol (unify (cadar l) bl p al)))        (if tracefacts (tracefact (car l)))        (setq ans (forgets '(failure) (car l) (butlast (cddar l)) (list bl depth stack)))        (backup ol)        (if ans (return ans)))))(defun forgets (next rule pl al-depth-stack)  (destructuring-bind (al depth stack) al-depth-stack    (cond ((null pl)           (forgetdepth (car (last rule)) al (1+ depth) stack)           (profail nil next))          ((eq 'cut (car pl)) (forgets next rule (cdr pl) (list al depth stack)) t)          ((finddepth (car pl) al depth stack                      (list next `(forgets ,rule ,(cdr pl) (,al ,depth ,stack))))))))(defmethod findp (p th) "(FINDP P TH)  FINDP takes a sentence and a theory as arguments.  It tries to prove the  sentence from the specified theory and its included theories using model  elimination.  The search is done in iterative deepening fashion, controlled by  the variables *START*, *INCREMENT*, and *DEPTH*.  If FINDP is able to prove  the sentence, it returns T; otherwise, it returns NIL."  (findx t p th))(defmethod findx (x p *theory*) "(FINDX X P *THEORY*)  FINDX takes as argument a term, a sentence, and a theory.  It tries to prove  the specified sentence from the specified theory and its included theories  using the model elimination.  The search is done in iterative deepening  fashion, controlled by the variables *START*, *INCREMENT*, and *DEPTH*.  If  FINDX is able to prove the sentence, it returns a copy of the specified term  with variables replaced by values obtained during the proof process.  If it  fails to prove the sentence, the value is NIL."  (do ((old *depth*) (*depth* (min *start* *depth*) (+ *depth* *increment*))       (alist (environment)) (level 0) (tracecalls))      ((> *depth* old) nil)      (setq *termination* nil *inferences* 0 *unifications* 0)      (cond ((finddepth p alist 1 nil (list '(failure) '(success)))             (return (plugstdexp x alist)))            ((not *termination*) (return nil)))))(defmethod finds (x p *theory*) "(FINDS X P *THEORY*)  FINDS takes as argument a term, a sentence, and a theory.  It tries to  prove the specified sentence from the specified theory and its included  theories using model elimination.  The search is depth-first and  statically-ordered and uses *DEPTH* as a depth limit.  If FINDS succeeds  in proving the sentence, it returns a list of copies of the specified term,  one for each way the sentence can be proved.  In each copy, the variables are  replaced by values obtained during the proof process.  If the sentence cannot  be proved, FINDS returns NIL."  (let ((alist (environment)) (level 0) tracecalls)    (setq *termination* nil *inferences* 0 *unifications* 0)    (do ((next (finddepth p alist 1 nil (list '(failure) '(success)))(profail nil next))         (nl))        ((null next) (nreverse nl))        (setq nl (cons (plugstdexp x alist) nl)))))(defmethod findval (x th) "(FINDVAL X TH)  is equivalent to (FINDX '?? `(AND (= ,X ??) (PRIMITIVE ??)) TH)."  (findx '?? `(and (= ,x ??) (primitive ??)) th))(defmethod findvals (x th) "(FINDVALS X TH)  is equivalent to (FINDS '?? `(AND (= ,X ??) (PRIMITIVE ??)) TH)."  (finds '?? `(and (= ,x ??) (primitive ??)) th))(defmethod findg (x p th) "(FINDG X P *THEORY*)  FINDG takes as argument a term, a sentence, and a theory.  It returns a  continuation that on each call tries to prove the specified sentence from the  specified theory and its included theories.  The search is done in iterative  deepening fashion, controlled by the variables *START*, *INCREMENT*, and  *DEPTH*.  If the continuation is able to prove the sentence, it returns a copy  of the specified term with variables replaced by values obtained during the  proof process.  After each successful attempt, the continuation can be called  again to get the next answer.  Once all answers have been enumerated, the  continuation returns NIL."  (let* ((al (environment))         (cont `(procall (finddepth ,p ,al 1 nil ((failure) (success)))))         (tcs) (inferences 0) (unifications 0))    #'(lambda ()        (let ((*theory* th) (alist al) (level 0) (tracecalls tcs))          (setq *termination* nil *inferences* inferences *unifications*unifications)          (when (setq cont (profail nil cont))            (setq tcs tracecalls inferences *inferences* unifications*unifications*)            (plugstdexp x alist)))))) (defun finddepth (p al depth stack next-done)  (destructuring-bind (next done) next-done    (setq *inferences* (1+ *inferences*))    (cond ((greaterp depth *depth*) (setq *termination* t) (profail nil next))          ((and traceexpressions                (protracecall p al done)                (setq next `(protracefail ,next ,done))                (setq done `(protraceexit ,done)) nil))          (t (findexp p al depth stack (list next done))))))(defun findexp (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((atom p) (findconst p al depth stack next-done))          ((eq 'not (car p)) (findnotexp (cadr p) al depth stack next-done))          ((eq 'and (car p)) (findand p al depth stack next-done))          ((eq 'or (car p)) (findor p al depth stack next-done))          ((eq '== (car p)) (findvalue p al next done))          ((eq 'distinct (car p)) (finddistinct p al next done))          ((eq 'primitive (car p)) (findprimitive p al next done))          ((eq 'nonprimitive (car p)) (findnonprimitive p al next done))          ((eq 'execute (car p)) (findexecute p al next done))          ((get (car p) 'basic) (findbasic p al depth stack next-done))          ((get (car p) 'basicval) (findbasicvalue p al depth stack next-done))          (t (findcallfail p al depth stack next-done)))))(defun findnotexp (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((atom p) (findnotconst p al depth stack next-done))          ((eq 'not (car p)) (finddepth (cadr p) al depth stack next-done))          ((eq 'and (car p)) (findornot p al depth stack next-done))          ((eq 'or (car p)) (findandnot p al depth stack next-done))          ((eq '== (car p)) (findnotvalue p al next done))          ((eq 'execute (car p)) (findnotexecute p al next done))          ((get (car p) 'basic) (findnotbasic p al depth stack next-done))          ((get (car p) 'basicval) (findnotbasicvalue p al depth stacknext-done))          (t (findcallfail `(not ,p) al depth stack next-done)))))(defun findconst (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((eq 'true p) (proexit next done))          ((eq 'cut p) (proexit next done))          ((eq 'false p) (profail nil next))          (t (findcallfail p al depth stack next-done)))))(defun findnotconst (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((eq 'true p) (profail nil next))          ((eq 'cut p) (profail nil next))          ((eq 'false p) (proexit next done))          (t (findcallfail `(not ,p) al depth stack next-done))))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; clean up cut behavior may be possible -- move to one place?;;; also cut in andnot and or and ornot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun findand (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((null (cdr p)) (proexit next done))          (t (finddepth (cadr p) al depth stack                        (list next `(findands ,(cddr p) ,al (,depth ,stack ,done))))))));;; efficiency gain possible by checking for null before consing continuation(defun findands (ans pl al depth-stack-done)  (destructuring-bind (depth stack done) depth-stack-done    (cond ((null pl) (proexit ans done))          ((eq 'cut (car pl))           (findands `(procut ,depth ,ans) (cdr pl) al (list depth stack done)))          (t (finddepth (car pl) al depth stack                        (list ans `(findands ,(cdr pl) ,al (,depth ,stack ,done))))))))(defun procut (ans depth next &optional four)  (declare (ignore four))  (cond (ans (profail ans next))        (t (profail (1- depth) next))))(defun findandnot (p al depth stack next-done)  (destructuring-bind (next done) next-done    (cond ((null (cdr p)) (proexit next done))          (t (finddepth `(not ,(cadr p)) al depth stack                        (list next `(findandnots ,(cddr p) ,al (,depth,stack ,done))))))))(defun findandnots (ans pl al depth-stack-done)  (destructuring-bind (depth stack done) depth-stack-done    (cond ((null pl) (proexit ans done))          ((eq 'cut (car pl))           (findandnots `(procut ,ans ,done) (cdr pl) al (list depth stackdone)))          (t (finddepth `(not ,(car pl)) al depth stack                        (list ans `(findandnots ,(cdr pl) ,al (,depth,stack ,done))))))))(defun findor (p al depth stack next-done)  (destructuring-bind (next done) next-done    (findors nil (cdr p) al (list depth stack next done))))(defun findors (ans pl al depth-stack-next-done)  (destructuring-bind (depth stack next done) depth-stack-next-done    (cond ((not (null ans)) (profail ans next))          ((null pl) (profail nil next))          (t (finddepth (car pl) al depth stack                        (list `(findors ,(cdr pl) ,al                                        (,depth ,stack ,next ,done)) done))))))(defun findornot (p al depth stack next-done)  (destructuring-bind (next done) next-done    (findornots nil (cdr p) al (list depth stack next done))))(defun findornots (ans pl al depth-stack-next-done)  (destructuring-bind (depth stack next done) depth-stack-next-done    (cond ((not (null ans)) (profail ans next))          ((null pl) (profail nil next))          (t (finddepth `(not ,(car pl)) al depth stack                        (list `(findornots ,(cdr pl) ,al (,depth ,stack                                                                 ,next ,done) done))))))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Note that both primitive and nonprimitive are true of all objects;;; but Epilog succeeds only on terms that are primitive or nonprimitive.;;; This is why (nonprimitive <x>) is not (not (primitive <x>));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun findprimitive (p al next done)  (if (chkprimitivep (cadr p) al) (proexit next done) (profail nil next)))(defun findnonprimitive (p al next done)  (if (chkprimitivep (cadr p) al) (profail nil next) (proexit next done)))(defun chkprimitivep (x al)  (cond ((indvarp x)         (cond ((null (cddr (setq x (getbdg x al)))))               ((chkprimitivep (cadr x) (cddr x)))))        ((atom x) (cond ((numberp x))                        ((stringp x))                        ((characterp x))                        ((eq 'pi x) nil)                        ((not (listp *names*)))                        ((memq x *names*) t)))        ((eq 'quote (car x)))        ((eq 'listof (car x)) (chkprimitivepcdr (cdr x) al))        ((get (car x) 'basicval) nil)        ((not (listp *functionals*)) (chkprimitivepcdr (cdr x) al))        ((memq (car x) *functionals*) (chkprimitivepcdr (cdr x) al))))(defun chkprimitivepcdr (x al)  (do ((l x (cdr l)) (ans))      ((null l) t)      (cond ((seqvarp (car l))             (cond ((null (cddr (setq ans (getbdg (car l) al)))))                   ((chkprimitivepcdr (cadr ans) (cddr ans)))                   (t (return nil))))            ((chkprimitivep (car l) al))            (t (return nil)))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Distinct is true of all pairs of objects;;; but epilog succeeds only in those cases where the arguments are different;;; This is why there is no (not (distinct <x> <y>));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun finddistinct (p al next done)  (let ((ol))    (cond ((setq ol (unify (caddr p) al (cadr p) al))           (backup ol) (profail nil next))          (t (proexit next done))))) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Not clear whether it should go on to database in case of nongroundprimitive.;;; basic goes on; value does not.  This is weird.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun findvalue (p al next done)  (let ((x (findbasicval (cadr p) al)) (y (caddr p)) (ol))    (if (and (not (null x)) (setq ol (unify y al x al)))        (proexit `(findvaluenext ,ol ,next) done)        (profail nil next))))(defun findvaluenext (ans ol next &optional four)  (declare (ignore ans four))  (backup ol)  (profail nil next))(defun findnotvalue (p al next done)  (let ((x (findbasicval (cadr p) al)) (y (caddr p)) (ol))    (cond ((null x) (profail nil next))          ((setq ol (unify y al x al)) (backup ol) (profail nil next))          (t (proexit next done)))));;; needless inefficiency here.  Just needs to check atom and car.(defun findbasicval (x al)  (let (dum)    (cond ((null (setq dum (groundplugstdexp x al))) nil)          ((atom dum) (if (primitivep dum) dum))          ((eq 'execute (car dum)) (quotify (ignore-errors (eval (cadr dum)))))          ((and (get (car dum) 'basicval) (every 'primitivep (cdr dum)))           (funcall (get (car dum) 'basicval) dum))          ((primitivep dum) dum))))(defun findexecute (p al next done)  (cond ((null (cddr p)) (findvalue `(== ,p 't) al next done))        (t (findvalue `(== ,(butlast p) ,(car (last p))) al next done))))(defun findnotexecute (p al next done)  (cond ((null (cddr p)) (findnotvalue `(== ,p 't) al next done))        (t (findnotvalue `(== ,(butlast p) ,(car (last p))) al next done))))(defun findbasic (p al depth stack next-done)  (destructuring-bind (next done) next-done    (let (ans)      (cond ((and (setq ans (groundplugstdexp p al))                  (every 'primitivep (cdr ans)))             (if (apply (get (car ans) 'basic) (cdr ans))               (proexit next done)               (profail nil next)))            (t (findcallfail p al depth stack next-done))))))(defun findbasicvalue (p al depth stack next-done)  (destructuring-bind (next done) next-done    (let ((x (butlast p)) (y (car (last p))) (ol))      (cond ((and (setq x (groundplugstdexp x al)) (every 'primitivep (cdr x)))             (setq x (funcall (get (car x) 'basicval) x))             (if (and (not (null x)) (setq ol (unify y al x al)))               (proexit `(findvaluenext ,ol ,next) done)               (profail nil next)))            (t (findcallfail p al depth stack next-done))))))(defun findnotbasic (p al depth stack next-done)  (destructuring-bind (next done) next-done    (let (ans)      (cond ((and (setq ans (groundplugstdexp p al))                  (every 'primitivep (cdr ans)))             (if (not (apply (get (car ans) 'basic) (cdr ans)))               (proexit next done)               (profail nil next)))            (t (findcallfail `(not ,p) al depth stack next-done))))))(defun findnotbasicvalue (p al depth stack next-done)  (destructuring-bind (next done) next-done    (let ((x (butlast p)) (y (car (last p))) (ol))      (cond ((and (setq x (groundplugstdexp x al)) (every 'primitivep (cdr x)))             (setq x (funcall (get (car x) 'basicval) x))             (cond ((null x) (profail nil next))                   ((setq ol (unify y al x al)) (backup ol) (profail nil next))                   (t (proexit next done))))            (t (findcallfail `(not ,p) al depth stack next-done)))))) (defun findcallfail (p al depth stack next-done)  (destructuring-bind (next done) next-done    (findrs p al depth stack (list `(findcallfailnext ,depth ,next) done))))(defun findcallfailnext (ans depth next &optional four)  (declare (ignore four))  (cond ((null ans) (profail nil next))        ((= ans depth) (profail nil next))        (t (profail ans next))))(defun findrs (p al depth stack next-done)  (destructuring-bind (next done) next-done    (findrsloop nil p al (list depth stack stack nil next done))))(defun findrsloop (ans p al depth-stack-sl-ol-next-done)  (destructuring-bind (depth stack sl ol next done) depth-stack-sl-ol-next-done    (backup ol)    (cond ((not (null ans)) (profail ans next))          ((null sl) (finddb p al (list depth stack) *theory* (list next                                                                    done)))          ((identify (caar sl) (cdar sl) p al) (profail nil next))          ((setq ol (unify (maknot (caar sl)) (cdar sl) p al))           (proexit `(findrsloop ,p ,al                                 (,depth ,stack ,(cdr sl) ,ol ,next ,done))                    done))          (t (findrsloop nil p al (list depth stack (cdr sl) ol next done))))));;; efficiency gain here by checking for null before consing continuation(defun finddb (p al depth-stack th next-done)  (destructuring-bind (depth stack) depth-stack    (destructuring-bind (next done) next-done      (findth p al (list depth stack) th              (list `(finddbs ,p ,al (,depth ,stack ,(includees th) ,next,done)) done)))))(defun finddbs (ans p al depth-stack-tl-next-done)  (destructuring-bind (depth stack tl next done) depth-stack-tl-next-done    (cond ((not (null ans)) (profail ans next))          ((null tl) (profail nil next))          (t (finddb p al (list depth stack) (car tl)                     (list `(finddbs ,p ,al                                     (,depth ,stack ,(cdr tl) ,next ,done)) done))))))(defun findth (p al depth-stack th next-done)  (destructuring-bind (depth stack) depth-stack    (destructuring-bind (next done) next-done      (findths nil p al (list depth stack (envindexps p al th)(environment) nil next done)))));;; ground test in rule case would save work but it is expensive.;;; note that subset test not good in rule case cause subgoals may bind vars.;;; we should allow *saves* to work here when caching problem solved.(defun findths (ans p al depth-stack-fl-bl-ol-next-done)  (destructuring-bind (depth stack fl bl ol next done) depth-stack-fl-bl-ol-next-done    (backup ol)    (cond ((not (null ans)) (profail ans next))          ((null fl) (profail nil next))          ((and (listp (car fl)) (eq (caar fl) 'or))           (cond ((setq ol (unify (cadar fl) bl p al))                  (setq next `(findths ,p ,al (,depth ,stack ,(cdr fl)                                                      ,bl ,ol ,next ,done)))                  (if *ancestry* (setq stack (acons p al stack)))                  (findand (cons 'and (mapcar #'maknot (cddar fl)))                           bl (1+ depth) stack (list next done)))                 (t (findths nil p al (list depth stack (cdr fl) bl ol next done)))))          ((and (listp (car fl)) (eq (caar fl) '<=))           (cond ((setq ol (unify (cadar fl) bl p al))                  (setq next `(findths ,p ,al (,depth ,stack ,(cdr fl)                                                      ,bl ,ol ,next ,done)))                  (if *ancestry* (setq stack (acons p al stack)))                  (findand (cons 'and (cddar fl)) bl (1+ depth) stack                           (list next done)))                 (t (findths nil p al (list depth stack (cdr fl) bl ol next done)))))          ((setq ol (unify (car fl) bl p al))           (if (not (subsetp (cdr ol) (alist bl)))             (setq next `(findths ,p ,al (,depth ,stack ,(cdr fl) ,bl                                                 ,ol ,next ,done))))           (proexit next done))          (t (findths nil p al (list depth stack (cdr fl) bl ol next done)))))) (defun failure (&rest l)  (declare (ignore l))  nil)(defun success (&rest l)  (car l))(defun proexit (next done)  (if traceexpressions (setq next `(protraceredo ,next ,done)))  (if done (funcall (car done) next (second done) (third done) (fourth done))      next))(defun profail (ans next)  (if next (funcall (car next) ans (second next) (third next) (fourth next))))(defun procall (ans next &optional three four)  (declare (ignore ans three four))  (if next (apply (car next) (cdr next))))(defun protracecall (p al done)  (setq p (plugstdexp p al))  (when (memp p traceexpressions 'instp)        (tracemessage level '|Call: | p)        (setq tracecalls (acons done p tracecalls))        (setq level (1+ level))))(defun protraceexit (ans done &optional three four)  (declare (ignore three four))  (let (dum)    (when (setq dum (assq done tracecalls))      (setq level (1- level))      (tracemessage level '|Exit: | (plugstdexp (cdr dum) alist)))    (proexit ans done)))(defun protraceredo (ans next done &optional four)  (declare (ignore four))  (let (dum)    (when (setq dum (assq done tracecalls))      (tracemessage level '|Redo: | (cdr dum))      (setq level (1+ level)))    (profail ans next)))(defun protracefail (ans next done four)  (declare (ignore four))  (let (dum)    (when (setq dum (assq done tracecalls))      (setq tracecalls (cdr tracecalls))      (setq level (1- level))      (tracemessage level '|Fail: | (cdr dum)))    (profail ans next))) (defparameter *trace-device* t "*TRACE-DEVICE* is the device to which inference trace information is  printed.  The default is T, which directs all inference routines to print  traces on the terminal.")(defvar traceexpressions nil)(defvar tracefacts nil)(defvar tracecalls nil)(defmethod trace-expression (&rest l) "(TRACE-EXPRESSION &REST l)  TRACE-EXPRESSION takes any number of expressions as arguments.  It sets up   data structures so that various proof procedures print out appropriate  messages whenever they examine expressions that are instances of the specified  expressions.  If no arguments are passed to TRACE-EXPRESSION, the result is a   list of currently traced expressions.  Otherwise, the value is DONE."  (cond ((null l) traceexpressions)        (t (mapc 'traceexp l)           'done)))(defun traceexp (x)  (if (not (memp x traceexpressions 'samep))      (setq traceexpressions (cons x traceexpressions))))(defmethod untrace-expression (&rest l) "(UNTRACE-EXPRESSION &REST l)  UNTRACE-EXPRESSION takes any number of expressions as arguments.  Iteliminates  the specified expressions from the data structures set up by TRACE-EXPRESSION  and thus turns off the corresponding tracing.  If no arguments are passed to   UNTRACE-EXPRESSION, all traced expressions are deleted, and a list of thethose   expressions is returned as value.  Otherwise, the value is DONE."  (cond ((null l) (mapc 'untraceexp traceexpressions))        (t (mapc 'untraceexp l)))  'done)(defun untraceexp (x)  (setq traceexpressions (delone x traceexpressions 'samep)))(defmethod trace-fact (&rest l) "(TRACE-FACT &REST l)  TRACE-FACT takes any number of expressions as arguments.  It sets up   data structures so that various proof procedures print out appropriate  messages whenever they use database facts that are instances of the specified  expressions.  If no arguments are passed to TRACE-FACT, the result is a   list of currently traced expressions.  Otherwise, the value is DONE."  (cond ((null l) tracefacts)        (t (mapc 'tracefactoid l)           'done)))(defun tracefactoid (x)  (if (not (memp x tracefacts 'samep))      (setq tracefacts (cons x tracefacts))))(defmethod untrace-fact (&rest l) "(UNTRACE-FACT &REST l)  UNTRACE-FACT takes any number of expressions as arguments.  It eliminates  the specified expressions from the data structures set up by TRACE-FACT  and thus turns off the corresponding tracing.  If no arguments are passed to   UNTRACE-FACT, all traced expressions are deleted, and a list of the those   expressions is returned as value.  Otherwise, the value is DONE."  (cond ((null l) (mapc 'untracefact tracefacts))        (t (mapc 'untracefact l)))  'done)(defun untracefact (x)  (setq tracefacts (delone x tracefacts 'samep)))(defun tracesave (p al)  (setq p (plugstdexp p al))  (when (memp p traceexpressions 'instp)        (tracemessage level '|Save: | p)        (setq level (1+ level))))(defun tracedrop (p al)  (setq p (plugstdexp p al))  (when (memp p traceexpressions 'instp)        (tracemessage level '|Drop: | p)        (setq level (1+ level))))(defun tracedone (p al)  (setq p (plugstdexp p al))  (when (memp p traceexpressions 'instp)        (setq level (1- level))        (tracemessage level '|Done: | p)))(defun tracefact (x)  (when (memp x tracefacts 'instp)        (tracemessage level "Fact: " x)))(defun tracemessage (n pr p)  (fresh-line *trace-device*)  (tracespaces n) (princ pr *trace-device*) (princ p *trace-device*))(defun tracespaces (n)  (do ((i 1 (1+ i)))      ((> i n))      (princ " | " *trace-device*)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;