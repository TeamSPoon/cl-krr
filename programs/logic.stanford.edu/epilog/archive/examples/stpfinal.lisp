;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1988  Michael R. Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(proclaim '(special *theory* *depth* depth termination))(defun stpfinalize (&optional (th *theory*)) "(STPFINALIZE &OPTIONAL (TH *THEORY*))  STPFINALIZE takes a theory as argument.  It reprograms STP so that it returns  the same answers when called on the specified theory, no matter what further  changes are made to it.  In the process of reprogramming, STPFINALIZE can  usually improve efficiency by building in information about the contents of  the theory at the time it is finalized."  (mapc 'eval (stpfinalizers th))  th)(defun stpfinalize-file (in &optional (out nil)) "(STPFINALIZE-FILE IN OUT)  STPFINALIZE-FILE takes an input filename and an output filename as arguments.    It is similar to STPFINALIZE except that (1) the input information comes  from the input file and (2) the output goes to the output file and no   modifications are made to the programs in memory."   (let (*theory*)    (setq *theory* (read-from-string (pathname-name (pathname in))))    (if (not out)       (setq out (concatenate 'string (namestring (pathname-directory (pathname in)))                                     (namestring (pathname-name (pathname in)))                                     ".lisp")))    (load-theory in *theory* 'stpstash)    (with-open-file (f out :direction :output :if-exists :supersede)      (do ((l (stpfinalizers *theory*) (cdr l)))          ((null l))          (pprint (car l) f)))    (empty *theory*)    out))(defun stpfinalizers (&optional (*theory* *theory*))  (let (setfuns valfuns provables assertables)    (do ((l (contents *theory*) (cdr l)))        ((null l))        (cond ((atom (car l)))              ((eq '<- (caar l))               (setq setfuns (allsetfuns (caddar l) setfuns))               (cond ((atom (cadar l)))                     (t (setq valfuns (addeq (caadar l) valfuns)))))              ((eq '=> (caar l))               (cond ((atom (cadar l)))                     (t (setq assertables (addeq (caadar l) assertables)))))              ((eq '<= (caar l))               (cond ((atom (cadar l)))                     (t (setq provables (addeq (caadar l) provables)))))              (t (setq provables (addeq (caar l) provables)))))    (finalize-stp provables)))(defun finalize-stp (provables)  (cons `(defprop ,*theory* stpthfinal stpth)        (mapcan 'finalize-stp-relation provables)))(defun finalize-stp-relation (r)  (do ((l (indexps r *theory*) (cdr l)) (nl))      ((null l) (list `(defprop ,r ,(finalname 'stp r) stpthfinal)                      `(defun ,(finalname 'stp r) (p al c)                          (let (bl ol ans)                           (setq bl (environment))                           ,(makscond (nreverse nl))))))      (cond ((atom (car l)))            ((eq r (caar l))             (setq nl (cons '((backup ol))                            (cons `((and (setq ol (unify p al ',(car l) bl))                                         (setq ans (stpexitredo p al c)))                                    (backup ol) ans)                                  nl))))            ((and (memq (caar l) '(<= <==)) (listp (cadar l)) (eq r (caadar l)))             (setq nl (list* '((backup ol))                             `((and (or (< depth *depth*) (not (setq termination t)))                                    (setq ol (unify p al ',(cadar l) bl))                                    (setq ans (stppush ',(cadar l)                                                       ',(cddar l)                                                       bl c)))                               (backup ol)                               (if (eq c ans) nil ans))                             nl))))))