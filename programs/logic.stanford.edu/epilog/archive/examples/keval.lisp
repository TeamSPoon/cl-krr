(defun keval (x al)  (cond ((atom x) (cdr (assq x al)))        ((eq '= (car x)) (eq (keval (cadr x) al) (keval (caddr x) al)))        ((eq 'not (car x)) (not (keval (cadr x) al)))        ((eq 'and (car x)) (keval-and x al))        ((eq 'or (car x)) (keval-or x al))        ((eq '=> (car x)) (keval-=> x al))        ((eq '<= (car x)) (keval-<= x al))        ((eq '<=> (car x)) (eq (keval (cadr x) al) (keval (caddr x) al)))        ((eq 'forall (car x)) (keval-forall x al))        ((eq 'exists (car x)) (keval-exists x al))        (t (apply (cdr (assq (car x) al))                  (mapcar #'(lambda (x) (keval x al)) (cdr x))))))(defun keval-and (x al)  (every #'(lambda (x) (keval x al)) (cdr x)))(defun keval-or (x al)  (some #'(lambda (x) (keval x al)) (cdr x)))(defun keval-=> (x al)  (do ((l (cdr x) (cdr l)))      ((null (cdr l)) (keval (car l) al))      (if (not (keval (car l) al)) (return t))))(defun keval-<= (x al)  (or (keval (cadr x) al) (every #'(lambda (x) (keval x al)) (cddr x))))(defun keval-forall (x al)  (do ((l (cdr (assq 'forall al)) (cdr l)))      ((null l) t)      (if (not (keval (caddr x) (acons (caadr x) (car l) al))) (return nil))))(defun keval-exists (x al)  (do ((l (cdr (assq 'forall al)) (cdr l)))      ((null l))      (if (keval (caddr x) (acons (caadr x) (car l) al)) (return t))))