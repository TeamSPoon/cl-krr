;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; (c) Copyright 1988  Michael R. Genesereth;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(proclaim '(special *theory* alist thing result depth stack termination                    calls level traceliterals tracecalls))(defun pttstash (p &optional (th *theory*))  (do ((l (contrabrfs p) (cdr l)))      ((null l) p)      (stash (brf (car l)) th)))(defun pttp (p &optional (th *theory*))  (let ((*theory* 'pttp))    (decludes 'pttp)    (empty 'pttp)    (includes 'pttp th)    (mapc 'stash (contrabrfs (maknot p)))    (do ((l (alternatives p) (cdr l)))        ((null l) t)        (if (not (idpttp (car l) *theory*)) (return nil)))))(defun idpttp (p &optional (th *theory*))  (setq calls 0)  (do ((old *depth*) (*depth* 4 (+ *depth* 2)) (termination nil nil))      ((> *depth* old) nil)      (cond ((pttpfd p th) (return t))            ((not termination) (return nil)))))(defun pttpfd (p &optional (th *theory*)) "(pttP P &OPTIONAL (TH *THEORY*))  pttP takes a proposition and a theory as arguments.  It  is equivalent  to (pttX T P TH)."  (pttx t p th))(defun pttx (x p &optional (*theory* *theory*)) "(pttX X P &OPTIONAL (TH *THEORY*))  pttX takes an expression, a proposition, and a theory as arguments.  It   tries to prove the specified proposition in the specified theory by applying  all known specialized proof procedures and the ptt rule of inference in a  depth-first, statically  ordered search. If it succeeds, it returns a copy  of the specified expression with variables replaced by values obtained   during the proof process.  If it fails to prove the proposition, the value  is NIL.  NOTE: pttX is similar to DFOX but differs in that it  recognizes CUT and is very highly optimized."  (let ((depth 0) stack (level 0) tracecalls)    (pttbind p (environment) x nil '(pttexitx))))(defun ptts (x p &optional (*theory* *theory*)) "(pttS X P &OPTIONAL (TH *THEORY*))  pttS takes an expression, a proposition, and a theory as arguments.  It  tries to prove the specified proposition in the specified theory by applying  all known specialized proof procedures and the ptt rule of inference in a  depth-first, statically  ordered search. If it succeeds, it returns a list of  copies of the specified expression, one for each way the proposition can be  proved.  In each copy, the variables are replaced by values obtained in the  corresponding proof.  If pttS fails to prove the proposition, the value is  NIL.  NOTE: pttS is similar to DFOS but differs in that it recognizes CUT   and is very highly optimized."  (let ((depth 0) stack (level 0) tracecalls)    (nreverse (pttbind p (environment) x nil '(pttexits)))))(defun pttexitx ()  (setq result (plugstd thing alist)) t)(defun pttexits ()  (setq result (cons (plugstd thing alist) result)) nil)(defun pttbind (p alist thing result c)  (pttcall p alist c)  result)(defun pttcall (p al c)  (setq depth (1+ depth) calls (1+ calls) stack (cons (cons p al) stack))  (if traceliterals (tracecall p al c))  (cond ((> depth *depth*) (ptttermination c))        ((atom p) (cond ((eq t p) (pttexit p al c))                        ((eq 'cut p) (pttexit p al c))			((null p) (pttfail c))			(t (pttrs p al c))))        ((eq 'and (car p)) (pttand p al c))	((eq 'alike (car p)) (pttalike p al c))	((eq 'unalike (car p)) (pttunalike p al c))	((eq 'is (car p)) (pttis p al c))	((eq 'ns (car p)) (pttns p al c))	((eq 'known (car p)) (pttknown p al c))	((eq 'unknown (car p)) (pttunknown p al c))	((eq 'provable (car p)) (pttprovable p al c))	((eq 'unprovable (car p)) (pttunprovable p al c))	((get (car p) 'virtual) (pttvirtual p al c))	(t (pttrs p al c))))(defun pttexit (p al c)  (setq depth (1- depth) stack (cdr stack))  (if traceliterals (traceexit p al))  (apply (car c) (cdr c)))(defun pttexitredo (p al c)  (cond ((pttexit p al c))        (t (pttredo p al c))))(defun pttredo (p al c)  (setq depth (1+ depth) stack (cons (cons p al) stack))  (if traceliterals (traceredo c))  nil)(defun pttfail (c)  (setq depth (1- depth) stack (cdr stack))  (if traceliterals (tracefail c))  nil)(defun ptttermination (c)  (setq depth (1- depth) stack (cdr stack) termination t)  (if traceliterals (tracetermination c))  nil)(defun pttand (p al c)  (let (ans)    (setq ans (pttpush p (cdr p) al c))    (cond ((null ans) (pttfail c))          ((eq c ans) (pttfail c))          (t ans))))(defun pttpush (p pl al c)  (cond ((null pl) (pttexitredo p al c))        ((eq 'cut (car pl)) (pttcut p pl al c))        ((pttcall (car pl) al (list 'pttpush p (cdr pl) al c)))))(defun pttcut (p pl al c)  (cond ((pttpush p (cdr pl) al c))        (t c)))(defun pttrs (p al c)  (do ((l (cdr stack) (cdr l)) (ans) (ol))      ((null l) (cond ((pttrsdb p al c *theory*))                      (t (pttfail c))))      (cond ((identify (caar l) (cdar l) p al) (return (pttfail c)))            ((setq ol (unify (maknot (caar l)) (cdar l) p al))             (cond ((setq ans (pttexitredo p al c))                    (backup ol)                    (return ans))                   (t (backup ol)))))))(defun pttrsdb (p al c th)  (cond ((pttrsth p al c th))	(t (do ((l (includees th) (cdr l)) (ans))	       ((null l) nil)	       (if (setq ans (pttrsdb p al c (car l)))		   (return ans))))))(defun pttrsth (p al c th)  (do ((l (indexps p th) (cdr l)) (bl (environment)) (ol) (ans))      ((null l) nil)      (cond ((and (listp (car l)) (memq (caar l) '(<= <==)))	     (cond  ((not (setq ol (unify p al (cadar l) bl))))		    ((not (setq ans (pttpush (cadar l) (cddar l) bl c)))		     (backup ol))		    ((eq c ans) (backup ol) (return nil))		    (t (return ans))))	    ((setq ol (unify p al (car l) bl))	     (cond ((setq ans (pttexitredo p al c))		    (backup ol)		    (return ans))		   (t (backup ol)))))))(defun pttalike (p al c)  (let (ol)    (if (setq ol (unify (cadr p) al (caddr p) al))        (prog1 (pttexit p al c) (backup ol))        (pttfail c))))(defun pttunalike (p al c)  (let (ol)    (if (setq ol (unify (cadr p) al (caddr p) al))        (progn (pttfail c) (backup ol))        (pttexit p al c))))(defun pttis (p al c)  (cond ((bupvalexp (cadr p) al `(pttisexit ,p ,al ,c)))        (t (pttfail c))))(defun pttisexit (z p al c)  (let (ol)    (if (setq ol (unify z al (caddr p) al))        (prog1 (pttexit p al c) (backup ol)))))(defun pttns (p al c)  (let (dum ol)    (if (setq dum (bupvalexpbind (cadr p) al '(bupvalexitx)))        (if (setq ol (unify dum alist (caddr p) al))            (prog1 (pttfail p al c) (backup ol))            (pttexit p al c))        (pttfail c))))(defun pttknown (p al c)  (cond ((pttcallun (cadr p) al (list 'pttexitredo p al c)))        (t (pttfail c))))(defun pttunknown (p al c)  (if (pttbindun (cadr p) al t nil '(pttexitx))      (pttfail c)      (pttexit p al c)))(defun pttbindun (p alist thing result m)  (pttcallun p alist m))(defun pttcallun (p al c)  (setq depth (1+ depth) calls (1+ calls) stack (cons (cons p al) stack))  (if traceliterals (tracecall p al c))  (cond ((> depth *depth*) (ptttermination c))        ((atom p) (cond ((eq t p) (pttexit p al c))                        ((eq 'cut p) (pttexit p al c))			((null p) (pttfail c))			(t (pttun p al c))))	((eq 'alike (car p)) (pttalike p al c))	((eq 'unalike (car p)) (pttunalike p al c))	((eq 'is (car p)) (pttis p al c))	((eq 'ns (car p)) (pttns p al c))	((eq 'known (car p)) (pttknown p al c))	((eq 'unknown (car p)) (pttunknown p al c))	((eq 'provable (car p)) (pttprovable p al c))	((eq 'unprovable (car p)) (pttunprovable p al c))	((get (car p) 'virtual) (pttvirtual p al c))	(t (pttun p al c))))(defun pttun (p al c)   (cond ((pttundb p al c *theory*))        (t (pttfail c))))(defun pttundb (p al c th)  (cond ((pttunth p al c th))	(t (do ((l (includees th) (cdr l)) (ans))	       ((null l) nil)	       (if (setq ans (pttundb p al c (car l)))		   (return ans))))))(defun pttunth (p al c th)  (do ((l (indexps p th) (cdr l)) (bl (environment)) (ol) (ans))      ((null l) nil)      (cond ((setq ol (unify p al (car l) bl))	     (cond ((setq ans (pttexitredo p al c))		    (backup ol)		    (return ans))		   (t (backup ol)))))))(defun pttprovable (p al c)  (cond ((pttcall (cadr p) al (list 'pttexitredo p al c)))        (t (pttfail c))))(defun pttunprovable (p al c)  (if (let ((thing t) (result nil)) (pttcall (cadr p) al '(pttexitx)))      (pttfail c)      (pttexit p al c)))(defun pttvirtual (p al c)  (if (funcall (get (car p) 'virtual) (plugstd p al))      (pttexit p al c)      (pttfail c)))