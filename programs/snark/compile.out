This is SBCL 1.3.1.debian, an implementation of ANSI Common Lisp.
More information about SBCL is available at <http://www.sbcl.org/>.

SBCL is free software, provided as is, with absolutely no warranty.
It is mostly in the public domain; some portions are provided under
BSD-style licenses.  See the CREDITS and COPYING files in the
distribution for more information.
To load "quicklisp-slime-helper":
  Load 1 ASDF system:
    quicklisp-slime-helper
; Loading "quicklisp-slime-helper"
.
slime-helper.el installed in "/root/quicklisp/slime-helper.el"

To use, add this to your ~/.emacs:

  (load (expand-file-name "~/quicklisp/slime-helper.el"))
  ;; Replace "sbcl" with the path to your implementation
  (setq inferior-lisp-program "sbcl")


* 
T
* 
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFMACRO MVLET ...)
; compiling (DEFMACRO MVLET* ...)
; compiling (DEFUN BINDING-P ...)
; compiling (DEFUN LIST-BINDINGS ...)
; compiling (DEFUN MVLET-EXPANSION ...)
; compiling (DEFUN EXPAND-MVLET ...)
; compiling (DEFUN EXPAND-MVLET1 ...)
; compiling (DEFUN TYPE-SYMBOL-P ...)
; compiling (DEFUN EXTRACT-DECLARATION-SPECIFIERS ...)
; compiling (DEFUN FILTER-DECLARATION-SPECIFIERS ...)
; compiling (DEFUN MVLET-TEST1 ...)
; compiling (DEFUN MVLET-TEST2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFPARAMETER *PROG->-FUNCTION-SECOND-FORMS* ...)
; compiling (DEFPARAMETER *PROG->-SPECIAL-FORMS* ...)
; compiling (DEFUN PROG->*-FUNCTION-SECOND-FORM-P ...)
; compiling (DEFUN PROG->-SPECIAL-FORM ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-PATTERN ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-ARGS ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-RESULT ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-MATCH-ERROR ...)
; compiling (DEFUN PROG->-NO-VARIABLE-ERROR ...)
; compiling (DEFUN PROG->-TOO-MANY-VARIABLES-ERROR ...)
; compiling (DEFUN PROG->-TOO-MANY->S-ERROR ...)
; compiling (DEFUN PROG->-UNRECOGNIZED->-ATOM ...)
; compiling (DEFUN PROG->-ATOM ...)
; compiling (DEFUN PROG->*-FUNCTION-ARGUMENT ...)
; compiling (DEFUN PROCESS-PROG-> ...)
; compiling (DEFUN PROG->*-CALL ...)
; compiling (DEFUN WRAP-PROGN ...)
; compiling (DEFUN WRAP-BLOCK ...)
; compiling (DEFUN PROCESS-PROG->-PROGN ...)
; compiling (DEFUN PROCESS-PROG->-BLOCK ...)
; compiling (DEFMACRO UNNAMED-PROG-> ...)
; compiling (DEFMACRO PROG-> ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.fasl written
; compilation finished in 0:00:00.073
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFCONSTANT NONE ...)
; compiling (DEFCONSTANT TRUE ...)
; compiling (DEFCONSTANT FALSE ...)
; compiling (DEFMACRO DEFINLINE ...)
; compiling (DEFINLINE NEQ ...)
; compiling (DEFINLINE NEQL ...)
; compiling (DEFINLINE NEQUAL ...)
; compiling (DEFINLINE NEQUALP ...)
; compiling (DEFINLINE IFF ...)
; compiling (DEFMACRO IMPLIES ...)
; compiling (DEFMACRO IF-LET ...)
; compiling (DEFMACRO WHEN-LET ...)
; compiling (DEFUN KWOTE ...)
; compiling (DEFUN UNQUOTE ...)
; compiling (DEFINLINE RREST ...)
; compiling (DEFINLINE RRREST ...)
; compiling (DEFINLINE RRRREST ...)
; compiling (DEFINLINE MKLIST ...)
; compiling (DEFUN FIRSTN ...)
; compiling (DEFUN CONSN ...)
; compiling (DEFUN LEAFP ...)
; compiling (DEFUN NATURALP ...)
; compiling (DEFUN RATIOP ...)
; compiling (DEFMACRO CARC ...)
; compiling (DEFMACRO CDRC ...)
; compiling (DEFMACRO CAARCC ...)
; compiling (DEFMACRO CADRCC ...)
; compiling (DEFMACRO CDARCC ...)
; compiling (DEFMACRO CDDRCC ...)
; compiling (DEFMACRO LCONS ...)
; compiling (DEFINLINE CONS-UNLESS-NIL ...)
; compiling (DEFMACRO PUSH-UNLESS-NIL ...)
; compiling (DEFMACRO PUSHNEW-UNLESS-NIL ...)
; compiling (DEFMACRO DOTAILS ...)
; compiling (DEFMACRO DOPAIRS ...)
; compiling (DEFUN CHOOSE ...)
; compiling (DEFUN INTEGERS-BETWEEN ...)
; compiling (DEFUN INTS ...)
; compiling (DEFUN LENGTH= ...)
; compiling (DEFUN LENGTH< ...)
; compiling (DEFUN LENGTH<= ...)
; compiling (DEFINLINE LENGTH> ...)
; compiling (DEFINLINE LENGTH>= ...)
; compiling (DEFUN ACONS+ ...)
; compiling (DEFUN ALIST-NOTANY-PLUSP ...)
; compiling (DEFUN ALIST-NOTANY-MINUSP ...)
; compiling (DEFUN CONS-COUNT ...)
; compiling (DEFUN CHAR-INVERT-CASE ...)
; compiling (LET (#) ...)
; compiling (DEFUN TO-STRING ...)
; compiling (DEFUN FIND-OR-MAKE-PACKAGE ...)
; compiling (DEFUN PERCENTAGE ...)
; compiling (DEFUN PRINT-TIME ...)
; compiling (DEFUN PRINT-UNIVERSAL-TIME ...)
; compiling (DEFUN PRINT-CURRENT-TIME ...)
; compiling (DEFUN LEAP-YEAR-P ...)
; compiling (DEFUN DAYS-PER-MONTH ...)
; compiling (DEFUN MONTH-NUMBER ...)
; compiling (DEFUN PRINT-ARGS ...)
; compiling (DEFMACRO DEFINE-PLIST-SLOT-ACCESSOR ...)
; compiling (DEFVAR *PRINT-PRETTY2* ...)
; compiling (DEFMACRO WITH-STANDARD-IO-SYNTAX2 ...)
; compiling (DEFUN QUIT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN QUIT
;     (QUIT)
; 
; caught STYLE-WARNING:
;   The function SB-EXT:QUIT has been deprecated as of SBCL version 1.0.56.55.
;   
;   Use SB-EXT:EXIT or SB-THREAD:ABORT-THREAD instead.
;   
;   In future SBCL versions SB-EXT:QUIT will signal a full warning at compile-time.
;   See also:
;     The SBCL Manual, Node "Deprecation Conditions"


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.fasl written
; compilation finished in 0:00:00.176
WARNING: Reference to deprecated function (SB-EXT:QUIT) from QUIT
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/collectors.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN MAKE-COLLECTOR ...)
; compiling (DEFUN COLLECTOR-VALUE ...)
; compiling (DEFUN COLLECT-ITEM ...)
; compiling (DEFUN COLLECT-LIST ...)
; compiling (DEFSTRUCT (QUEUE # ...) ...)
; compiling (DEFUN QUEUE-EMPTY-P ...)
; compiling (DEFUN ENQUEUE ...)
; compiling (DEFUN DEQUEUE ...)
; compiling (DEFMACRO COLLECT ...)
; compiling (DEFMACRO NCOLLECT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/collectors.fasl written
; compilation finished in 0:00:00.042
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN MAPNCONC-FILE-FORMS ...)
; compiling (DEFUN MAPNCONC-FILE-LINES ...)
; compiling (DEFUN MAPNCONC-STREAM-FORMS ...)
; compiling (DEFUN MAPNCONC-STREAM-LINES ...)
; compiling (DEFUN MAPNCONC-STREAM0 ...)
; compiling (DEFUN READ-FILE ...)
; compiling (DEFUN READ-FILE-LINES ...)
; compiling (DEFUN READ-FILE-TO-STRING ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.fasl written
; compilation finished in 0:00:00.035
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFVAR *CLOCKS* ...)
; compiling (DEFUN MAKE-CLOCK-VARIABLE ...)
; compiling (MAPC (FUNCTION MAKE-CLOCK-VARIABLE) ...)
; compiling (DEFVAR *EXCLUDED-CLOCKS* ...)
; compiling (DEFVAR *RUNNING-CLOCKS* ...)
; compiling (DEFVAR *FIRST-REAL-TIME-VALUE* ...)
; compiling (DEFVAR *FIRST-RUN-TIME-VALUE* ...)
; compiling (DEFVAR *LAST-RUN-TIME-VALUE* ...)
; compiling (DEFVAR *RUN-TIME-MARK* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *TOTAL-SECONDS* ...)
; compiling (DEFUN INITIALIZE-CLOCKS ...)
; compiling (DEFMACRO WITH-CLOCK-ON ...)
; compiling (DEFMACRO WITH-CLOCK-OFF ...)
; compiling (DEFUN CLOCK-NAME ...)
; compiling (DEFUN PRINT-CLOCKS ...)
; compiling (DEFUN TOTAL-RUN-TIME ...)
; compiling (DEFUN PRINT-INCREMENTAL-TIME-USED ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.fasl written
; compilation finished in 0:00:00.041
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFSTRUCT (COUNTER # ...) ...)
; compiling (DEFUN INCREMENT-COUNTER ...)
; compiling (DEFUN DECREMENT-COUNTER ...)
; compiling (DEFUN COUNTER-VALUE ...)
; compiling (DEFUN COUNTER-VALUES ...)
; compiling (DEFINLINE SHOW-COUNT-P ...)
; compiling (DEFUN SHOW-COUNT ...)
; compiling (DEFUN SHOW-COUNT0 ...)
; compiling (DEFUN SHOW-COUNT1 ...)
; compiling (DEFMACRO PRINCF ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.fasl written
; compilation finished in 0:00:00.041
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/pattern-match.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN PATTERN-MATCH ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/pattern-match.fasl written
; compilation finished in 0:00:00.006
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN TOPOLOGICAL-SORT* ...)
; compiling (DEFUN TOPOLOGICAL-SORT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.fasl written
; compilation finished in 0:00:00.006
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-DEQUE)
; compiling (DEFSTRUCT (DEQUE #) ...)
; compiling (DEFUN DEQUE-EMPTY? ...)
; compiling (DEFUN DEQUE-FIRST ...)
; compiling (DEFUN DEQUE-LAST ...)
; compiling (DEFUN DEQUE-REST ...)
; compiling (DEFUN DEQUE-BUTLAST ...)
; compiling (DEFUN DEQUE-POP-FIRST ...)
; compiling (DEFUN DEQUE-POP-LAST ...)
; compiling (DEFUN DEQUE-ADD-FIRST ...)
; compiling (DEFUN DEQUE-ADD-LAST ...)
; compiling (DEFUN DEQUE-PUSH-FIRST ...)
; compiling (DEFUN DEQUE-PUSH-LAST ...)
; compiling (DEFUN DEQUE-LENGTH ...)
; compiling (DEFUN DEQUE-DELETE ...)
; compiling (DEFUN DEQUE-DELETE-IF ...)
; compiling (DEFUN MAPNCONC-DEQUE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.fasl written
; compilation finished in 0:00:00.052
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFTYPE SPARSE-VECTOR-INDEX ...)
; compiling (DEFTYPE SPARSE-VECTOR-COUNT ...)
; compiling (DEFSTRUCT (SPARSE-VECTOR # ...) ...)
; compiling (DEFUN MAKE-SPARSE-VECTOR ...)
; compiling (DEFINLINE SPARSE-VECTOR-BOOLEAN ...)
; compiling (DEFINLINE SPARSE-VECTOR-DEFAULT-VALUE ...)
; compiling (DEFINLINE SPARSE-VECTOR-COUNT ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE-1 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2+1 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2-1 ...)
; compiling (DEFMACRO MAKE-B-TREE-NODE ...)
; compiling (DEFMACRO B-TREE-NODE-ALIST ...)
; compiling (DEFMACRO B-TREE-NODE-NONLEAF-LAST-VALUE ...)
; compiling (DEFINLINE B-TREE-NONLEAF-NODE-ALIST-SEARCH ...)
; compiling (DEFINLINE LASTC ...)
; compiling (DEFINLINE SMALLEST-KEY ...)
; compiling (DEFINLINE LARGEST-KEY ...)
; compiling (DEFINLINE B-TREE-NODE-SMALLEST-KEY* ...)
; compiling (DEFINLINE B-TREE-NODE-LARGEST-KEY* ...)
; compiling (DEFUN NESTN ...)
; compiling (DEFMACRO UNROLL-SPAREF1-LEAF ...)
; compiling (DEFMACRO UNROLL-SPAREF1-NONLEAF ...)
; compiling (DEFMACRO UNROLL-FULL-ALIST ...)
; compiling (DEFINLINE FULL-ALIST ...)
; compiling (DEFUN SPAREF1 ...)
; compiling (DEFMACRO SPAREF ...)
; compiling (DEFUN SPARSE-VECTOR-SETTER ...)
; compiling (DEFUN COPY-SPARSE-VECTOR ...)
; compiling (DEFINLINE SPACONS ...)
; compiling (DEFMACRO DO-MAP-SPARSE-VECTOR-BACKWARD ...)
; compiling (DEFMACRO DO-MAP-SPARSE-VECTOR-FORWARD ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-INDEXES-ONLY ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-INDEXES-ONLY ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-INDEXES-ONLY ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-INDEXES-ONLY ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-WITH-INDEXES ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-WITH-INDEXES ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED ...)
; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-VECTOR0 ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-WITH-INDEXES ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-INDEXES-ONLY ...)
; compiling (DEFUN FIRST-SPAREF ...)
; compiling (DEFUN LAST-SPAREF ...)
; compiling (DEFUN POP-FIRST-SPAREF ...)
; compiling (DEFUN POP-LAST-SPAREF ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.fasl written
; compilation finished in 0:00:01.082
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFSTRUCT (SPARSE-MATRIX # ...) ...)
; compiling (DEFUN MAKE-SPARSE-MATRIX ...)
; compiling (DEFUN SPARSE-MATRIX-COUNT ...)
; compiling (DEFUN SPAREF2 ...)
; compiling (DEFUN SPARSE-MATRIX-ROW ...)
; compiling (DEFUN (SETF SPARSE-MATRIX-ROW) ...)
; compiling (DEFUN SPARSE-MATRIX-COLUMN ...)
; compiling (DEFUN (SETF SPARSE-MATRIX-COLUMN) ...)
; compiling (DEFUN ADD-SPARSE-MATRIX-ROW-OR-COLUMN ...)
; compiling (DEFUN DELETE-SPARSE-MATRIX-ROW-OR-COLUMN ...)
; compiling (DEFUN (SETF SPAREF1) ...)
; compiling (DEFUN (SETF SPAREF2) ...)
; compiling (DEFUN MAP-SPARSE-MATRIX ...)
; compiling (DEFUN MAP-SPARSE-MATRIX-WITH-INDEXES ...)
; compiling (DEFUN MAP-SPARSE-MATRIX-INDEXES-ONLY ...)
; compiling (DEFUN PRINT-SPARSE-VECTOR3 ...)
; compiling (DEFUN PRINT-SPARSE-MATRIX3 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.fasl written
; compilation finished in 0:00:00.086
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFINLINE MEM-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFUN MEM-SPARSE-VECTOR-EXPRESSION1 ...)
; compiling (DEFMACRO MAP-SPARSE-VECTOR-EXPRESSION-MACRO ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES0 ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY0 ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION0 ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-VALUES2 ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-SIZE ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-MAXCOUNT ...)
; compiling (DEFUN OPTIMIZED-SPARSE-VECTOR-EXPRESSION-MAXCOUNT ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-INDEX-BOUNDS ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-GENERATES-IN-ORDER-P ...)
; compiling (DEFUN EQUAL-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFUN EQUAL-OPTIMIZED-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFINLINE OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFINLINE OPTIMIZE-AND-SORT-SHORT-LISTS-OF-SPARSE-VECTOR-EXPRESSIONS ...)
; compiling (DEFUN OPTIMIZE-SPARSE-VECTOR-EXPRESSION1 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.fasl written
; compilation finished in 0:00:00.202
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-NUMBERING)
; compiling (DEFVAR *NONCE* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *STANDARD-EQL-NUMBERING*)
; compiling (DEFINLINE NONCE ...)
; compiling (DEFUN INITIALIZE-NUMBERINGS ...)
; compiling (DEFUN MAKE-NUMBERING ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.fasl written
; compilation finished in 0:00:00.013
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-AGENDA)
; compiling (DEFSTRUCT (AGENDA # ...) ...)
; compiling (DEFUN FIND-AGENDA-BUCKET ...)
; compiling (DEFUN FIRST-OR-LAST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFINLINE FIRST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFINLINE LAST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFUN COLLECT-AGENDA-BUCKETS ...)
; compiling (DEFUN AGENDA-INSERT ...)
; compiling (DEFUN AGENDA-DELETE ...)
; compiling (DEFUN AGENDA-FIRST ...)
; compiling (DEFUN POP-AGENDA ...)
; compiling (DEFUN MAP-AGENDA-BUCKETS ...)
; compiling (DEFUN MAPNCONC-AGENDA ...)
; compiling (DEFUN AGENDA-DELETE-IF ...)
; compiling (DEFUN LIMIT-AGENDA-LENGTH ...)
; compiling (DEFVAR *AGENDA*)
; compiling (DEFUN PRINT-AGENDA ...)
; compiling (DEFUN PRINT-AGENDA3 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.fasl written
; compilation finished in 0:00:00.110
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-INFIX-READER)
; compiling (DEFVAR *INFIX-OPERATORS* ...)
; compiling (DEFVAR *PREFIX-OPERATORS* ...)
; compiling (DEFVAR *POSTFIX-OPERATORS* ...)
; compiling (DEFPARAMETER INFIX-TYPES ...)
; compiling (DEFPARAMETER PREFIX-TYPES ...)
; compiling (DEFPARAMETER POSTFIX-TYPES ...)
; compiling (DEFSTRUCT (OPERATOR #) ...)
; compiling (DEFINLINE INFIX-OPERATOR-P ...)
; compiling (DEFINLINE PREFIX-OPERATOR-P ...)
; compiling (DEFINLINE POSTFIX-OPERATOR-P ...)
; compiling (DEFUN INITIALIZE-OPERATOR-SYNTAX ...)
; compiling (DEFINLINE OPERATOR-LOOKUP0 ...)
; compiling (DEFINLINE INFIX-OPERATOR-LOOKUP ...)
; compiling (DEFINLINE PREFIX-OPERATOR-LOOKUP ...)
; compiling (DEFINLINE POSTFIX-OPERATOR-LOOKUP ...)
; compiling (DEFUN UPDATE-OPERATOR-SYNTAX ...)
; compiling (DEFUN DECLARE-OPERATOR-SYNTAX ...)
; compiling (DEFINLINE REDUCE-BEFORE? ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.fasl written
; compilation finished in 0:00:00.111
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-INFIX-READER)
; compiling (DEFINLINE ORDINARY-CHAR-P ...)
; compiling (DEFINLINE SEPARATOR-CHAR-P ...)
; compiling (DEFINLINE WHITESPACE-CHAR-P ...)
; compiling (DEFINLINE QUOTATION-CHAR-P ...)
; compiling (DEFINLINE COMMENT-CHAR-P ...)
; compiling (DEFUN TOKENIZE1 ...)
; compiling (DEFUN TOKENIZE ...)
; compiling (DEFUN TOKENS-TO-LISP ...)
; compiling (DEFUN READ-INFIX-TERM ...)
; compiling (DEFUN READ-INFIX-TERMS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.fasl written
; compilation finished in 0:00:00.172
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-FEATURE)
; compiling (DEFVAR *FEATURE-TREE*)
; compiling (DEFSTRUCT (FEATURE-TREE #) ...)
; compiling (DEFSTRUCT (FEATURE # ...) ...)
; compiling (DEFSTRUCT (FEATURE-COMBO # ...) ...)
; compiling (DEFUN INITIALIZE-FEATURES ...)
; compiling (DEFUN MAKE-FEATURE1 ...)
; compiling (DEFUN MAKE-FEATURE ...)
; compiling (DEFUN DECLARE-FEATURE ...)
; compiling (DEFUN DECLARE-FEATURE-ALIASES ...)
; compiling (DEFUN CHARACTERISTIC-FEATURE-TYPE ...)
; compiling (DEFUN EXTRACT-A-CHARACTERISTIC-FEATURE ...)
; compiling (DEFUN RENAME-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN RENAME-FEATURE
;     (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::V)
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK-FEATURE::V
; 
; note: deleting unreachable code

;     (SETF (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE SNARK-FEATURE::X)
;             (NSUBSTITUTE SNARK-FEATURE::NEW-NAME SNARK-FEATURE::NAME
;                          (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE
;                           SNARK-FEATURE::X)))
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK-FEATURE::X
; 
; note: deleting unreachable code

; compiling (DEFUN DELETE-FEATURE ...)
; compiling (DEFINLINE FEATURE-DELETED? ...)
; compiling (DEFUN CAN-BE-FEATURE-NAME ...)
; compiling (DEFUN LOOKUP-FEATURE-NAME ...)
; compiling (DEFUN DELETE-FEATURE-NAME ...)
; compiling (DEFUN THE-FEATURE ...)
; compiling (DEFUN FEATURE-TREE-PREORDER-LABELING ...)
; compiling (DEFINLINE FEATURE> ...)
; compiling (DEFINLINE FEATURE>= ...)
; compiling (DEFINLINE FEATURE< ...)
; compiling (DEFINLINE FEATURE<= ...)
; compiling (DEFUN FEATURE-ANCESTOR ...)
; compiling (DEFINLINE NEAREST-COMMON-FEATURE-ANCESTOR ...)
; compiling (DEFUN FEATURE-INCOMPATIBLE0 ...)
; compiling (DEFINLINE FEATURE-INCOMPATIBLE1 ...)
; compiling (DEFINLINE FEATURE-INCOMPATIBLE2 ...)
; compiling (DEFUN FEATURE-MERGE1 ...)
; compiling (DEFUN FEATURE-MERGE2 ...)
; compiling (DEFUN FEATURE-SET-DIFFERENCE ...)
; compiling (DEFINLINE FEATURE-SUBSUMES1 ...)
; compiling (DEFINLINE FEATURE-SUBSUMES2 ...)
; compiling (DEFUN FEATURE-SUBSUMES? ...)
; compiling (DEFUN FEATURE-CANONICAL-LIST-KEY ...)
; compiling (DEFUN FEATURE-CANONICAL-LIST-UNKEY ...)
; compiling (DEFUN FEATURE-CANONIZE ...)
; compiling (DEFUN CHARACTERISTIC-FEATURE-RESTRICTION ...)
; compiling (DEFINLINE FEATURE-UNION0 ...)
; compiling (DEFINLINE FEATURE-UNION1 ...)
; compiling (DEFINLINE FEATURE-UNION2 ...)
; compiling (DEFUN FEATURE-UNION ...)
; compiling (DEFUN FEATURE-LIVE? ...)
; compiling (DEFUN DECLARE-FEATURES-INCOMPATIBLE ...)
; compiling (DEFUN UNTHE-FEATURE ...)
; compiling (DEFUN FEATURE-SYM ...)
; compiling (DEFUN PRINT-FEATURE3 ...)
; compiling (DEFUN PRINT-FEATURE-COMBO3 ...)
; compiling (DEFUN PRINT-FEATURE ...)
; compiling (DEFUN PRINT-FEATURE-LIST ...)
; compiling (DEFUN PRINT-FEATURE-TREE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.fasl written
; compilation finished in 0:00:00.359
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-DPLL)
; compiling (DEFPARAMETER DP-PROVER ...)
; compiling (DEFPARAMETER DP-VERSION ...)
; compiling (DEFVAR DP-TRACING ...)
; compiling (DEFVAR DP-TRACING-STATE ...)
; compiling (DEFVAR DP-TRACING-MODELS ...)
; compiling (DEFVAR DP-TRACING-CHOICES ...)
; compiling (DEFSTRUCT (DP-CLAUSE-SET # ...) ...)
; compiling (DEFSTRUCT (DP-CLAUSE # ...) ...)
; compiling (DEFSTRUCT (DP-ATOM # ...) ...)
; compiling (DEFVAR *DEFAULT-FIND-ALL-MODELS* ...)
; compiling (DEFVAR *DEFAULT-MODEL-TEST-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-DEPENDENCY-CHECK* ...)
; compiling (DEFVAR *DEFAULT-PURE-LITERAL-CHECK* ...)
; compiling (DEFVAR *DEFAULT-ATOM-CHOICE-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-MORE-UNITS-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-BRANCH-LIMIT* ...)
; compiling (DEFVAR *DEFAULT-TIME-LIMIT* ...)
; compiling (DEFVAR *DEFAULT-MINIMAL-MODELS-SUFFICE* ...)
; compiling (DEFVAR *DEFAULT-MINIMAL-MODELS-ONLY* ...)
; compiling (DEFVAR *DEFAULT-CONVERT-TO-CLAUSES* ...)
; compiling (DEFVAR *DEFAULT-DIMACS-CNF-FORMAT* ...)
; compiling (DEFVAR *DEFAULT-SUBSUMPTION* ...)
; compiling (DEFVAR *DEFAULT-PRINT-SUMMARY* ...)
; compiling (DEFVAR *DEFAULT-PRINT-WARNINGS* ...)
; compiling (DEFVAR *DEPENDENCY-CHECK*)
; compiling (DEFVAR *MORE-UNITS-FUNCTION*)
; compiling (DEFVAR *MINIMAL-MODELS-SUFFICE*)
; compiling (DEFVAR *CLAUSE-SET*)
; compiling (DEFVAR *FAILURE-BRANCH-COUNT* ...)
; compiling (DEFVAR *ASSIGNMENT-COUNT* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *DP-START-TIME*)
; compiling (DEFUN DP-SATISFIABLE-P ...)
; compiling (DEFUN DP-SATISFIABLE-FILE-P ...)
; compiling (DEFUN DP-INSERT ...)
; compiling (DEFUN DP-INSERT-SORTED ...)
; compiling (DEFUN DP-INSERT-WFF ...)
; compiling (DEFVAR *DP-READ-STRING*)
; compiling (DEFVAR *DP-READ-INDEX*)
; compiling (DEFUN DP-READ ...)
; compiling (DEFUN DP-INSERT-FILE ...)
; compiling (DEFMACRO CLAUSE-CONTAINS-TRUE-POSITIVE-LITERAL ...)
; compiling (DEFMACRO CLAUSE-CONTAINS-TRUE-NEGATIVE-LITERAL ...)
; compiling (DEFUN DP-HORN-CLAUSE-SET-P ...)
; compiling (DEFUN DP-COUNT ...)
; compiling (DEFUN DP-CLAUSES ...)
; compiling (DEFUN DP-OUTPUT-CLAUSES-TO-FILE ...)
; compiling (DEFUN ASSERT-DP-CLAUSE-SET-P ...)
; compiling (DEFUN ASSERT-UNVALUED-DP-CLAUSE-SET-P ...)
; compiling (DEFUN ADD-MODEL-CONSTRAINT ...)
; compiling (DEFUN VALUED-ATOMS ...)
; compiling (DEFUN DP-ATOM-NAMED ...)
; compiling (DEFUN NEGATIVE-LITERAL-P ...)
; compiling (DEFUN COMPLEMENTARY-LITERAL ...)
; compiling (DEFUN CLAUSE-CONTAINS-REPEATED-ATOM ...)
; compiling (DEFUN PRINT-DP-CLAUSE-SET3 ...)
; compiling (DEFUN DECODE-DP-CLAUSE ...)
; compiling (DEFUN PRINT-DP-CLAUSE ...)
; compiling (DEFUN PRINT-DP-ATOM ...)
; compiling (DEFUN PRINT-DP-TRACE-LINE ...)
; compiling (DEFUN PRINT-DP-CHOICE-POINTS ...)
; compiling (DEFVAR FLOAT-INTERNAL-TIME-UNITS-PER-SECOND ...)
; compiling (DEFUN RUN-TIME-SINCE ...)
; compiling (DEFMACRO FIRST-NONTRUE-ATOM ...)
; compiling (DEFMACRO FIRST-NONFALSE-ATOM ...)
; compiling (DEFMACRO FIRST-UNASSIGNED-ATOM ...)
; compiling (DEFMACRO NTH-UNASSIGNED-ATOM ...)
; compiling (DEFUN MARK-USED-ATOMS ...)
; compiling (DEFUN MAKE-LEMMA ...)
; compiling (DEFVAR *LAST-TRIED-ATOM*)
; compiling (DEFUN ASSIGN-ATOMS ...)
; compiling (DEFUN UNASSIGN-ATOM ...)
; compiling (DEFUN UNASSIGN-ATOMS ...)
; compiling (DEFUN FIND-UNIT-CLAUSES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE* ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-WITH-MOST-OCCURRENCES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-WITH-MOST-OCCURRENCES-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-WITH-MOST-OCCURRENCES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-WITH-MOST-OCCURRENCES-RANDOMLY ...)
; compiling (DEFUN FIX-DP-CLAUSE-SET ...)
; compiling (DEFUN CHECKPOINT-DP-CLAUSE-SET ...)
; compiling (DEFUN RESTORE-DP-CLAUSE-SET ...)
; compiling (DEFUN UNCHECKPOINT-DP-CLAUSE-SET ...)
; compiling (DEFUN CHECKPOINT-DP-ATOM ...)
; compiling (DEFUN RESTORE-DP-ATOM ...)
; compiling (DEFVAR *VERBOSE-LOOKAHEAD* ...)
; compiling (DEFVAR *VERBOSE-LOOKAHEAD-SHOW-COUNT* ...)
; compiling (DEFUN LOOKAHEAD-TRUE ...)
; compiling (DEFUN LOOKAHEAD-FALSE ...)
; compiling (DEFUN LOOKAHEAD-TRUE-FALSE ...)
; compiling (DEFUN LOOKAHEAD-FALSE-TRUE ...)
; compiling (DEFVAR VALUES-AND-PASSES1 ...)
; compiling (DEFVAR VALUES-AND-PASSES2 ...)
; compiling (DEFVAR VALUES-AND-PASSES3 ...)
; compiling (DEFVAR VALUES-AND-PASSES4 ...)
; compiling (DEFVAR VALUES-AND-PASSES5 ...)
; compiling (DEFVAR VALUES-AND-PASSES6 ...)
; compiling (DEFVAR VALUES-AND-PASSES7 ...)
; compiling (DEFVAR VALUES-AND-PASSES8 ...)
; compiling (DEFUN LOOKAHEAD* ...)
; compiling (DEFUN SHOW-COUNT-P ...)
; compiling (DEFUN SHOW-COUNT ...)
; compiling (DEFUN VARIABLE-AND-RANGE-P ...)
; compiling (DEFUN VARIABLES-AND-RANGES-P ...)
; compiling (DEFUN QUOTEVAL ...)
; compiling (DEFUN VARIABLE-RANGE ...)
; compiling (DEFUN RANGE-TERM-VALUE ...)
; compiling (DEFUN EXPAND-RANGE-FORM ...)
; compiling (DEFUN REPLACE-VARIABLE-BY-VALUE-IN-TERM ...)
; compiling (DEFUN WFF-CLAUSES ...)
; compiling (DEFVAR *VERBOSE-SUBSUMPTION* ...)
; compiling (DEFVAR *SUBSUMPTION-SHOW-COUNT* ...)
; compiling (DEFUN DP-SUBSUMPTION ...)
; compiling (DEFUN ALLWAYS-3-PROBLEM ...)
; compiling (DEFUN PIGEONHOLE-PROBLEM ...)
; compiling (DEFUN QUEENS-PROBLEM ...)
; compiling (DEFUN GRAPH-COLORING-PROBLEM ...)
; compiling (DEFUN PIGEONHOLE-PROBLEM-CLAUSES ...)
; compiling (DEFUN QUEENS-PROBLEM-CLAUSES ...)
; compiling (DEFUN GRAPH-COLORING-PROBLEM-CLAUSES ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.fasl written
; compilation finished in 0:00:00.971
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/useful.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO SETQ-ONCE ...)
; compiling (DEFINLINE ASSOC/EQ ...)
; compiling (DEFUN LIST-P ...)
; compiling (DEFVAR *OUTPUTTING-COMMENT* ...)
; compiling (DEFINLINE COMMENT* ...)
; compiling (DEFINLINE NOCOMMENT* ...)
; compiling (DEFUN COMMENT ...)
; compiling (DEFUN NOCOMMENT ...)
; compiling (DEFUN TERPRI ...)
; compiling (DEFUN TERPRI-COMMENT ...)
; compiling (DEFVAR *TERPRI-INDENT* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFUN TERPRI-COMMENT-INDENT ...)
; compiling (DEFUN TERPRI-INDENT ...)
; compiling (DEFUN UNIMPLEMENTED ...)
; compiling (DEFVAR *HASH-DOLLAR-PACKAGE* ...)
; compiling (DEFVAR *HASH-DOLLAR-READTABLE* ...)
; compiling (DEFUN HASH-DOLLAR-READER ...)
; compiling (DEFUN INITIALIZE-HASH-DOLLAR-READER ...)
; compiling (INITIALIZE-HASH-DOLLAR-READER)
; compiling (DEFSTRUCT (HASH-DOLLAR # ...) ...)
; compiling (DEFUN PRINT-HASH-DOLLAR-SYMBOL3 ...)
; compiling (DEFUN HASH-DOLLAR-SYMBOLIZE ...)
; compiling (DEFUN HASH-DOLLAR-PRIN1 ...)
; compiling (DEFUN HASH-DOLLAR-PRINT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/useful.fasl written
; compilation finished in 0:00:00.051
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-POSET ...)
; compiling (DEFINLINE POSET-GREATERP ...)
; compiling (DEFINLINE POSET-LESSP ...)
; compiling (DEFUN POSET-EQUIVALENT ...)
; compiling (DEFUN DECLARE-POSET-GREATERP ...)
; compiling (DEFUN DECLARE-POSET-LESSP ...)
; compiling (DEFUN POSET-SUPERIORS ...)
; compiling (DEFUN POSET-INFERIORS ...)
; compiling (DEFUN ADD-EDGE-TRANSITIVELY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.fasl written
; compilation finished in 0:00:00.015
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SOLVE-SUM ...)
; compiling (DEFUN SOLVE-SUM-P ...)
; compiling (DEFUN SOLVE-SUM-SOLUTIONS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.fasl written
; compilation finished in 0:00:00.024
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/globals.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SNARK-GLOBALS* ...)
; compiling (DEFVAR *SNARK-NONSAVE-GLOBALS* ...)
; compiling (DEFUN SUSPEND-SNARK* ...)
; compiling (DEFUN RESUME-SNARK ...)
; compiling (DEFUN SUSPEND-SNARK ...)
; compiling (DEFUN SUSPEND-AND-RESUME-SNARK ...)
; compiling (DEFUN AUDIT-SNARK-GLOBALS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/globals.fasl written
; compilation finished in 0:00:00.019
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SNARK-GLOBALS* ...))
; compiling (DEFVAR *SNARK-OPTIONS* ...)
; compiling (DEFMACRO DECLARE-SNARK-OPTION ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-SYMBOL-PREFIXES ...)
; compiling (DECLARE-SNARK-OPTION USE-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-NEGATIVE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-UR-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-UR-PTTP ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-FACTORING ...)
; compiling (DECLARE-SNARK-OPTION USE-EQUALITY-FACTORING ...)
; compiling (DECLARE-SNARK-OPTION USE-CONDENSING ...)
; compiling (DECLARE-SNARK-OPTION USE-RESOLVE-CODE ...)
; compiling (DECLARE-SNARK-OPTION USE-UNIT-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-INPUT-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-UR-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-SUBSUMPTION-BY-FALSE ...)
; compiling (DECLARE-SNARK-OPTION USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-SIMPLIFICATION-BY-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-SIMPLIFICATION-BY-EQUALITIES ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-ORDERING-CACHE ...)
; compiling (DECLARE-SNARK-OPTION USE-DEFAULT-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION 1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION ORDERING-FUNCTIONS>CONSTANTS ...)
; compiling (DECLARE-SNARK-OPTION RPO-STATUS ...)
; compiling (DECLARE-SNARK-OPTION KBO-STATUS ...)
; compiling (DECLARE-SNARK-OPTION KBO-VARIABLE-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION KBO-BUILTIN-CONSTANT-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION USE-INDEFINITE-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION USE-CONDITIONAL-ANSWER-CREATION ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRUCTIVE-ANSWER-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-ANSWERS-DURING-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION REWRITE-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION REWRITE-CONSTRAINTS ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRAINT-PURIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-EMBEDDED-REWRITES ...)
; compiling (DECLARE-SNARK-OPTION USE-FUNCTION-CREATION ...)
; compiling (DECLARE-SNARK-OPTION USE-REPLACEMENT-RESOLUTION-WITH-X=X ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION-ONLY-INTO-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION-ONLY-FROM-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-SINGLE-REPLACEMENT-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-PARTITIONS ...)
; compiling (DECLARE-SNARK-OPTION PARTITION-COMMUNICATION-TABLE ...)
; compiling (DECLARE-SNARK-OPTION DECLARE-ROOT-SORT ...)
; compiling (DECLARE-SNARK-OPTION DECLARE-STRING-SORT ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-CONTEXT ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION ASSUME-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION PROVE-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION ASSUME-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION PROVE-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION PROVE-CLOSURE ...)
; compiling (DECLARE-SNARK-OPTION NUMBER-OF-GIVEN-ROWS-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION NUMBER-OF-ROWS-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-LENGTH-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION RUN-TIME-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-ARGUMENT-COUNT-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-WEIGHT-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION LEVEL-PREF-FOR-GIVING ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION BUILTIN-CONSTANT-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION BAG-WEIGHT-FACTORIAL ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-ORDERING-FUNCTION ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-SIZE-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-WEIGHT-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-DEPTH-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-LEVEL-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION PRUNING-TESTS ...)
; compiling (DECLARE-SNARK-OPTION PRUNING-TESTS-BEFORE-SIMPLIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-CLAUSIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-EQUALITY-ELIMINATION ...)
; compiling (DECLARE-SNARK-OPTION USE-MAGIC-TRANSFORMATION ...)
; compiling (DECLARE-SNARK-OPTION USE-AC-CONNECTIVES ...)
; compiling (DECLARE-SNARK-OPTION USE-PURITY-TEST ...)
; compiling (DECLARE-SNARK-OPTION USE-RELEVANCE-TEST ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSERTION-ANALYSIS ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSOCIATIVE-UNIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSOCIATIVE-IDENTITY ...)
; compiling (DECLARE-SNARK-OPTION USE-DP-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION UNIFY-BAG-BASIS-SIZE-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-MEMORY-DELETION ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-SORT-MARKER ...)
; compiling (DECLARE-SNARK-OPTION USE-VARIABLE-NAME-SORTS ...)
; compiling (DECLARE-SNARK-OPTION USE-WELL-SORTING ...)
; compiling (DECLARE-SNARK-OPTION USE-EXTENDED-IMPLICATIONS ...)
; compiling (DECLARE-SNARK-OPTION USE-EXTENDED-QUANTIFIERS ...)
; compiling (DECLARE-SNARK-OPTION USE-SORT-RELATIVIZATION ...)
; compiling (DECLARE-SNARK-OPTION USE-QUANTIFIER-PRESERVATION ...)
; compiling (DECLARE-SNARK-OPTION INPUT-FLOATS-AS-RATIOS ...)
; compiling (DECLARE-SNARK-OPTION USE-CLOSURE-WHEN-SATISFIABLE ...)
; compiling (DECLARE-SNARK-OPTION LISTEN-FOR-COMMANDS ...)
; compiling (DECLARE-SNARK-OPTION USE-TO-LISP-CODE ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-TO-LISP-CODE ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-GIVEN ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-DERIVED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-PROCESSED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-FINAL-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-UNORIENTABLE-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-PURE-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-IRRELEVANT-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-REWRITE-ORIENTATION ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-TEST ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-SHORTENED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-PRETTILY ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-WFFS-PRETTILY ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-CONSTRAINTS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-REASONS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-GOALS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-PARTITIONS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-LENGTH-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION PRINT-GIVEN-ROW-LINES-PRINTING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-GIVEN-ROW-LINES-SIGNALLING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-SUMMARY-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-CLOCKS-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-TERM-MEMORY-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-AGENDA-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-OPTIONS-WHEN-STARTING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ASSERTION-ANALYSIS-NOTES ...)
; compiling (DECLARE-SNARK-OPTION PRINT-SYMBOL-TABLE-WARNINGS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-TIME-USED ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY ...)
; compiling (DECLARE-SNARK-OPTION METER-UNIFY-BAG ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY-BAG-BASIS ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY-BAG-BINDINGS ...)
; compiling (DECLARE-SNARK-OPTION TRACE-DP-REFUTE ...)
; compiling (DECLARE-SNARK-OPTION TRACE-REWRITE ...)
; compiling (DECLARE-SNARK-OPTION TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DECLARE-SNARK-OPTION TRACE-DPLL-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT ...)
; compiling (DECLARE-SNARK-OPTION CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION2 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION3 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION6 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION8 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION9 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION14 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION17 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION18 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION19 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION20 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION21 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION23 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION29 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION30 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION36 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION37 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION38 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION39 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION40 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION41 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION42 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION43 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION44 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION45 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION49 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION50 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION51 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION52 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION53 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION54 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION55 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION56 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION57 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION58 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION59 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION60 ...)
; compiling (DEFVAR OPTIONS-HAVE-BEEN-CRITIQUED)
; compiling (DEFUN INITIALIZE-OPTIONS ...)
; compiling (DEFUN FINALIZE-OPTIONS ...)
; compiling (DEFUN SNARK-OPTION-SPEC-P ...)
; compiling (DEFUN SET-OPTIONS ...)
; compiling (DEFMACRO LET-OPTIONS ...)
; compiling (DEFUN PRINT-OPTIONS ...)
; compiling (DEFMETHOD AGENDA-LENGTH-LIMIT ...)
; compiling (DEFMETHOD AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DEFMETHOD USE-RESOLVE-CODE ...)
; compiling (DEFMETHOD USE-TERM-ORDERING ...)
; compiling (DEFMETHOD USE-CONSTRAINT-PURIFICATION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.fasl written
; compilation finished in 0:00:00.829
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *CONS*)
; compiling (DEFVAR *=*)
; compiling (DEFVAR *NOT*)
; compiling (DEFVAR *AND*)
; compiling (DEFVAR *OR*)
; compiling (DEFVAR *IMPLIES*)
; compiling (DEFVAR *IMPLIED-BY*)
; compiling (DEFVAR *IFF*)
; compiling (DEFVAR *XOR*)
; compiling (DEFVAR *IF*)
; compiling (DEFVAR *FORALL*)
; compiling (DEFVAR *EXISTS*)
; compiling (DEFVAR *ANSWER-IF*)
; compiling (DEFVAR *A-FUNCTION-WITH-LEFT-TO-RIGHT-ORDERING-STATUS*)
; compiling (DEFVAR *A-FUNCTION-WITH-MULTISET-ORDERING-STATUS*)
; compiling (DEFINLINE COMPOUND-APPL-P ...)
; compiling (DEFINLINE HEADA ...)
; compiling (DEFINLINE ARGSA ...)
; compiling (DEFINLINE CONSTANT-P ...)
; compiling (DEFINLINE COMPOUND-P ...)
; compiling (DEFUN MAKE-COMPOUND%2 ...)
; compiling (DEFUN MAKE-COMPOUND%* ...)
; compiling (DEFMACRO MAKE-COMPOUND ...)
; compiling (DEFMACRO MAKE-COMPOUND* ...)
; compiling (DEFINLINE ARG1A ...)
; compiling (DEFINLINE ARG2A ...)
; compiling (DEFINLINE ARG1 ...)
; compiling (DEFINLINE ARG2 ...)
; compiling (DEFINLINE ARGS ...)
; compiling (DEFINLINE HEAD ...)
; compiling (DEFINLINE HEAD-OR-TERM ...)
; compiling (DEFMACRO FANCY-MAKE-COMPOUND* ...)
; compiling (DEFUN MAKE-COMPOUND2 ...)
; compiling (DEFMACRO MAKE-A1-COMPOUND* ...)
; compiling (DEFMACRO DEREFERENCE ...)
; compiling (DEFMACRO DEREFERENCE2 ...)
; compiling (DEFMACRO PREFER-TO-BIND-P ...)
; compiling (DEFVAR *FROZEN-VARIABLES* ...)
; compiling (DEFINLINE VARIABLE-FROZEN-P ...)
; compiling (DEFINLINE UNFROZEN-VARIABLE-P ...)
; compiling (DEFINLINE MAKE-TC ...)
; compiling (DEFINLINE TC-TERM ...)
; compiling (DEFMACRO TC-COUNT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.fasl written
; compilation finished in 0:00:00.177
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ROWSETS*)
; compiling (DEFVAR *ROWS*)
; compiling (DEFVAR *ROW-COUNT* ...)
; compiling (DEFVAR *NUMBER-OF-ROWS* ...)
; compiling (DEFVAR *ROW-NAMES*)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFUN UNINITIALIZED ...)
; compiling (DEFSTRUCT (ROW # ...) ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFUN ROW-WFF-SYMBOL-COUNTS ...)
; compiling (DEFUN ROW-NAME-OR-NUMBER ...)
; compiling (DEFMACRO MAKE-ROW ...)
; compiling (DEFUN INITIALIZE-ROWS ...)
; compiling (DEFUN ROW-GIVEN-P ...)
; compiling (DEFUN ROW-DELETED-P ...)
; compiling (DEFUN ROW-HINT-P ...)
; compiling (DEFUN ROW-INPUT-P ...)
; compiling (DEFUN ROW-NONASSERTION-P ...)
; compiling (DEFUN ROW-FROM-CONJECTURE-P ...)
; compiling (DEFUN ROW-PARENTS ...)
; compiling (DEFUN ROW-PARENT ...)
; compiling (DEFUN ROW-EMBEDDING-P ...)
; compiling (DEFUN ROW-REWRITES-USED ...)
; compiling (DEFUN (SETF ROW-REWRITES-USED) ...)
; compiling (DEFUN ROW-LEVEL ...)
; compiling (DEFUN ROW-CLAUSE-P ...)
; compiling (DEFUN ROW-UNIT-P ...)
; compiling (DEFUN ROW-BARE-P ...)
; compiling (DEFUN ROW-BARE-UNIT-P ...)
; compiling (DEFUN ROW-POSITIVE-P ...)
; compiling (DEFUN ROW-NEGATIVE-P ...)
; compiling (DEFUN ROW-VARIABLES ...)
; compiling (DEFUN ROW-SUPPORTED-INHERITABLY ...)
; compiling (DEFUN ROW-SEQUENTIAL-INHERITABLY ...)
; compiling (DEFUN MAKE-ROWSET ...)
; compiling (DEFUN ROWSET-SIZE ...)
; compiling (DEFUN ROWSET-INSERT ...)
; compiling (DEFUN ROWSET-DELETE ...)
; compiling (DEFUN ROWSETS-DELETE ...)
; compiling (DEFUN ROWSETS-DELETE-COLUMN ...)
; compiling (DEFUN ROWSET-EMPTY? ...)
; compiling (DEFUN MAP-ROWS-IN-REASON ...)
; compiling (DEFUN ROWS-IN-REASON ...)
; compiling (DEFUN ROW-ANCESTRY-ROWSET ...)
; compiling (DEFUN ROW-ANCESTRY ...)
; compiling (DEFUN ROW ...)
; compiling (DEFUN MAPNCONC-ROWS ...)
; compiling (DEFUN MAP-ROWS ...)
; compiling (DEFUN ROWS ...)
; compiling (DEFUN LAST-ROW ...)
; compiling (DEFUN SET-ROW-NUMBER ...)
; compiling (DEFUN NAME-ROW ...)
; compiling (DEFUN PRINT-ANCESTRY ...)
; compiling (DEFUN PRINT-ROWS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.fasl written
; compilation finished in 0:00:00.286
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ROOT-ROW-CONTEXT*)
; compiling (DEFVAR *CURRENT-ROW-CONTEXT*)
; compiling (DEFMACRO ROOT-ROW-CONTEXT ...)
; compiling (DEFMACRO CURRENT-ROW-CONTEXT ...)
; compiling (DEFUN INITIALIZE-ROW-CONTEXTS ...)
; compiling (DEFINLINE CONTEXT-PARENT ...)
; compiling (DEFINLINE CONTEXT-LIVE? ...)
; compiling (DEFUN PRINT-ROW-CONTEXT-TREE ...)
; compiling (DEFUN THE-ROW-CONTEXT ...)
; compiling (DEFUN MAKE-ROW-CONTEXT ...)
; compiling (DEFUN DELETE-ROW-CONTEXT ...)
; compiling (DEFUN IN-ROW-CONTEXT ...)
; compiling (DEFUN PUSH-ROW-CONTEXT ...)
; compiling (DEFUN POP-ROW-CONTEXT ...)
; compiling (DEFUN NEW-ROW-CONTEXT ...)
; compiling (DEFUN THE-ROW-CONTEXT2 ...)
; compiling (DEFUN ROW-CONTEXT-LIVE? ...)
; compiling (DEFUN CONTEXT-INTERSECTION-P ...)
; compiling (DEFUN CONTEXT-SUBSUMES? ...)
; compiling (DEFVAR *REWRITING-ROW-CONTEXT* ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.fasl written
; compilation finished in 0:00:00.033
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFSTRUCT CONSTANT-INFO ...)
; compiling (DEFINLINE CONSTANT-NUMBER ...)
; compiling (DEFVAR *CONSTANT-INFO-TABLE*)
; compiling (DEFMACRO CONSTANT-INFO0 ...)
; compiling (DEFINLINE CONSTANT-INFO ...)
; compiling (DEFUN INIT-CONSTANT-INFO ...)
; compiling (DEFMACRO DEFINE-CONSTANT-SLOT-ACCESSOR ...)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR HASH-CODE0 ...)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR BOOLEAN-VALUED-P0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR CONSTRUCTOR0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR MAGIC)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR ALLOWED-IN-ANSWER0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR KBO-WEIGHT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR WEIGHT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR SORT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR PLIST)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFVAR *NUMBER-INFO-TABLE*)
; compiling (DEFVAR *STRING-INFO-TABLE*)
; compiling (DEFSTRUCT (NUMBER-INFO # ...) ...)
; compiling (DEFSTRUCT (STRING-INFO # ...) ...)
; compiling (DEFMACRO NUMBER-INFO ...)
; compiling (DEFMACRO STRING-INFO ...)
; compiling (DEFUN NUMBER-CANONICAL ...)
; compiling (DEFUN DECLARE-NUMBER ...)
; compiling (DEFUN DECLARE-STRING ...)
; compiling (DEFINLINE BUILTIN-CONSTANT-P ...)
; compiling (DEFINLINE CONSTANT-BUILTIN-P ...)
; compiling (DEFUN CONSTANT-HASH-CODE ...)
; compiling (DEFINLINE CONSTANT-BOOLEAN-VALUED-P ...)
; compiling (DEFINLINE CONSTANT-CONSTRUCTOR ...)
; compiling (DEFINLINE CONSTANT-ALLOWED-IN-ANSWER ...)
; compiling (DEFINLINE CONSTANT-KBO-WEIGHT ...)
; compiling (DEFINLINE CONSTANT-WEIGHT ...)
; compiling (DEFUN CONSTANT-SORT ...)
; compiling (DEFUN (SETF CONSTANT-SORT) ...)
; compiling (DEFINLINE CONSTANT-LOCKED ...)
; compiling (DEFINLINE CONSTANT-NAME ...)
; compiling (DEFUN CONSTANT-NAME-LESSP ...)
; compiling (DEFUN INITIALIZE-CONSTANTS ...)
; compiling (DEFMACRO SET-SLOT-IF-SUPPLIED ...)
; compiling (DEFUN DECLARE-CONSTANT-SYMBOL0 ...)
; compiling (DEFUN CHANGEABLE-KEYS-AND-VALUES0 ...)
; compiling (DEFUN CHANGEABLE-KEYS-AND-VALUES ...)
; compiling (DEFUN DECLARE-CONSTANT-SYMBOL1 ...)
; compiling (DEFUN DECLARE-CONSTANT ...)
; compiling (DEFUN DECLARE-PROPOSITION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.fasl written
; compilation finished in 0:00:00.173
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING*))
; compiling (DEFVAR *NAME*)
; compiling (DEFSTRUCT (FUNCTION-SYMBOL # ...) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFSTRUCT FUNCTION-SYMBOL
;     (DEFSTRUCT
;         (SNARK::FUNCTION-SYMBOL
;          (:CONSTRUCTOR SNARK::MAKE-FUNCTION-SYMBOL0 (SNARK::NAME SNARK::ARITY))
;          (:COPIER NIL) (:PRINT-FUNCTION SNARK::PRINT-FUNCTION-SYMBOL)
;          (:CONC-NAME :FUNCTION-))
;       (SNARK::NAME NIL)
;       (SNARK::ARITY NIL :READ-ONLY T)
;       (NUMBER NIL)
;       (SNARK::HASH-CODE (SNARK::MAKE-ATOM-HASH-CODE) :READ-ONLY T)
;       (SNARK::BOOLEAN-VALUED-P NIL)
;       (SNARK::CONSTRUCTOR NIL)
;       (SNARK::INJECTIVE NIL)
;       (SNARK::MAGIC T)
;       (SNARK::ALLOWED-IN-ANSWER T)
;       (SNARK::KBO-WEIGHT 1)
;       ...)
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION SNARK::FUNCTION-SYMBOL {10087671B3}>
;    '#(#<SB-KERNEL:LAYOUT for T {1000099793}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {1000099813}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to SNARK:FUNCTION-SYMBOL-P could not be inlined
;   because the structure definition for SNARK::FUNCTION-SYMBOL was not yet seen.
;   To avoid this warning, DEFSTRUCT should precede references to the affected
;   functions, or they must be declared locally notinline at each call site.

; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINLINE FUNCTION-RPO-STATUS ...)
; compiling (DEFINLINE FUNCTION-KBO-STATUS ...)
; compiling (DEFUN MAKE-FUNCTION-SYMBOL ...)
; compiling (DEFUN FUNCTION-KIND ...)
; compiling (DEFUN FUNCTION-HAS-ARITY-P ...)
; compiling (DEFUN FUNCTION-IDENTITY2 ...)
; compiling (DEFUN FUNCTION-NAME-LESSP ...)
; compiling (DEFUN FUNCTION-NAME-ARITY-LESSP ...)
; compiling (DEFMACRO SET-FUNCTION-CODE ...)
; compiling (DEFUN DECLARE-FUNCTION-SYMBOL0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN DECLARE-FUNCTION-SYMBOL0
;     (SNARK::SET-FUNCTION-CODE SNARK::REWRITE-CODE)
; --> WHEN IF SETF SB-KERNEL:%INSTANCE-SET IF REMOVE-DUPLICATES 
; ==>
;   SNARK::REWRITE-CODE
; 
; note: deleting unreachable code

;     (SNARK::SET-FUNCTION-CODE SNARK::PARAMODULATE-CODE)
; --> WHEN IF SETF SB-KERNEL:%INSTANCE-SET IF REMOVE-DUPLICATES 
; ==>
;   SNARK::PARAMODULATE-CODE
; 
; note: deleting unreachable code

; compiling (DEFUN DECLARE-FUNCTION-SYMBOL1 ...)
; compiling (DEFUN DECLARE-FUNCTION ...)
; compiling (DEFUN DECLARE-RELATION ...)
; compiling (DEFUN DECLARE-LOGICAL-SYMBOL ...)
; compiling (DEFUN DECLARE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN DECLARE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN FUNCTION-CODE-NAME ...)
; compiling (DEFUN FUNCTION-RESOLVE-CODE ...)
; compiling (DEFUN DECLARE-FUNCTION1 ...)
; compiling (DEFUN DECLARE-FUNCTION2 ...)
; compiling (DEFUN DECLARE-RELATION1 ...)
; compiling (DEFUN DECLARE-RELATION2 ...)
; compiling (DEFUN DECLARE-CHARACTERISTIC-RELATION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.fasl written
; compilation finished in 0:00:00.369
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLE-BLOCKS ...)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLES-PER-BLOCK ...)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLES-IN-BLOCKS ...)
; compiling (DEFVAR *VARIABLES*)
; compiling (DEFVAR *NEXT-VARIABLE-NUMBER* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFSTRUCT (VARIABLE # ...) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.lisp
; in: DEFSTRUCT VARIABLE
;     (DEFSTRUCT
;         (SNARK::VARIABLE (:CONSTRUCTOR SNARK::MAKE-VARIABLE0 (SORT NUMBER))
;          (:COPIER NIL) (:PRINT-FUNCTION SNARK::PRINT-VARIABLE))
;       NUMBER
;       SORT)
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION SNARK::VARIABLE {10041A68E3}>
;    '#(#<SB-KERNEL:LAYOUT for T {1000099793}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {1000099813}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to SNARK:VARIABLE-P could not be inlined because the
;   structure definition for SNARK::VARIABLE was not yet seen. To avoid this
;   warning, DEFSTRUCT should precede references to the affected functions, or they
;   must be declared locally notinline at each call site.

; compiling (DEFUN INITIALIZE-VARIABLES ...)
; compiling (DEFUN MAKE-VARIABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.lisp
; in: DEFUN MAKE-VARIABLE
;     (MOD (+ NUMBER 1) SNARK::$NUMBER-OF-VARIABLES-PER-BLOCK)
; --> LET IF AND IF AND THE IF PLUSP > 
; ==>
;   NUMBER
; 
; note: deleting unreachable code

; compiling (DEFUN VARIABLE-BLOCK ...)
; compiling (DEFUN VARIABLE-BLOCK-0-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.fasl written
; compilation finished in 0:00:00.022
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO MAKE-BINDING ...)
; compiling (DEFMACRO BINDING-VAR ...)
; compiling (DEFMACRO BINDING-VALUE ...)
; compiling (DEFMACRO ADD-BINDING-TO-SUBSTITUTION ...)
; compiling (DEFMACRO DOBINDINGS ...)
; compiling (DEFINLINE BIND-VARIABLE-TO-TERM ...)
; compiling (DEFUN LOOKUP-VARIABLE-IN-SUBSTITUTION ...)
; compiling (DEFUN LOOKUP-VALUE-IN-SUBSTITUTION ...)
; compiling (DEFUN LOOKUP-VALUE-IN-SUBSTITUTION2 ...)
; compiling (DEFUN SUBSTITUTION-EQUAL-P ...)
; compiling (DEFUN SUBSTITUTION-SUBSET-P ...)
; compiling (DEFUN SUBSTITUTION-DIFF ...)
; compiling (DEFUN SUBSTITUTION-DIFF2 ...)
; compiling (DEFUN SUBSTITUTION-SUBSET-P1 ...)
; compiling (DEFUN REMOVE-IRRELEVANT-BINDINGS ...)
; compiling (DEFUN PRINT-SUBSTITUTION ...)
; compiling (DEFUN MAKE-IDEMPOTENT-SUBSTITUTION ...)
; compiling (DEFUN VARIABLES ...)
; compiling (DEFUN NONTHEORY-VARIABLES ...)
; compiling (DEFUN VARIABLESL ...)
; compiling (DEFUN FIRST-NONVARIABLE-TERM ...)
; compiling (DEFUN FIRST-NONVARIABLE-SUBTERM ...)
; compiling (DEFUN VARIABLE-COUNTS ...)
; compiling (DEFUN VARIABLE-DISJOINT-PARTITION ...)
; compiling (DEFUN NEW-VARIABLES ...)
; compiling (DEFUN INSTANTIATE ...)
; compiling (DEFUN RENUMBER ...)
; compiling (DEFUN RENUMBERL ...)
; compiling (DEFVAR *RENUMBER-FIRST-NUMBER* ...)
; compiling (DEFVAR *RENUMBER-BY-SORT* ...)
; compiling (DEFVAR *RENUMBER-IGNORE-SORT* ...)
; compiling (DEFUN RENUMBERV ...)
; compiling (DEFUN RENUMBER-NEW ...)
; compiling (DEFUN RENUMBERER ...)
; compiling (DEFUN GROUND-P ...)
; compiling (DEFUN FROZEN-P ...)
; compiling (DEFUN CONSTRUCTOR-TERM-P ...)
; compiling (DEFUN UNSORTED-P ...)
; compiling (DEFUN ALL-VARIABLES-P ...)
; compiling (DEFUN OCCURS-P ...)
; compiling (DEFUN FUNCTION-OCCURS-P ...)
; compiling (DEFUN CONSTANT-OCCURS-P ...)
; compiling (DEFUN COMPOUND-OCCURS-P ...)
; compiling (DEFUN NO-NEW-VARIABLE-OCCURS-P ...)
; compiling (DEFUN CONSTANT-OCCURS-BELOW-CONSTRUCTOR-P ...)
; compiling (DEFUN VARIABLE-OCCURS-BELOW-CONSTRUCTOR-P ...)
; compiling (DEFUN COMPOUND-OCCURS-BELOW-CONSTRUCTOR-P ...)
; compiling (DEFMACRO VARIABLE-OCCURS-P1-MACRO ...)
; compiling (DEFMACRO VARIABLE-OCCURS-P2-MACRO ...)
; compiling (DEFUN VARIABLE-OCCURS-P1L ...)
; compiling (DEFUN VARIABLE-OCCURS-P2L ...)
; compiling (DEFUN VARIABLE-OCCURS-P1 ...)
; compiling (DEFUN VARIABLE-OCCURS-P2 ...)
; compiling (DEFUN VARIABLE-OCCURS-P ...)
; compiling (DEFUN SPECIAL-UNIFY-P ...)
; compiling (DEFUN SKOLEM-OCCURS-P ...)
; compiling (DEFUN DISALLOWED-SYMBOL-OCCURS-IN-ANSWER-P ...)
; compiling (DEFUN EMBEDDING-VARIABLE-OCCURS-P ...)
; compiling (DEFUN SPLIT-IF ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.fasl written
; compilation finished in 0:00:00.272
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBSTITUTE ...)
; compiling (DEFUN SUBSTITUTEL ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT ...)
; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND ...)
; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE ...)
; compiling (DEFUN SUBSTITUTE-ONCE ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT-ONCE ...)
; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND-ONCE ...)
; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE-ONCE ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANTL ...)
; compiling (DEFUN SUBSTITUTE-FOR-COMPOUNDL ...)
; compiling (DEFUN SUBSTITUTE-FOR-VARIABLEL ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT-ONCEL ...)
; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND-ONCEL ...)
; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE-ONCEL ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.fasl written
; compilation finished in 0:00:00.050
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SYMBOL-TABLE*)
; compiling (DECLAIM (SPECIAL *INPUT-WFF*))
; compiling (DEFUN MAKE-SYMBOL-TABLE ...)
; compiling (DEFMACRO SYMBOL-TABLE-ENTRIES ...)
; compiling (DEFUN CREATE-SYMBOL-TABLE-ENTRY ...)
; compiling (DEFUN FIND-SYMBOL-TABLE-ENTRY ...)
; compiling (DEFUN FIND-OR-CREATE-SYMBOL-TABLE-ENTRY ...)
; compiling (DEFUN CREATE-ALIASES-FOR-SYMBOL ...)
; compiling (DEFUN RENAME-FUNCTION-SYMBOL ...)
; compiling (DEFUN SYMBOL-KIND ...)
; compiling (DEFUN SYMBOL-TABLE-KIND-MATCH ...)
; compiling (DEFUN SYMBOL-TABLE-CONSTANT? ...)
; compiling (DEFUN SYMBOL-TABLE-FUNCTION? ...)
; compiling (DEFUN SYMBOL-TABLE-RELATION? ...)
; compiling (DEFUN MAP-SYMBOL-TABLE ...)
; compiling (DEFUN SYMBOL-ALIASES ...)
; compiling (DEFUN PRINT-SYMBOL-TABLE ...)
; compiling (DEFUN SYMBOL-TO-NAME ...)
; compiling (DEFUN SYMBOL-BOOLEAN-VALUED-P ...)
; compiling (DEFUN SYMBOL-NUMBER ...)
; compiling (DEFINLINE SYMBOL-NUMBERED ...)
; compiling (DEFUN THE-FUNCTION-SYMBOL ...)
; compiling (DEFUN CURRENT-FUNCTION-NAME ...)
; compiling (DEFUN INPUT-SYMBOL ...)
; compiling (DEFUN INPUT-CONSTANT-SYMBOL ...)
; compiling (DEFUN INPUT-PROPOSITION-SYMBOL ...)
; compiling (DEFUN INPUT-FUNCTION-SYMBOL ...)
; compiling (DEFUN INPUT-RELATION-SYMBOL ...)
; compiling (DEFUN INPUT-LOGICAL-SYMBOL ...)
; compiling (DEFUN EXPR-ARITY ...)
; compiling (DEFUN INPUT-HEAD-FUNCTION-SYMBOL ...)
; compiling (DEFUN INPUT-HEAD-RELATION-SYMBOL ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.fasl written
; compilation finished in 0:00:00.136
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-definitions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SKOLEM-FUNCTION-ALIST*))
; compiling (DEFVAR *ALL-BOTH-POLARITY*)
; compiling (SETF *ALL-BOTH-POLARITY* ...)
; compiling (RPLACD *ALL-BOTH-POLARITY* ...)
; compiling NIL
; compiling NIL
; compiling (DEFUN INITIALIZE-SYMBOL-TABLE ...)
; compiling (DEFUN INITIALIZE-SYMBOL-TABLE2 ...)
; compiling (DEFUN INITIALIZE-SORT-THEORY2 ...)
; compiling (DEFUN NUMBER-SORT-NAME ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-definitions.fasl written
; compilation finished in 0:00:00.015
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *WFF*)
; compiling (DECLAIM (SPECIAL *EXTENDED-VARIANT*))
; compiling (DEFVAR *ASSERTION-ANALYSIS-PATTERNS*)
; compiling (DEFVAR *ASSERTION-ANALYSIS-FUNCTION-INFO*)
; compiling (DEFVAR *ASSERTION-ANALYSIS-RELATION-INFO*)
; compiling (DEFSTRUCT AA-FUNCTION ...)
; compiling (DEFSTRUCT AA-RELATION ...)
; compiling (DEFUN AA-FUNCTION ...)
; compiling (DEFUN AA-RELATION ...)
; compiling (DEFUN PRINT-ASSERTION-ANALYSIS-NOTE ...)
; compiling (DEFUN NOTE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN NOTE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN NOTE-FUNCTION-LEFT-IDENTITY ...)
; compiling (DEFUN NOTE-FUNCTION-RIGHT-IDENTITY ...)
; compiling (DEFUN NOTE-FUNCTION-LEFT-INVERSE ...)
; compiling (DEFUN NOTE-FUNCTION-RIGHT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-ASSOC1 ...)
; compiling (DEFUN NOTE-RELATION-ASSOC2 ...)
; compiling (DEFUN NOTE-RELATION-COMMUTATIVE ...)
; compiling (DEFUN NOTE-RELATION-LEFT-IDENTITY ...)
; compiling (DEFUN NOTE-RELATION-RIGHT-IDENTITY ...)
; compiling (DEFUN NOTE-RELATION-LEFT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-RIGHT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-FUNCTIONAL ...)
; compiling (DEFUN NOTE-RELATION-CLOSURE ...)
; compiling (DEFUN FUNCTION-ASSOCIATIVITY-TESTS ...)
; compiling (DEFUN FUNCTION-COMMUTATIVITY-TESTS ...)
; compiling (DEFUN FUNCTION-IDENTITY-TESTS ...)
; compiling (DEFUN FUNCTION-INVERSE-TESTS ...)
; compiling (DEFUN RELATION-ASSOCIATIVITY-TESTS ...)
; compiling (DEFUN RELATION-COMMUTATIVITY-TESTS ...)
; compiling (DEFUN RELATION-IDENTITY-TESTS ...)
; compiling (DEFUN RELATION-INVERSE-TESTS ...)
; compiling (DEFUN RELATION-FUNCTIONALITY-TESTS ...)
; compiling (DEFUN RELATION-CLOSURE-TESTS ...)
; compiling (DEFUN INITIALIZE-ASSERTION-ANALYSIS ...)
; compiling (DEFUN ASSERTION-ANALYSIS ...)
; compiling (DEFUN MAYBE-DECLARE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-RELATION-COMMUTATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-FUNCTION-IDENTITY ...)
; compiling (DEFUN AA-RELATION-ASSOCIATIVE ...)
; compiling (DEFUN COMPLETE-ASSERTION-ANALYSIS ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFUN |ATOM-REL#| ...)
; compiling (DEFUN PURITY-TEST ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.fasl written
; compilation finished in 0:00:00.156
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations-tables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFPARAMETER $RCC8-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-II-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-PP-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-PI-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-IP-RELATION-CODE ...)
; compiling (DEFPARAMETER $RCC8-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-III-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PPP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PII-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PPI-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PIP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IPI-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IIP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IPP-COMPOSITION-TABLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations-tables.fasl written
; compilation finished in 0:00:00.005
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLARE-SNARK-OPTION RCC8-REGION-SORT-NAME ...)
; compiling (DECLARE-SNARK-OPTION TIME-INTERVAL-SORT-NAME ...)
; compiling (DECLARE-SNARK-OPTION TIME-POINT-SORT-NAME ...)
; compiling (DEFPARAMETER RCC8-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER RCC8-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-II-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-II-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PP-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PP-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PI-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PI-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-IP-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-IP-MORE-RELATION-NAMES ...)
; compiling (DEFUN JEPD-RELATION-INPUT-FUNCTION ...)
; compiling (DEFUN 1-OR-?S ...)
; compiling (DEFUN 1S-COUNT ...)
; compiling (DEFUN 1-INDEXES ...)
; compiling (DEFUN JEPD-RELATION-COMPOSITION-REWRITER ...)
; compiling (DEFUN JEPD-RELATION-COMPOSITION-REWRITER1 ...)
; compiling (DEFUN REVERSEM ...)
; compiling (DEFUN XX-INTERSECTION ...)
; compiling (DEFUN JEPD-RELATION-INTERSECTION-REWRITER1 ...)
; compiling (DEFUN JEPD-RELATION-ATOM-WEIGHT ...)
; compiling (DEFUN DECLARE-JEPD-RELATION ...)
; compiling (DEFUN DECLARE-JEPD-RELATION-INPUT ...)
; compiling (DEFUN DECLARE-EQUALITY-JEPD-RELATION ...)
; compiling (DEFUN DECLARE-JEPD-RELATION-INTERSECTION ...)
; compiling (DEFUN DECLARE-JEPD-RELATIONS ...)
; compiling (DEFUN JEPD-RELATION-CODE ...)
; compiling (DEFUN MAKE-COMPOSITION-TABLE ...)
; compiling (DEFVAR *RCC8-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-III-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-IPI-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PII-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PIP-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PPI-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PPP-COMPOSITION-TABLE* ...)
; compiling (DEFUN FIRSTA ...)
; compiling (DEFUN RESTA ...)
; compiling (DEFUN DECLARE-RCC8-RELATIONS ...)
; compiling (DEFUN DECLARE-TIME-RELATIONS ...)
; compiling (DEFUN JEPD-ATOM-TO-LISP ...)
; compiling (DEFUN EQUAL-JEPD-RELATION-ATOM-ARGS-P ...)
; compiling (DEFUN VARIANT-JEPD-RELATION-ATOM-ARGS ...)
; compiling (DEFUN UNIFY-JEPD-RELATION-ATOM-ARGS ...)
; compiling (DEFUN JEPD-RELATION-ATOM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.fasl written
; compilation finished in 0:00:00.427
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *DATE-POINT*)
; compiling (DEFVAR *UTIME-POINT*)
; compiling (DEFVAR *DATE-INTERVAL*)
; compiling (DEFVAR *UTIME-INTERVAL*)
; compiling (DEFUN DECLARE-CODE-FOR-DATES ...)
; compiling (DEFUN CAN-BE-DATE-P ...)
; compiling (DEFUN ENCODE-UNIVERSAL-TIME-POINT ...)
; compiling (DEFUN DECODE-UNIVERSAL-TIME-POINT ...)
; compiling (DEFUN ENCODE-UNIVERSAL-TIME-INTERVAL ...)
; compiling (DEFUN DECODE-UNIVERSAL-TIME-INTERVAL ...)
; compiling (DEFUN PP-COMPARE-UNIVERSAL-TIMES ...)
; compiling (DEFUN II-COMPARE-UNIVERSAL-TIMES ...)
; compiling (DEFUN PI-COMPARE-UNIVERSAL-TIMES ...)
; compiling (DEFUN DECLARE-DATE-FUNCTIONS ...)
; compiling (DEFUN INPUT-DATE-POINT ...)
; compiling (DEFUN INPUT-DATE-INTERVAL ...)
; compiling (DEFUN UTIME-POINT-TERM-TO-LISP ...)
; compiling (DEFUN UTIME-INTERVAL-TERM-TO-LISP ...)
; compiling (DEFUN UTIME-POINT-TERM-P ...)
; compiling (DEFUN UTIME-INTERVAL-TERM-P ...)
; compiling (DEFUN TIME-II-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN TIME-PP-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN TIME-PI-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN DECLARE-UTIME-PP-COMPOSITION ...)
; compiling (DEFUN DECLARE-UTIME-PI-COMPOSITION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.fasl written
; compilation finished in 0:00:00.178
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *PROCESSING-ROW*))
; compiling (DEFGENERIC CHECKPOINT-THEORY ...)
; compiling (DEFGENERIC UNCHECKPOINT-THEORY ...)
; compiling (DEFGENERIC RESTORE-THEORY ...)
; compiling (DEFGENERIC THEORY-CLOSURE ...)
; compiling (DEFGENERIC THEORY-ASSERT ...)
; compiling (DEFGENERIC THEORY-DENY ...)
; compiling (DEFGENERIC THEORY-SIMPLIFY ...)
; compiling (DEFGENERIC THEORY-REWRITE ...)
; compiling (DEFUN THEORY-ASSERT2 ...)
; compiling (DEFUN THEORY-DENY2 ...)
; compiling (DEFUN THEORY-TRUEP ...)
; compiling (DEFUN THEORY-FALSEP ...)
; compiling (DEFUN SIMPLIFY-CONSTRAINT-ALIST ...)
; compiling (DEFUN REWRITE-CONSTRAINT-ALIST ...)
; compiling (DEFUN ASSUMPTIVE-CONSTRAINT-THEORY-P ...)
; compiling (DEFUN ROW-CONSTRAINED-P ...)
; compiling (DEFUN ROW-CONSTRAINED-P2 ...)
; compiling (DEFUN ROW-UNIT-CONSTRAINT ...)
; compiling (DEFUN ROW-CONSTRAINT-COVERAGE ...)
; compiling (DEFUN ROW-CONSTRAINT-COVERAGE* ...)
; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)
; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)
; compiling (DEFUN ASSUMPTION-TEST1 ...)
; compiling (DEFUN ASSUMPTION-TEST2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.fasl written
; compilation finished in 0:00:00.097
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN NOT-WFF-ERROR ...)
; compiling (DEFUN NOT-CLAUSE-ERROR ...)
; compiling (DEFUN HEAD-IS-LOGICAL-SYMBOL ...)
; compiling (DEFUN NEGATION-P ...)
; compiling (DEFUN CONJUNCTION-P ...)
; compiling (DEFUN DISJUNCTION-P ...)
; compiling (DEFUN IMPLICATION-P ...)
; compiling (DEFUN REVERSE-IMPLICATION-P ...)
; compiling (DEFUN EQUIVALENCE-P ...)
; compiling (DEFUN EXCLUSIVE-OR-P ...)
; compiling (DEFUN CONDITIONAL-P ...)
; compiling (DEFUN UNIVERSAL-QUANTIFICATION-P ...)
; compiling (DEFUN EXISTENTIAL-QUANTIFICATION-P ...)
; compiling (DEFUN ATOM-P ...)
; compiling (DEFUN LITERAL-P ...)
; compiling (DEFUN CLAUSE-P ...)
; compiling (DEFUN EQUALITY-RELATION-SYMBOL-P ...)
; compiling (DEFUN EQUALITY-P ...)
; compiling (DEFUN POSITIVE-EQUALITY-WFF-P ...)
; compiling (DECLARE-SNARK-OPTION ELIMINATE-NEGATIONS ...)
; compiling (DECLARE-SNARK-OPTION FLATTEN-CONNECTIVES ...)
; compiling (DECLARE-SNARK-OPTION EX-JOIN-NEGATION ...)
; compiling (DEFUN CONJOIN* ...)
; compiling (DEFUN DISJOIN* ...)
; compiling (DEFUN CONJOIN ...)
; compiling (DEFUN DISJOIN ...)
; compiling (DEFUN AO-JOIN* ...)
; compiling (DEFUN NOT-NOT-ELIMINATE ...)
; compiling (DEFUN MAKE-EQUIVALENCE* ...)
; compiling (DEFUN MAKE-EXCLUSIVE-OR* ...)
; compiling (DEFUN MAKE-EQUIVALENCE ...)
; compiling (DEFUN MAKE-EXCLUSIVE-OR ...)
; compiling (DEFUN EX-JOIN* ...)
; compiling (DEFUN NEGATE0 ...)
; compiling (DEFUN NEGATE* ...)
; compiling (DEFUN MAKE-IMPLICATION* ...)
; compiling (DEFUN MAKE-REVERSE-IMPLICATION* ...)
; compiling (DEFUN MAKE-CONDITIONAL* ...)
; compiling (DEFUN MAKE-CONDITIONAL-ANSWER* ...)
; compiling (DEFUN NEGATE ...)
; compiling (DEFUN RELATION-COMPLEMENTER ...)
; compiling (DEFUN PROPOSITION-COMPLEMENTER ...)
; compiling (DEFUN COMPLEMENT-NAME ...)
; compiling (DEFUN MAKE-IMPLICATION ...)
; compiling (DEFUN MAKE-REVERSE-IMPLICATION ...)
; compiling (DEFUN MAKE-CONDITIONAL ...)
; compiling (DEFUN MAKE-CONDITIONAL-ANSWER ...)
; compiling (DEFUN MAKE-EQUALITY0 ...)
; compiling (DEFUN MAKE-EQUALITY ...)
; compiling (DEFUN COMPLEMENT-P ...)
; compiling (DEFUN EQUAL-OR-COMPLEMENT-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.fasl written
; compilation finished in 0:00:00.164
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAP-ATOMS-IN-CLAUSE ...)
; compiling (DEFUN MAP-ATOMS-IN-WFF ...)
; compiling (DEFUN MAP-ATOMS-IN-WFF-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-WFF ...)
; compiling (DEFUN MAP-TERMS-IN-WFF-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-ATOM ...)
; compiling (DEFUN MAP-TERMS-IN-ATOM-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-TERM ...)
; compiling (DEFUN MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-LIST-OF-TERMS ...)
; compiling (DEFVAR MAP-ATOMS-FIRST ...)
; compiling (DEFUN MAP-ATOMS-IN-LIST-OF-WFFS ...)
; compiling (DEFUN MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-ATOMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-ATOMS-IN-ALIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-CONJUNCTS ...)
; compiling (DEFUN REPLACE-ATOM-IN-WFF ...)
; compiling (DEFUN ATOMS-IN-WFF ...)
; compiling (DEFUN ATOMS-IN-WFFS ...)
; compiling (DEFUN ATOMS-IN-WFF2 ...)
; compiling (DEFUN ATOMS-IN-CLAUSE2 ...)
; compiling (DEFUN ATOMS-TO-CLAUSE2 ...)
; compiling (DEFUN ATOMS-IN-CLAUSE3 ...)
; compiling (DEFUN ATOMS-TO-CLAUSE3 ...)
; compiling (DEFUN LITERALS-IN-CLAUSE ...)
; compiling (DEFUN LITERALS-TO-CLAUSE ...)
; compiling (DEFUN FIRST-NEGATIVE-LITERAL-IN-WFF ...)
; compiling (DEFUN FIRST-POSITIVE-LITERAL-IN-WFF ...)
; compiling (DEFUN DO-NOT-RESOLVE ...)
; compiling (DEFUN DO-NOT-FACTOR ...)
; compiling (DEFUN WFF-POSITIVE-OR-NEGATIVE ...)
; compiling (DEFUN ATOM-SATISFIES-SEQUENTIAL-RESTRICTION-P ...)
; compiling (DEFUN TERM-SATISFIES-SEQUENTIAL-RESTRICTION-P ...)
; compiling (DEFUN SALSIFY ...)
; compiling (DEFUN PROPOSITIONAL-CONTRADICTION-P ...)
; compiling (DEFUN PROPOSITIONAL-TAUTOLOGY-P ...)
; compiling (DEFUN FLATTEN-TERM ...)
; compiling (DEFUN FLATTEN-LIST ...)
; compiling (DEFUN UNFLATTEN-TERM1 ...)
; compiling (DEFUN UNFLATTEN-TERM ...)
; compiling (DEFUN FLATTEN-ARGS ...)
; compiling (DEFUN FN-CHAIN-TAIL ...)
; compiling (DEFUN FN-CHAIN-ITEMS ...)
; compiling (DEFUN MAKE-FN-CHAIN ...)
; compiling (DEFUN MAKE-COMPOUND1 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.fasl written
; compilation finished in 0:00:00.187
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/nonhorn-magic-set.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-MAGIC-GOAL-ATOM ...)
; compiling (DEFUN MAGIC-TRANSFORM-CLAUSE ...)
; compiling (DEFUN MAGIC-TRANSFORM-WFF ...)
; compiling (DEFUN PROPOSITION-MAGIC-GOAL-P ...)
; compiling (DEFUN RELATION-MAGIC-GOAL-P ...)
; compiling (DEFUN MAGIC-GOAL-ATOM-P ...)
; compiling (DEFUN MAGIC-GOAL-OCCURS-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/nonhorn-magic-set.fasl written
; compilation finished in 0:00:00.027
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL MAP-ATOMS-FIRST ...))
; compiling (DEFSTRUCT (CONTEXT # ...) ...)
; compiling (DEFUN MAKE-CONTEXT2 ...)
; compiling (DEFUN DP-REFUTE-P ...)
; compiling (DEFUN DP-REFUTE ...)
; compiling (DEFUN DP-REFUTE-TRACE ...)
; compiling (DEFUN CHOOSE-ATOM ...)
; compiling (DEFUN REFUTE-METHODS ...)
; compiling (DEFUN SIMPLIFY-FORMULA ...)
; compiling (DEFUN PRINT-CONTEXT ...)
; compiling (DEFUN DP-SUBSUME* ...)
; compiling (DEFUN DP-SUBSUME-CONSTRAINT-ALISTS* ...)
; compiling (DEFUN DP-SUBSUME ...)
; compiling (DEFUN DP-SUBSUME+ ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.fasl written
; compilation finished in 0:00:00.062
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN ASA-ARG-SORT ...)
; compiling (DEFUN INPUT-ARGUMENT-SORT-ALIST ...)
; compiling (DEFUN CAN-BE-ARGUMENT-SORT-ALIST-P1 ...)
; compiling (DEFUN CAN-BE-ARGUMENT-SORT-ALIST-P2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.fasl written
; compilation finished in 0:00:00.016
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TOP-SORT*)
; compiling (DEFINLINE TOP-SORT-NAME ...)
; compiling (DEFUN TOP-SORT-NAME? ...)
; compiling (DEFUN INITIALIZE-SORT-THEORY ...)
; compiling (DEFUN PRINT-SORT-THEORY ...)
; compiling (DEFINLINE TOP-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFINLINE TOP-SORT
;     (SNARK-LISP:DEFINLINE SNARK:TOP-SORT
;         NIL
;       SNARK::*TOP-SORT*)
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK:TOP-SORT
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK:TOP-SORT)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO SNARK:TOP-SORT
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK:TOP-SORT
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   6 calls to SNARK:TOP-SORT were compiled before a compiler-macro was defined for
;   it. A declaration of NOTINLINE at the call sites will eliminate this warning,
;   as will defining the compiler-macro before its first potential use.

; compiling (DEFINLINE SAME-SORT? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFINLINE SAME-SORT?
;     (SNARK-LISP:DEFINLINE SNARK::SAME-SORT?
;         (SNARK::X SNARK::Y)
;       (EQ SNARK::X SNARK::Y))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::SAME-SORT?
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::SAME-SORT?)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::SAME-SORT?
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::SAME-SORT?
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   2 calls to SNARK::SAME-SORT? were compiled before a compiler-macro was defined
;   for it. A declaration of NOTINLINE at the call sites will eliminate this
;   warning, as will defining the compiler-macro before its first potential use.

; compiling (DEFINLINE TOP-SORT? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFINLINE TOP-SORT?
;     (SNARK-LISP:DEFINLINE SNARK::TOP-SORT?
;         (SNARK::X)
;       (SNARK::SAME-SORT? (SNARK:TOP-SORT) SNARK::X))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::TOP-SORT?
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::TOP-SORT?)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO SNARK::TOP-SORT?
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::TOP-SORT?
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   4 calls to SNARK::TOP-SORT? were compiled before a compiler-macro was defined
;   for it. A declaration of NOTINLINE at the call sites will eliminate this
;   warning, as will defining the compiler-macro before its first potential use.

; compiling (DEFUN SUBSORT0 ...)
; compiling (DEFINLINE SUBSORT? ...)
; compiling (DEFINLINE SUBSORT1? ...)
; compiling (DEFUN SORT-INTERSECTION0 ...)
; compiling (DEFINLINE SORT-INTERSECTION ...)
; compiling (DEFINLINE SORT-DISJOINT? ...)
; compiling (DEFUN SORT? ...)
; compiling (DEFUN SORT-NAME ...)
; compiling (DEFUN SORT-NAME? ...)
; compiling (DEFUN SORT-NAME-EXPRESSION? ...)
; compiling (DEFUN FIX-SORT-NAME-EXPRESSION ...)
; compiling (DEFUN THE-SORT ...)
; compiling (DEFUN DECLARE-SORT1 ...)
; compiling (DEFUN DECLARE-SORT ...)
; compiling (DEFUN DECLARE-SUBSORT ...)
; compiling (DEFUN DECLARE-SORTS-INCOMPATIBLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.fasl written
; compilation finished in 0:00:00.055
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-THE-SORT-FUNCTION-SYMBOL ...)
; compiling (DEFUN DECLARE-CONSTANT-SORT ...)
; compiling (DEFUN DECLARE-FUNCTION-SORT ...)
; compiling (DEFVAR *%CHECK-FOR-WELL-SORTED-ATOM%* ...)
; compiling (DEFUN CHECK-FOR-WELL-SORTED-ATOM ...)
; compiling (DEFUN ASSERT-ATOM-IS-WELL-SORTED ...)
; compiling (DEFUN CHECK-WELL-SORTED ...)
; compiling (DEFVAR *%CHECKING-WELL-SORTED-P%* ...)
; compiling (DEFUN WELL-SORTED-P ...)
; compiling (DEFUN WELL-SORTED-ARGS-P ...)
; compiling (DEFUN TERM-SORT ...)
; compiling (DEFUN COMPOUND-SORT ...)
; compiling (DEFUN WELL-SORT ...)
; compiling (DEFUN WELL-SORT-ARGS ...)
; compiling (DEFUN WELL-SORT-ATOMS ...)
; compiling (DEFUN WELL-SORT-ATOMS1 ...)
; compiling (DEFUN WELL-SORT-WHICH-ATOMS ...)
; compiling (DEFUN WELL-SORT-WFF ...)
; compiling (DEFUN WELL-SORT-WFFS ...)
; compiling (DEFUN REPLACE-SKOLEM-TERMS-BY-VARIABLES-IN-ATOMS ...)
; compiling (DEFUN FIX-SKOLEM-TERM-SORTS ...)
; compiling (DEFINLINE CONSTANT-SORT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFINLINE CONSTANT-SORT-P
;     (SNARK-LISP:DEFINLINE SNARK::CONSTANT-SORT-P
;         (SNARK::CONSTANT SORT)
;       (OR (SNARK::TOP-SORT? SORT)
;           (SNARK::SUBSORT1? (SNARK:CONSTANT-SORT SNARK::CONSTANT) SORT)))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::CONSTANT-SORT-P
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::CONSTANT-SORT-P)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::CONSTANT-SORT-P
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::CONSTANT-SORT-P
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::CONSTANT-SORT-P was compiled before a compiler-macro was
;   defined for it. A declaration of NOTINLINE at the call site will eliminate this
;   warning, as will defining the compiler-macro before its first potential use.

; compiling (DEFINLINE VARIABLE-SORT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFINLINE VARIABLE-SORT-P
;     (SNARK-LISP:DEFINLINE SNARK::VARIABLE-SORT-P
;         (SNARK::VARIABLE SORT)
;       (OR (SNARK::TOP-SORT? SORT)
;           (SNARK::SUBSORT1? (SNARK:VARIABLE-SORT SNARK::VARIABLE) SORT)))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::VARIABLE-SORT-P
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::VARIABLE-SORT-P)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::VARIABLE-SORT-P
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::VARIABLE-SORT-P
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::VARIABLE-SORT-P was compiled before a compiler-macro was
;   defined for it. A declaration of NOTINLINE at the call site will eliminate this
;   warning, as will defining the compiler-macro before its first potential use.

; compiling (DEFUN TERM-SORT-P ...)
; compiling (DEFUN TERM-SUBSORT-P ...)
; compiling (DEFUN SORT-COMPATIBLE-P ...)
; compiling (DEFUN CHECK-ASSOCIATIVE-FUNCTION-SORT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.fasl written
; compilation finished in 0:00:00.278
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO INC-ARGUMENT-COUNT ...)
; compiling (DEFMACRO COUNT-ARGUMENT ...)
; compiling (DEFUN COUNT-ARGUMENTS ...)
; compiling (DEFUN RECOUNT-ARGUMENTS ...)
; compiling (DEFUN TERM-SIZE-DIFFERENCE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.fasl written
; compilation finished in 0:00:00.076
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN ARGUMENT-LIST-A1 ...)
; compiling (DEFUN ARGUMENT-COUNT-A1 ...)
; compiling (DEFUN SIMILAR-ARGUMENT-LIST-AC1-P ...)
; compiling (DEFUN FLATARGS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.fasl written
; compilation finished in 0:00:00.045
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING*))
; compiling (DEFVAR *UNIFY-SPECIAL* ...)
; compiling (DEFSTRUCT SPECIAL-UNIFICATION-PROBLEM ...)
; compiling (DEFUN UNIFY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp
; in: DEFUN UNIFY
;     (PSETQ SNARK::TERM1 SNARK::TERM2
;            SNARK::TERM2 SNARK::TERM1)
; --> LET* 
; ==>
;   SNARK::TERM2
; 
; note: deleting unreachable code

; ==>
;   SNARK::TERM1
; 
; note: deleting unreachable code

; compiling (DEFUN UNIFY-P ...)
; compiling (DEFUN MIGHT-UNIFY-P ...)
; compiling (DEFUN UNIFIERS ...)
; compiling (DEFUN UNIFY-SPECIAL ...)
; compiling (DEFUN COMMUTATIVE-UNIFY ...)
; compiling (DEFUN DONT-UNIFY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.fasl written
; compilation finished in 0:00:00.175
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBMULTISETP ...)
; compiling (DEFUN MULTISET-EQUAL ...)
; compiling (DEFVAR MAXX)
; compiling (DEFVAR MAXY)
; compiling (DEFMACRO CHECK-UNIFY-BAG-BASIS-SIZE ...)
; compiling (DEFMACRO A-COEF ...)
; compiling (DEFMACRO B-COEF ...)
; compiling (DEFMACRO X-TERM ...)
; compiling (DEFMACRO Y-TERM ...)
; compiling (DEFMACRO X-BIND ...)
; compiling (DEFMACRO Y-BIND ...)
; compiling (DEFMACRO XX-UNIFY-P ...)
; compiling (DEFMACRO YY-UNIFY-P ...)
; compiling (DEFMACRO XY-UNIFY-P ...)
; compiling (DEFMACRO X-TERM-GROUND-P ...)
; compiling (DEFMACRO Y-TERM-GROUND-P ...)
; compiling (DEFUN PRINT-UNIFY-BAG-BASIS ...)
; compiling (DEFUN UNIFY-BAG-BASIS ...)
; compiling (DECLARE-SNARK-OPTION USE-SUBSUME-BAG ...)
; compiling (DEFUN AC-UNIFY ...)
; compiling (DEFUN UNIFY-BAG ...)
; compiling (DEFUN UNIFY-BAG* ...)
; compiling (DEFUN SORT-TERMS-AND-COUNTS ...)
; compiling (DEFUN UNIFY-BAG0 ...)
; compiling (DEFMACRO NOSOL3X ...)
; compiling (DEFMACRO NOSOL3Y ...)
; compiling (DEFMACRO UNIFY-BAG2* ...)
; compiling (DEFUN UNIFY-BAG1 ...)
; compiling (DEFUN UNIFY-IDENTITY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.fasl written
; compilation finished in 0:00:00.705
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBSUME-BAG ...)
; compiling (DEFUN SUBSUME-BAG0 ...)
; compiling (DEFUN SUBSUME-BAG1 ...)
; compiling (DEFUN SUBSUME-BAG2 ...)
; compiling (DEFUN SUBSUME-BAG3 ...)
; compiling (DEFUN SUBSUME-BAG4 ...)
; compiling (DEFUN MAXTC1 ...)
; compiling (DEFUN COMPUTE-BOUNDS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.fasl written
; compilation finished in 0:00:00.108
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN FIRST-AND-REST-OF-VECTOR ...)
; compiling (DEFUN UNIFY-IDENTITY-WITH-VECTOR ...)
; compiling (DEFUN UNIFY-VARIABLE-WITH-VECTOR ...)
; compiling (DEFUN UNIFY-VARIABLE-WITH-VECTOR-MAX ...)
; compiling (DEFUN ASSOCIATIVE-UNIFY ...)
; compiling (DEFUN UNIFY-VECTOR ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.fasl written
; compilation finished in 0:00:00.033
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUAL-P ...)
; compiling (DEFUN AC-EQUAL-P ...)
; compiling (DEFUN COMMUTATIVE-EQUAL-P ...)
; compiling (DEFUN ASSOCIATIVE-EQUAL-P ...)
; compiling (DEFUN MEMBER-P ...)
; compiling (DEFUN ASSOC-P ...)
; compiling (DEFUN LITERAL-MEMBER-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.fasl written
; compilation finished in 0:00:00.038
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *EXTENDED-VARIANT* ...)
; compiling (DEFUN VARIANT ...)
; compiling (DEFUN VARIANTL ...)
; compiling (DEFUN VARIANT-P ...)
; compiling (DEFUN VARIANT-BAG ...)
; compiling (DEFUN VARIANT-BAG0 ...)
; compiling (DEFUN VARIANT-BAG* ...)
; compiling (DEFUN VARIANT-COMMUTE ...)
; compiling (DEFUN VARIANT-VECTOR ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.fasl written
; compilation finished in 0:00:00.049
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUAL-ALIST-P ...)
; compiling (DEFUN CONJOIN-ALISTS ...)
; compiling (DEFUN CONJOIN-ALIST1 ...)
; compiling (DEFUN DISJOIN-ALISTS ...)
; compiling (DEFUN DISJOIN-ALIST1 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.fasl written
; compilation finished in 0:00:00.030
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ATOM-HASH-CODE*)
; compiling (DEFVAR *TERM-BY-HASH-ARRAY*)
; compiling (DEFVAR *HASH-TERM-USES-VARIABLE-NUMBERS* ...)
; compiling (DEFVAR *HASH-TERM-ONLY-COMPUTES-CODE* ...)
; compiling (DEFVAR *HASH-TERM-NOT-FOUND-ACTION* ...)
; compiling (DEFUN INITIALIZE-TERM-HASH ...)
; compiling (DEFUN MAKE-ATOM-HASH-CODE ...)
; compiling (DEFUN FIND-TERM-BY-HASH ...)
; compiling (DEFUN TERM-BY-HASH-ARRAY-TERMS ...)
; compiling (DEFMACRO THVALUES ...)
; compiling (DEFUN HASH-TERM* ...)
; compiling (DEFUN HASH-TERM-CODE ...)
; compiling (DEFUN HASH-TERM ...)
; compiling (DEFUN SOME-HASH-TERM ...)
; compiling (DEFUN THE-HASH-TERM ...)
; compiling (DEFUN HASH-LIST ...)
; compiling (DEFUN HASH-COMPOUND ...)
; compiling (DEFUN PRINT-TERM-HASH ...)
; compiling (DEFVAR *DEFAULT-HASH-TERM-SET-COUNT-DOWN-TO-HASHING* ...)
; compiling (DEFSTRUCT (HASH-TERM-SET # ...) ...)
; compiling (DEFUN HTS-MEMBER-P ...)
; compiling (DEFUN HTS-ADJOIN-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.fasl written
; compilation finished in 0:00:00.072
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TRIE-INDEX*)
; compiling (DEFSTRUCT (TRIE-INDEX # ...) ...)
; compiling (DEFSTRUCT (TRIE-INDEX-INTERNAL-NODE #) ...)
; compiling (DEFSTRUCT (TRIE-INDEX-LEAF-NODE # ...))
; compiling (DEFMACRO TRIE-INDEX-LEAF-NODE-ENTRIES ...)
; compiling (DEFSTRUCT (INDEX-ENTRY # ...) ...)
; compiling (DEFUN MAKE-TRIE-INDEX ...)
; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE ...)
; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE ...)
; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-LOOKUP-ARGS ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-ARGS ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-ARITY ...)
; compiling (DEFUN SIMPLY-INDEXED-P ...)
; compiling (DEFINLINE TRIE-INDEX-BUILD-PATH-FOR-TERMS ...)
; compiling (DEFUN TRIE-INDEX-BUILD-PATH-FOR-TERM ...)
; compiling (DEFINLINE TRIE-INDEX-PATH-FOR-TERMS ...)
; compiling (DEFUN TRIE-INDEX-PATH-FOR-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN TRIE-INDEX-PATH-FOR-TERM
;     (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;      SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;      SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFUN TRIE-INDEX-INSERT ...)
; compiling (DEFUN TRIE-INDEX-DELETE ...)
; compiling (DEFMACRO MAP-TRIE-INDEX-ENTRIES ...)
; compiling (DEFUN MAP-TRIE-INDEX-INSTANCE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-INSTANCE-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFUN MAP-TRIE-INDEX-GENERALIZATION-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-GENERALIZATION-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF SNARK::SKIP-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFUN MAP-TRIE-INDEX-UNIFIABLE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-UNIFIABLE-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFUN MAP-TRIE-INDEX-VARIANT-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-VARIANT-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF SNARK::SKIP-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFUN MAP-TRIE-INDEX-ALL-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-ALL-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-ALL-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-ALL-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> PROGN SNARK-LISP:PROG-> BLOCK SNARK::MAP-FOR-TERM 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> COND THE PROGN SNARK-LISP:PROG-> BLOCK FLET SNARK::MAP-FOR-TERM 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF PROGN COND IF PROGN 
; --> SNARK-LISP:PROG-> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY SNARK-LISP::UNNAMED-PROG-> SNARK::MAP-FOR-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF PROGN COND IF COND THE 
; --> PROGN SNARK-LISP:PROG-> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET SNARK::MAP-FOR-TERMS 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFINLINE MAP-TRIE-INDEX ...)
; compiling (DEFUN PRINT-TRIE-INDEX ...)
; compiling (DEFUN PRINT-INDEX* ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T TRIE-INDEX-INTERNAL-NODE T)
;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;        SNARK::->NONNIL SNARK::NODE)
;       (SNARK::MAP-INDEX-LEAF-NODES SNARK::NODE (CONS 'SNARK:? SNARK::REVPATH)
;        SNARK::->* SNARK::NODE SNARK::REVPATH)
;       (FUNCALL SNARK::CC SNARK::NODE SNARK::REVPATH))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; compiling (DEFMETHOD PRINT-INDEX-LEAF-NODE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.fasl written
; compilation finished in 0:00:00.604
WARNING: Implicitly creating new generic function SNARK::MAP-INDEX-LEAF-NODES.
WARNING: Implicitly creating new generic function SNARK::PRINT-INDEX-LEAF-NODE.
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *TERPRI-INDENT*))
; compiling (DEFVAR *PATH-INDEX*)
; compiling (DEFSTRUCT (PATH-INDEX # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-NODE #) ...)
; compiling (DEFSTRUCT (PATH-INDEX-INTERNAL-NODE1 # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-INTERNAL-NODE2 # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-LEAF-NODE # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-ENTRY # ...) ...)
; compiling (DEFUN MAKE-PATH-INDEX ...)
; compiling (DEFMACRO PATH-INDEX-INTERNAL-NODE1-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO ADD-PATH-INDEX-INTERNAL-NODE1-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO ADD-PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE ...)
; compiling (DEFUN PATH-INDEX-ENTRY ...)
; compiling (DEFUN THE-PATH-INDEX-ENTRY ...)
; compiling (DEFUN SOME-PATH-INDEX-ENTRY ...)
; compiling (DEFUN PATH-INDEX-DELETE ...)
; compiling (DEFUN PATH-INDEX-DELETE-LEAF-NODE ...)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY*)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY-LEAF-NODES*)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY-INTERNAL-NODES*)
; compiling (DEFUN PATH-INDEX-INSERT ...)
; compiling (DEFUN PATH-INDEX-INSERT* ...)
; compiling (DEFUN PATH-INDEX-INSERT-APPL ...)
; compiling (DEFUN PATH-INDEX-INSERT-LIST ...)
; compiling (DEFUN PATH-INDEX-INSERT-LIST1 ...)
; compiling (DEFUN PATH-INDEX-INSERT-AT-LEAF ...)
; compiling (DEFUN NO-INTEGER-INDEXED-CHILD-NODES-P ...)
; compiling (DEFUN C-INDEX ...)
; compiling (DEFMACRO PATH-INDEX-VARIABLE-LEAF ...)
; compiling (DEFMACRO PATH-INDEX-CONSTANT-LEAF ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-V ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-I ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-G ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-U ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-APPL ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-LIST ...)
; compiling (DEFMACRO MAP-LEAF0 ...)
; compiling (DEFMACRO MAP-LEAF ...)
; compiling (DEFUN MAP-PATH-INDEX-ENTRIES ...)
; compiling (DEFUN MAP-PATH-INDEX-BY-QUERY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAP-PATH-INDEX-BY-QUERY
;     (FIRST SNARK::QUERY)
; --> CAR 
; ==>
;   SNARK::QUERY
; 
; note: deleting unreachable code

; compiling (DEFMACRO MARK-PATH-INDEX-ENTRY-IN-NODES ...)
; compiling (DEFMACRO MEMBER-PATH-INDEX-ENTRY-IN-NODES ...)
; compiling (DEFUN PATH-INDEX-ENTRY-SATISFIES-QUERY-P ...)
; compiling (DEFUN PATH-INDEX-ENTRY-SATISFIES-QUERY-P* ...)
; compiling (DEFUN RETRIEVAL-SIZE ...)
; compiling (DEFUN SELECT-QUERY ...)
; compiling (DEFUN MAKE-BOOLEAN-QUERY* ...)
; compiling (DEFUN MAKE-BOOLEAN-QUERY ...)
; compiling (DEFUN MAKE-UNIOND-QUERY2 ...)
; compiling (DEFUN NODUP-APPEND ...)
; compiling (DEFUN PATH-INDEX-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFUN FIX-PATH-INDEX-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-DESCRIPTION ...)
; compiling (DEFUN SZ ...)
; compiling (DEFUN TRACED-OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFUN PRINT-PATH-INDEX ...)
; compiling (DEFMETHOD PRINT-INDEX-LEAF-NODE ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; compiling (DEFUN PRINT-REVPATH ...)
; compiling (DEFUN PATH-INDEX-KEY-FOR-VALUE ...)
; compiling (DEFUN PATH-INDEX-NODE-REVPATH ...)
; compiling (DEFUN PRINT-PATH-INDEX-QUERY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.fasl written
; compilation finished in 0:00:00.569
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO MAKE-TRIE-NODE ...)
; compiling (DEFMACRO TRIE-NODE-DATA ...)
; compiling (DEFMACRO TRIE-NODE-BRANCHES ...)
; compiling (DEFSTRUCT (TRIE #) ...)
; compiling (DEFUN TRIEREF ...)
; compiling (DEFUN (SETF TRIEREF) ...)
; compiling (DEFUN TRIE-SIZE ...)
; compiling (DEFUN MAP-TRIE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.fasl written
; compilation finished in 0:00:00.031
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFCONSTANT $FV-MAXIMUM-FEATURE-VALUE ...)
; compiling (DEFCONSTANT $FV-FEATURES-PER-SYMBOL ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-COUNT ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-COUNT ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-MAX-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-MAX-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-MIN-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-MIN-DEPTH ...)
; compiling (DEFCONSTANT $FV-NUMBER-GROUND ...)
; compiling (DECLARE-SNARK-OPTION FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING ...)
; compiling (DEFUN NEW-FEATURE-VECTOR ...)
; compiling (DEFUN FEATURE-VECTOR-LIST ...)
; compiling (DEFUN UPDATE-FEATURE-VECTOR ...)
; compiling (DEFUN CLAUSE-FEATURE-VECTOR ...)
; compiling (DEFUN ATOM-OR-TERM-FEATURE-VECTOR ...)
; compiling (DEFUN ATOM-FEATURE-VECTOR ...)
; compiling (DEFUN TERM-FEATURE-VECTOR ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.fasl written
; compilation finished in 0:00:00.055
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFINLINE FV-TRIE-KEY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFINLINE FV-TRIE-KEY
;     (SNARK-LISP:DEFINLINE SNARK::FV-TRIE-KEY
;         (SNARK::FEATURE-NUMBER SNARK::FEATURE-VALUE)
;       (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
;          SNARK::FEATURE-VALUE))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::FV-TRIE-KEY
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::FV-TRIE-KEY)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::FV-TRIE-KEY
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::FV-TRIE-KEY
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::FV-TRIE-KEY was compiled before a compiler-macro was defined
;   for it. A declaration of NOTINLINE at the call site will eliminate this
;   warning, as will defining the compiler-macro before its first potential use.

; compiling (DEFINLINE FV-TRIE-KEY-FEATURE ...)
; compiling (DEFINLINE FV-TRIE-KEY-VALUE ...)
; compiling (DEFUN MAP-FV-TRIE<= ...)
; compiling (DEFUN MAP-FV-TRIE>= ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.fasl written
; compilation finished in 0:00:00.024
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *FEATURE-VECTOR-ROW-INDEX*)
; compiling (DEFVAR *FEATURE-VECTOR-TERM-INDEX*)
; compiling (DEFSTRUCT (FEATURE-VECTOR-INDEX # ...) ...)
; compiling (DEFUN MAKE-FEATURE-VECTOR-ROW-INDEX ...)
; compiling (DEFUN MAKE-FEATURE-VECTOR-TERM-INDEX ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-ENTRY-NUMBER ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-ENTRY-KEYS ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-INSERT ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-DELETE ...)
; compiling (DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-FORWARD-SUBSUMPTION-CANDIDATES ...)
; compiling (DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-BACKWARD-SUBSUMPTION-CANDIDATES ...)
; compiling (DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-GENERALIZATIONS ...)
; compiling (DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-INSTANCES ...)
; compiling (DEFUN PRINT-FEATURE-VECTOR-INDEX1 ...)
; compiling (DEFUN PRINT-FEATURE-VECTOR-ROW-INDEX ...)
; compiling (DEFUN PRINT-FEATURE-VECTOR-TERM-INDEX ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.fasl written
; compilation finished in 0:00:00.082
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TERM-MEMORY*)
; compiling (DEFSTRUCT (TERM-MEMORY-ENTRY # ...) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFSTRUCT TERM-MEMORY-ENTRY
;     (DEFSTRUCT
;         (SNARK::TERM-MEMORY-ENTRY (:INCLUDE SNARK::PATH-INDEX-ENTRY)
;          (:CONC-NAME :TME-) (:COPIER NIL))
;       (NUMBER (SNARK-NUMBERING:NONCE) :READ-ONLY T)
;       (SNARK::ROWS-CONTAINING-ATOM-POSITIVELY NIL)
;       (SNARK::ROWS-CONTAINING-ATOM-NEGATIVELY NIL)
;       (SNARK::ROWS-CONTAINING-PARAMODULATABLE-EQUALITY NIL)
;       (SNARK::ROWS-CONTAINING-TERM NIL)
;       (SNARK::REWRITES NIL)
;       SNARK::SIZE
;       SNARK::DEPTH
;       SNARK::MINDEPTH)
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-KERNEL::%COMPILER-DEFSTRUCT
;    '#<SB-KERNEL:DEFSTRUCT-DESCRIPTION SNARK::TERM-MEMORY-ENTRY {1007A55B33}>
;    '#(#<SB-KERNEL:LAYOUT for T {1000099793}>
;       #<SB-KERNEL:LAYOUT for STRUCTURE-OBJECT {1000099813}>
;       #<SB-KERNEL:LAYOUT for SNARK::INDEX-ENTRY {10039B3653}>
;       #<SB-KERNEL:LAYOUT for SNARK::PATH-INDEX-ENTRY {1004D0F383}>))
; 
; caught STYLE-WARNING:
;   Previously compiled call to SNARK::TME-NUMBER could not be inlined because the
;   structure definition for SNARK::TERM-MEMORY-ENTRY was not yet seen. To avoid
;   this warning, DEFSTRUCT should precede references to the affected functions, or
;   they must be declared locally notinline at each call site.

; compiling (DEFSTRUCT (TERM-MEMORY # ...) ...)
; compiling (DEFUN MAKE-TERM-MEMORY-ENTRY1 ...)
; compiling (DEFUN MAKE-TERM-MEMORY ...)
; compiling (DEFUN TERM-MEMORY-ENTRY ...)
; compiling (DEFUN SOME-TERM-MEMORY-ENTRY ...)
; compiling (DEFUN THE-TERM-MEMORY-ENTRY ...)
; compiling (DEFUN TM-STORE ...)
; compiling (DEFUN TM-REMOVE-ENTRY ...)
; compiling (DEFUN RETRIEVE-GENERALIZATION-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-GENERALIZATION-ENTRIES
;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :GENERALIZATION SNARK::TERM SUBST SNARK::->*
;                              SNARK::ENTRY)
;       (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :GENERALIZATION SNARK::TERM SUBST SNARK::->*
;                              SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; compiling (DEFUN RETRIEVE-INSTANCE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-INSTANCE-ENTRIES
;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :INSTANCE SNARK::TERM SUBST SNARK::->* SNARK::ENTRY)
;       (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :INSTANCE SNARK::TERM SUBST SNARK::->* SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; compiling (DEFUN RETRIEVE-UNIFIABLE-ENTRIES ...)
; compiling (DEFUN RETRIEVE-RESOLVABLE-ENTRIES ...)
; compiling (DEFUN RETRIEVE-PARAMODULATABLE-ENTRIES ...)
; compiling (DEFUN RETRIEVE-VARIANT-ENTRIES ...)
; compiling (DEFUN RETRIEVE-ALL-ENTRIES ...)
; compiling (DEFUN PRINT-TERM-MEMORY ...)
; compiling (DEFUN TME-USELESS-P ...)
; compiling (DEFMACRO ROWS-CONTAINING-ATOM-POSITIVELY ...)
; compiling (DEFMACRO ROWS-CONTAINING-ATOM-NEGATIVELY ...)
; compiling (DEFMACRO ROWS-CONTAINING-PARAMODULATABLE-EQUALITY ...)
; compiling (DEFMACRO ROWS-CONTAINING-TERM ...)
; compiling (DEFMACRO REWRITES ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-TERM ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-ATOM-POSITIVELY ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-ATOM-NEGATIVELY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.fasl written
; compilation finished in 0:00:00.152
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DEPTH ...)
; compiling (DEFUN MINDEPTH ...)
; compiling (DEFINLINE CONSTANTLY-ONE ...)
; compiling (DEFINLINE CONSTANTLY-NIL ...)
; compiling (DEFINLINE VARIABLE-WEIGHT1 ...)
; compiling (DEFMACRO WEIGHT-MACRO ...)
; compiling (DEFUN WEIGHT ...)
; compiling (DEFUN SIZE ...)
; compiling (DEFUN WEIGH-FIRST-TWO-ARGUMENTS ...)
; compiling (DEFUN MAXIMUM-ARGUMENT-WEIGHT ...)
; compiling (DEFUN WEIGHTM ...)
; compiling (DEFSTRUCT (SYMBOL-COUNT # ...) ...)
; compiling (DEFUN SYMBOL-COUNT ...)
; compiling (DEFINLINE SYMBOL-COUNT-NOT-GREATERP1 ...)
; compiling (DEFUN SYMBOL-COUNT-NOT-GREATERP ...)
; compiling (DEFUN WFF-SYMBOL-COUNTS ...)
; compiling (DEFUN WFF-SYMBOL-COUNTS-NOT-GREATERP ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.fasl written
; compilation finished in 0:00:00.223
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *POLARITY*)
; compiling (DEFUN FIFO ...)
; compiling (DEFUN LIFO ...)
; compiling (DEFUN ROW-DEPTH ...)
; compiling (DEFUN ROW-SIZE ...)
; compiling (DEFUN ROW-WEIGHT ...)
; compiling (DEFUN ROW-SIZE+DEPTH ...)
; compiling (DEFUN ROW-WEIGHT+DEPTH ...)
; compiling (DEFUN ROW-SIZE+DEPTH+LEVEL ...)
; compiling (DEFUN ROW-WEIGHT+DEPTH+LEVEL ...)
; compiling (DEFUN ROW-PRIORITY ...)
; compiling (DEFUN ROW-WFF&ANSWER-WEIGHT+DEPTH ...)
; compiling (DEFUN ROW-NEG ...)
; compiling (DEFUN ROW-NEG-SIZE+DEPTH ...)
; compiling (DEFUN ROW-ANSWER-WEIGHT ...)
; compiling (DEFUN WFF-DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-DEPTH
;     (DEFUN SNARK::WFF-DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::DEPTH ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (SNARK::DEPTH ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-SIZE
;     (DEFUN SNARK::WFF-SIZE
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::SIZE ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-SIZE
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-SIZE
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (SNARK::SIZE ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-WEIGHT
;     (DEFUN SNARK::WFF-WEIGHT
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::WEIGHT ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-WEIGHT
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-WEIGHT
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (SNARK::WEIGHT ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-SIZE+DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-SIZE+DEPTH
;     (DEFUN SNARK::WFF-SIZE+DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (+ (SNARK::SIZE ATOM SUBST) (SNARK::DEPTH ATOM SUBST))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-SIZE+DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-SIZE+DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (+ (SNARK::SIZE ATOM SUBST) (SNARK::DEPTH ATOM SUBST)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-WEIGHT+DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-WEIGHT+DEPTH
;     (DEFUN SNARK::WFF-WEIGHT+DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (+ (SNARK::WEIGHT ATOM SUBST) (SNARK::DEPTH ATOM SUBST))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-WEIGHT+DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-WEIGHT+DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (+ (SNARK::WEIGHT ATOM SUBST) (SNARK::DEPTH ATOM SUBST)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-LENGTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-LENGTH
;     (DEFUN SNARK::WFF-LENGTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (DECLARE (IGNORE ATOM SUBST))
;         1))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-LENGTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-LENGTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;            SUBST)
;           (DECLARE (IGNORE ATOM SUBST))
;           1)))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY
;                                                      (POLARITY :POS))

; compiling (DEFUN WFF-SIZE* ...)
; compiling (DEFUN WFF-NEG ...)
; compiling (DEFUN ROW-ARGUMENT-COUNT-LIMIT-EXCEEDED ...)
; compiling (DEFUN ROW-WEIGHT-LIMIT-EXCEEDED ...)
; compiling (DEFUN ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT-EXCEEDED ...)
; compiling (DEFUN ROW-PROOF-LENGTH-LIMIT-EXCEEDED ...)
; compiling (DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS ...)
; compiling (DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS-NEG ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.fasl written
; compilation finished in 0:00:00.172
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SKOLEM-FUNCTION-ALIST* ...)
; compiling (DEFVAR *INPUT-WFF* ...)
; compiling (DEFVAR *INPUT-WFF-SUBSTITUTION*)
; compiling (DEFVAR *INPUT-WFF-SUBSTITUTION2*)
; compiling (DEFVAR *INPUT-WFF-NEW-ANTECEDENTS*)
; compiling (DEFVAR *INPUT-WFF-MODAL-PREFIX*)
; compiling (DEFVAR *INPUT-PROPOSITION-VARIABLES* ...)
; compiling (DEFUN KEYWORD-ARGUMENT-LIST-P ...)
; compiling (DEFUN CAN-BE-NAME1 ...)
; compiling (DEFUN CAN-BE-FREE-VARIABLE-NAME ...)
; compiling (DEFUN CAN-BE-VARIABLE-NAME ...)
; compiling (DEFUN CAN-BE-CONSTANT-NAME ...)
; compiling (DEFUN CAN-BE-CONSTANT-ALIAS ...)
; compiling (DEFUN CAN-BE-PROPOSITION-NAME ...)
; compiling (DEFUN CAN-BE-FUNCTION-NAME ...)
; compiling (DEFUN CAN-BE-RELATION-NAME ...)
; compiling (DEFUN CAN-BE-LOGICAL-SYMBOL-NAME ...)
; compiling (DEFUN CAN-BE-SORT-NAME ...)
; compiling (DEFUN CAN-BE-ROW-NAME ...)
; compiling (DEFUN CAN-BE-CONSTANT-OR-FUNCTION-NAME ...)
; compiling (DEFUN CHECK-USABLE-HEAD1 ...)
; compiling (DEFUN CERROR1 ...)
; compiling (DEFUN CERROR2 ...)
; compiling (DEFUN VARIABLE-SYMBOL-PREFIXED-P ...)
; compiling (DEFUN UNSORTABLE-VARIABLE-NAME ...)
; compiling (DEFUN SORT-FROM-VARIABLE-NAME ...)
; compiling (DEFUN DECLARE-VARIABLE ...)
; compiling (DEFUN INPUT-WFF ...)
; compiling (DEFUN INPUT-WFF1 ...)
; compiling (DEFUN INPUT-WFFS1 ...)
; compiling (DEFUN INPUT-WFFS2 ...)
; compiling (DEFUN INPUT-QUOTED-CONSTANT ...)
; compiling (DEFUN INPUT-EQUALITY ...)
; compiling (DEFUN INPUT-DISEQUALITY ...)
; compiling (DEFUN INPUT-NEGATION ...)
; compiling (DEFUN INPUT-CONJUNCTION ...)
; compiling (DEFUN INPUT-DISJUNCTION ...)
; compiling (DEFUN INPUT-IMPLICATION ...)
; compiling (DEFUN INPUT-REVERSE-IMPLICATION ...)
; compiling (DEFUN INPUT-KIF-FORWARD-IMPLICATION ...)
; compiling (DEFUN INPUT-KIF-BACKWARD-IMPLICATION ...)
; compiling (DEFUN INPUT-NAND ...)
; compiling (DEFUN INPUT-NOR ...)
; compiling (DEFUN INPUT-LISP-LIST ...)
; compiling (DEFUN INPUT-LISP-LIST* ...)
; compiling (DEFUN INPUT-FUNCTION-AS-RELATION-RESULT-SORT2 ...)
; compiling (DEFUN INPUT-FUNCTION-AS-RELATION-RESULT-SORT ...)
; compiling (DEFUN INPUT-FUNCTION-AS-RELATION ...)
; compiling (DEFUN INPUT-FLOAT-FUNCTION-AS-RELATION ...)
; compiling (DEFUN INPUT-RELATION-AS-FUNCTION ...)
; compiling (DEFUN INPUT-EQUIVALENCE ...)
; compiling (DEFUN INPUT-EXCLUSIVE-OR ...)
; compiling (DEFUN INPUT-CONDITIONAL ...)
; compiling (DEFUN INPUT-CONDITIONAL-ANSWER ...)
; compiling (DEFUN INPUT-QUANTIFICATION ...)
; compiling (DEFUN INPUT-QUANTIFIER-VARIABLE ...)
; compiling (DEFUN MAKE-VARIABLE-FROM-VAR-SPEC ...)
; compiling (DEFUN INPUT-QUANTIFIER-VARIABLES ...)
; compiling (DEFUN INPUT-VARIABLES-IN-FORM ...)
; compiling (DEFUN CREATE-SKOLEM-TERM ...)
; compiling (DEFUN CREATE-SKOLEM-SYMBOL ...)
; compiling (DEFVAR *NEW-SYMBOL-PREFIX*)
; compiling (DEFVAR *NUMBER-OF-NEW-SYMBOLS*)
; compiling (DEFVAR *NEW-SYMBOL-TABLE*)
; compiling (DEFUN NEWSYM-PREFIX ...)
; compiling (DEFUN NEWSYM ...)
; compiling (DEFUN NEWSYM2 ...)
; compiling (DEFUN INPUT-FORM* ...)
; compiling (DEFUN INPUT-FORM ...)
; compiling (DEFUN INPUT-ATOM ...)
; compiling (DEFUN INPUT-TERM ...)
; compiling (DEFUN INPUT-TERM1 ...)
; compiling (DEFUN INPUT-TERMS ...)
; compiling (DEFUN MAP-POLARITY ...)
; compiling (DEFUN OPPOSITE-POLARITY ...)
; compiling (DEFUN INPUT-ATOM-WITH-KEYWORD-ARGUMENTS ...)
; compiling (DEFUN ATOM-WITH-KEYWORDS-INPUTTER ...)
; compiling (DEFUN CLAUSIFY ...)
; compiling (DEFUN REPORT-NOT-2-ARGUMENTS-QUANTIFICATION ...)
; compiling (DEFUN REPORT-NOT-2-ARGUMENTS-IMPLICATION ...)
; compiling (DEFUN REQUIRE-N-ARGUMENTS ...)
; compiling (DEFUN REQUIRE-N-OR-MORE-ARGUMENTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.fasl written
; compilation finished in 0:00:00.295
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO WITH-NO-OUTPUT ...)
; compiling (DEFUN PRINT-FUNCTION-SYMBOL ...)
; compiling (DEFUN PRINT-VARIABLE ...)
; compiling (DEFUN PRINT-TERM3 ...)
; compiling (DEFUN PRINT-TERM ...)
; compiling (DEFUN PRINT-ROW-TERM ...)
; compiling (DEFMETHOD PRINT-GIVEN-ROW ...)
; compiling (DEFMETHOD PRINT-DERIVED-ROW ...)
; compiling (DEFUN PRINT-PROCESSED-ROW ...)
; compiling (DEFUN PRINT-PURE-ROW ...)
; compiling (DEFVAR *PRINTING-DELETED-MESSAGES* ...)
; compiling (DEFUN PRINT-DELETED-WFF ...)
; compiling (DEFUN PRINT-UNORIENTABLE-WFF ...)
; compiling (DEFVAR *SZS-FILESPEC* ...)
; compiling (DEFVAR *SZS-CONJECTURE* ...)
; compiling (DEFUN PRINT-SZS-STATUS ...)
; compiling (DEFUN PRINT-SZS-ANSWERS-SHORT ...)
; compiling (DEFUN PRINT-FINAL-ROW ...)
; compiling (DEFUN REPLACE-ROWS-BY-NAME-OR-NUMBER ...)
; compiling (DEFUN PRINT-ROW-REASON ...)
; compiling (DEFUN PRINT-ROW3 ...)
; compiling (DEFUN PRINT-ROW-LENGTH-LIMIT1 ...)
; compiling (DEFUN PRINT-ROW ...)
; compiling (DEFVAR *PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP* ...)
; compiling (DEFUN TERM-TO-LISP ...)
; compiling (DEFUN CONS-TERM-TO-LISP ...)
; compiling (DEFUN QUANT-COMPOUND-TO-LISP ...)
; compiling (DEFUN ROW-SORTS ...)
; compiling (DEFUN DERIVATION-SORTS ...)
; compiling (DEFUN SUBSORT-FORMS ...)
; compiling (DEFUN DERIVATION-SUBSORT-FORMS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.fasl written
; compilation finished in 0:00:00.168
WARNING: Implicitly creating new generic function SNARK::PRINT-GIVEN-ROW.
WARNING: Implicitly creating new generic function SNARK::PRINT-DERIVED-ROW.
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *MANUAL-ORDERING-RESULTS* ...))
; compiling (DEFUN MANUAL-ORDERING-COMPARE-TERMS ...)
; compiling (DEFUN DEFINITION-P ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS0 ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS1 ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS ...)
; compiling (DEFVAR *SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS-HASH-TABLE*)
; compiling (DEFUN INITIALIZE-SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS-HASH-TABLE ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-GREATERP ...)
; compiling (DEFUN INSTANTIATING-DIRECTION1 ...)
; compiling (DEFUN INSTANTIATING-DIRECTION ...)
; compiling (DEFUN LITERAL-ORDERING-A ...)
; compiling (DEFUN LITERAL-ORDERING-P ...)
; compiling (DEFUN LITERAL-ORDERING-N ...)
; compiling (DEFUN LITERAL-IS-NOT-DOMINATED-IN-CLAUSE-P ...)
; compiling (DEFUN LITERAL-IS-NOT-DOMINATING-IN-CLAUSE-P ...)
; compiling (DEFUN LITERAL-SATISFIES-ORDERING-RESTRICTION-P ...)
; compiling (DEFUN SELECTED-ATOMS-IN-ROW ...)
; compiling (DEFUN SELECTED-ATOM-IN-ROW-P ...)
; compiling (DEFUN SELECTED-ATOM-P ...)
; compiling (DEFUN SELECTED-ATOMS-IN-HYPERRESOLUTION-ELECTRONS-P ...)
; compiling (DEFMETHOD THEORY-REWRITE ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.fasl written
; compilation finished in 0:00:00.127
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SYMBOLS-IN-SYMBOL-TABLE*))
; compiling (DEFVAR ORDERING-IS-TOTAL ...)
; compiling (DEFVAR *SYMBOL-ORDERING*)
; compiling (DEFUN INITIALIZE-SYMBOL-ORDERING ...)
; compiling (DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE ...)
; compiling (DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE1 ...)
; compiling (DEFUN DECLARE-ORDERING-GREATERP2 ...)
; compiling (DEFINLINE SYMBOL-ORDERING-COMPARE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFINLINE SYMBOL-ORDERING-COMPARE
;     (SNARK-LISP:DEFINLINE SNARK::SYMBOL-ORDERING-COMPARE
;         (SNARK::SYMBOL1 SNARK::SYMBOL2)
;       (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) '=)
;             (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2))))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::SYMBOL-ORDERING-COMPARE
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::SYMBOL-ORDERING-COMPARE)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::SYMBOL-ORDERING-COMPARE
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::SYMBOL-ORDERING-COMPARE
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::SYMBOL-ORDERING-COMPARE was compiled before a compiler-macro
;   was defined for it. A declaration of NOTINLINE at the call site will eliminate
;   this warning, as will defining the compiler-macro before its first potential
;   use.

; compiling (DEFUN SYMBOL-ORDERING-COMPARE1 ...)
; compiling (DEFUN OPPOSITE-ORDER ...)
; compiling (DEFUN PRINT-SYMBOL-ORDERING ...)
; compiling (DEFUN DECLARE-ORDERING-GREATERP ...)
; compiling (DEFUN RPO-ADD-CREATED-FUNCTION-SYMBOL ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.fasl written
; compilation finished in 0:00:00.107
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN COMPARE-MULTISETS ...)
; compiling (DEFUN COMPARE-TERM-MULTISETS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.fasl written
; compilation finished in 0:00:00.254
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *RPO-CACHE*)
; compiling (DEFVAR *RPO-CACHE-NUMBERING*)
; compiling (DEFVAR *AC-RPO-CACHE*)
; compiling (DEFUN RPO-COMPARE-TERMS-TOP ...)
; compiling (DEFUN RPO-CACHE-LOOKUP ...)
; compiling (DEFUN RPO-CACHE-STORE ...)
; compiling (DEFINLINE RPO-COMPARE-VARIABLE*COMPOUND ...)
; compiling (DEFINLINE RPO-COMPARE-COMPOUND*VARIABLE ...)
; compiling (DEFUN RPO-COMPARE-TERMS ...)
; compiling (DEFUN RPO-COMPARE-COMPOUND*CONSTANT ...)
; compiling (DEFUN RPO-COMPARE-CONSTANT*COMPOUND ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS0 ...)
; compiling (DEFUN RPO-COMPARE-LISTS ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS> ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS< ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS? ...)
; compiling (DEFUN THEREIS-RPO-EQUAL-OR-GREATERP ...)
; compiling (DEFUN RPO-COMPARE-ALISTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.fasl written
; compilation finished in 0:00:00.153
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN AC-RPO-COMPARE-COMPOUNDS ...)
; compiling (DEFUN AC-RPO-COMPARE-COMPOUNDS* ...)
; compiling (DEFUN EMB-NO-BIG ...)
; compiling (DEFUN BIG-HEAD-AND-NO-SMALL-HEAD ...)
; compiling (DEFUN COMPARE-NO-SMALL-HEADS ...)
; compiling (DEFUN COMPARE-ARGUMENT-COUNTS ...)
; compiling (DEFUN AC-RPO-CACHE-LOOKUP ...)
; compiling (DEFUN AC-RPO-CACHE-STORE ...)
; compiling (DEFUN EQL-LIST ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.fasl written
; compilation finished in 0:00:00.145
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFINLINE VARIABLE-KBO-WEIGHT ...)
; compiling (DEFUN KBO-EVALUATE-TERM ...)
; compiling (DEFUN KBO-EVALUATE-TERMS ...)
; compiling (DEFUN KBO-COMPARE-TERMS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.fasl written
; compilation finished in 0:00:00.117
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING* ...))
; compiling (DEFSTRUCT (REWRITE #) ...)
; compiling (DEFVAR *REDEX-PATH* ...)
; compiling (DEFUN REWRITE-PATTERNS-AND-VALUES ...)
; compiling (DEFVAR *REWRITES-USED*)
; compiling (DEFVAR REWRITE-STRATEGY ...)
; compiling (DEFVAR FULLY-REWRITTEN-COMPOUNDS)
; compiling (DEFUN REDEX-AT-TOP? ...)
; compiling (DEFUN REDEX-POLARITY ...)
; compiling (DEFUN SET-REDEX-POLARITY ...)
; compiling (DEFUN REDEX-LITERAL? ...)
; compiling (DEFUN REDEX-CLAUSE? ...)
; compiling (DEFUN REWRITER ...)
; compiling (DEFUN REWRITE-CONSTANT ...)
; compiling (DEFUN REWRITE-COMPOUND ...)
; compiling (DEFUN REWRITE-COMPOUND-BY-CODE ...)
; compiling (DEFUN DECLARE-CONSTANTS ...)
; compiling (DEFUN REWRITE-COMPOUND-BY-RULE ...)
; compiling (DEFUN REWRITE-LIST ...)
; compiling (DEFUN REWRITE-LIST-BY-RULE ...)
; compiling (DEFVAR *REWRITE-COUNT-WARNING* ...)
; compiling (DEFMACRO REWRITE-*MOST ...)
; compiling (DEFUN EQ-ARGS ...)
; compiling (DEFUN REWRITE-INNERMOST ...)
; compiling (DEFUN REWRITE-OUTERMOST ...)
; compiling (DEFUN REWRITE-LIST-INNERMOST ...)
; compiling (DEFUN REWRITE-LIST-OUTERMOST ...)
; compiling (DEFUN AC-INVERSE-RULE-P ...)
; compiling (DEFUN APPLY-AC-INVERSE-RULE ...)
; compiling (DEFUN APPLY-AC-INVERSE-RULE* ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.fasl written
; compilation finished in 0:00:00.159
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUALITY-REWRITER ...)
; compiling (DEFUN MAKE-CHARACTERISTIC-ATOM-REWRITER ...)
; compiling (DEFUN REFLEXIVITY-REWRITER ...)
; compiling (DEFUN IRREFLEXIVITY-REWRITER ...)
; compiling (DEFUN ASSOCIATIVE-IDENTITY-REWRITER ...)
; compiling (DEFUN ASSOCIATIVE-IDENTITY-PARAMODULATER ...)
; compiling (DEFUN NONVARIABLE-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN NONVARIABLE-REWRITER
;     (SNARK:DEREFERENCE SNARK::X SUBST :IF-VARIABLE SNARK-LISP:NONE :IF-CONSTANT
;                        SNARK-LISP:TRUE :IF-COMPOUND SNARK-LISP:TRUE)
; --> COND IF COND IF COND THE PROGN 
; ==>
;   SNARK-LISP:TRUE
; 
; note: deleting unreachable code

; compiling (DEFUN THE-TERM-REWRITER ...)
; compiling (DEFUN NOT-WFF-REWRITER ...)
; compiling (DEFUN AND-WFF-REWRITER ...)
; compiling (DEFUN OR-WFF-REWRITER ...)
; compiling (DEFUN IMPLIES-WFF-REWRITER ...)
; compiling (DEFUN IMPLIED-BY-WFF-REWRITER ...)
; compiling (DEFUN IMPLIES-WFF-REWRITER1 ...)
; compiling (DEFUN DISTRIBUTIVE-LAW1-P ...)
; compiling (DEFUN CANCEL1 ...)
; compiling (DEFUN MAKE-CANCEL ...)
; compiling (DEFUN DECLARE-CANCELLATION-LAW ...)
; compiling (DEFUN DISTRIBUTIVITY-REWRITER ...)
; compiling (DEFUN DECLARE-DISTRIBUTIVE-LAW ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.fasl written
; compilation finished in 0:00:00.233
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-strings2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-CODE-FOR-STRINGS ...)
; compiling (DEFUN STRING-LIST-P ...)
; compiling (DEFUN STRING-TO-LIST ...)
; compiling (DEFUN LIST-TO-STRING ...)
; compiling (DEFUN LIST-TO-STRING-TERM-REWRITER ...)
; compiling (DEFUN STRING-TO-LIST-TERM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-strings2.fasl written
; compilation finished in 0:00:00.028
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SUM*)
; compiling (DEFVAR *PRODUCT*)
; compiling (DEFVAR *LESS*)
; compiling (DEFVAR *RECIPROCAL*)
; compiling (DEFUN RNUMBERP ...)
; compiling (DEFUN NONZERO-RNUMBERP ...)
; compiling (DEFUN NONZERO-RATIONALP ...)
; compiling (DEFUN LESS? ...)
; compiling (DEFUN LESSEQ? ...)
; compiling (DEFUN GREATER? ...)
; compiling (DEFUN GREATEREQ? ...)
; compiling (DEFUN EUCLIDEAN-QUOTIENT ...)
; compiling (DEFUN EUCLIDEAN-REMAINDER ...)
; compiling (DEFUN CEILING-REMAINDER ...)
; compiling (DEFUN ROUND-REMAINDER ...)
; compiling (DEFUN DECLARE-ARITHMETIC-CHARACTERISTIC-RELATION ...)
; compiling (DEFUN DECLARE-ARITHMETIC-RELATION ...)
; compiling (DEFUN DECLARE-ARITHMETIC-FUNCTION ...)
; compiling (DEFUN DECLARE-CODE-FOR-NUMBERS ...)
; compiling (DEFUN DECLARE-ARITHMETIC-INEQUALITY-RELATIONS ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER0 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER1 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER2 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER3 ...)
; compiling (DEFUN ARITHMETIC-EXPR-ARGS ...)
; compiling (DEFUN ARITHMETIC-ATOM-REWRITER1 ...)
; compiling (DEFUN ARITHMETIC-ATOM-REWRITER4 ...)
; compiling (DEFUN ARITHMETIC-TERM-REWRITER1 ...)
; compiling (DEFUN ARITHMETIC-TERM-REWRITER2 ...)
; compiling (DEFUN ARITHMETIC-TERM-REWRITER3 ...)
; compiling (DEFUN ARITHMETIC-TERM-REWRITER4 ...)
; compiling (DEFUN ARITHMETIC-TERM-REWRITER5 ...)
; compiling (DEFUN DECOMPOSE-PRODUCT-TERM ...)
; compiling (DEFUN SUM-TERM-REWRITER1 ...)
; compiling (DEFUN UMINUS-TERM-REWRITER ...)
; compiling (DEFUN ARITHMETIC-RELATION-REWRITER ...)
; compiling (DEFUN TERM-REL-TERM-TO-0-REL-DIFFERENCE-ATOM-REWRITER ...)
; compiling (DEFUN SUM-REL-NUMBER-ATOM-REWRITER ...)
; compiling (DEFUN PRODUCT-REL-NUMBER-ATOM-REWRITER ...)
; compiling (DEFUN RECIPROCAL-REL-NUMBER-ATOM-REWRITER ...)
; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.fasl written
; compilation finished in 0:00:00.448
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-lists2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-CODE-FOR-LISTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-lists2.fasl written
; compilation finished in 0:00:00.004
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-bags4.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SINGLETON-BAG*)
; compiling (DEFVAR *BAG-UNION*)
; compiling (DEFUN DECLARE-CODE-FOR-BAGS ...)
; compiling (DEFUN BAGP ...)
; compiling (DEFUN INPUT-BAG-TERM ...)
; compiling (DEFUN INPUT-BAG*-TERM ...)
; compiling (DEFUN BAG-UNION-TERM-TO-LISP ...)
; compiling (DEFUN BAG-TO-LIST ...)
; compiling (DEFUN LIST-TO-BAG ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-bags4.fasl written
; compilation finished in 0:00:00.052
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN CONSTRUCTOR-REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN CONSTRUCTOR-IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN VARIABLES-REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN VARIABLES-IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN VARIABLE-SATISFIER ...)
; compiling (DEFUN NONVARIABLE-SATISFIER ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE1 ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE2 ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE2-SATISFIER ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFUN RESOLVE-CODE-RESOLVER1 ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE3 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.fasl written
; compilation finished in 0:00:00.078
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN TABLE-SATISFIER ...)
; compiling (DEFUN TABLE-REWRITER ...)
; compiling (DEFUN TABLE-LOOKUP-PATTERN ...)
; compiling (DEFUN SIMPLE-TABLE-MAPPER ...)
; compiling (DEFUN PREDICATE-TO-TABLE ...)
; compiling (DEFUN RELATION-TO-TABLE ...)
; compiling (DEFUN TEST-TABLE-RESOLVER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.fasl written
; compilation finished in 0:00:00.031
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL ORDERING-IS-TOTAL ...))
; compiling (DEFVAR OPTIONS-PRINT-MODE ...)
; compiling (DEFVAR *SNARK-IS-RUNNING* ...)
; compiling (DEFVAR *AGENDA-OF-FALSE-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-NEW-EMBEDDINGS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-INPUT-ROWS-TO-GIVE*)
; compiling (DEFVAR *AGENDA-OF-INPUT-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-BACKWARD-SIMPLIFIABLE-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-ROWS-TO-GIVE*)
; compiling (DEFVAR *PROOF*)
; compiling (DEFVAR *FALSE-ROWS*)
; compiling (DEFVAR *CONSTRAINT-ROWS*)
; compiling (DEFVAR *HINT-ROWS*)
; compiling (DEFVAR *MANUAL-ORDERING-RESULTS*)
; compiling (DEFVAR CRITIQUE-OPTIONS ...)
; compiling (DEFVAR *PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*)
; compiling (DEFVAR *NEGATIVE-HYPERRESOLUTION*)
; compiling (DEFVAR *FIND-ELSE-SUBSTITUTION* ...)
; compiling (DEFVAR *PROCESSING-ROW* ...)
; compiling (DEFVAR *HINTS-SUBSUMED*)
; compiling (DECLAIM (SPECIAL REWRITE-STRATEGY ...))
; compiling (DEFVAR RECURSIVE-UNSTORE ...)
; compiling (DEFUN CRITIQUE-OPTIONS ...)
; compiling (DEFVAR *NUMBER-OF-GIVEN-ROWS* ...)
; compiling (DEFVAR *NUMBER-OF-BACKWARD-ELIMINATED-ROWS* ...)
; compiling (DEFVAR *NUMBER-OF-AGENDA-FULL-DELETED-ROWS* ...)
; compiling (DECLAIM (TYPE INTEGER ...) ...)
; compiling (DEFUN CLEAR-STATISTICS ...)
; compiling (DEFUN PRINT-SUMMARY ...)
; compiling (DEFUN PRINT-REWRITES ...)
; compiling (DEFVAR REWRITES-INITIALIZED)
; compiling (DEFPARAMETER INITIALIZATION-FUNCTIONS ...)
; compiling (DEFUN INITIALIZE ...)
; compiling (DEFUN INITIALIZE-ROWS2 ...)
; compiling (DEFMACRO WITH-INPUT-FUNCTIONS-DISABLED ...)
; compiling (DEFUN INITIALIZE-AGENDA ...)
; compiling (DEFUN INITIALIZE-REWRITES ...)
; compiling (DEFUN STORE-BOOLEAN-RING-REWRITES ...)
; compiling (DEFUN RENUMBER-ROW ...)
; compiling (DEFVAR *EMBEDDING-VARIABLES* ...)
; compiling (DEFUN EMBEDDING-VARIABLE-P ...)
; compiling (DEFVAR *ASSERT-REWRITE-POLARITY* ...)
; compiling (DEFUN ASSERT-REWRITE-CHECK ...)
; compiling (DEFUN ASSERT-REWRITE ...)
; compiling (DEFMACRO ASSERTION ...)
; compiling (DEFUN ASSERTIONFUN ...)
; compiling (DEFUN ASSERT ...)
; compiling (DEFUN ASSUME ...)
; compiling (DEFUN PROVE ...)
; compiling (DEFUN NEW-PROVE ...)
; compiling (DEFUN HINT ...)
; compiling (DEFUN FAIL ...)
; compiling (DEFUN FAIL-WHEN-NIL ...)
; compiling (DEFUN FAIL-WHEN-TRUE ...)
; compiling (DEFUN FAIL-WHEN-FALSE ...)
; compiling (DEFUN FAIL-WHEN-CONSTRAINT-TRUE ...)
; compiling (DEFUN FAIL-WHEN-DISALLOWED ...)
; compiling (DEFVAR *CHECK-FOR-DISALLOWED-ANSWER* ...)
; compiling (DEFUN ANSWER-DISALLOWED-P ...)
; compiling (DEFUN MAKE-DEMODULANT ...)
; compiling (DEFUN MAKE-ANSWER2 ...)
; compiling (DEFMACRO MAKE-RESOLVENT-PART ...)
; compiling (DEFUN MAKE-RESOLVENT1 ...)
; compiling (DEFUN MAKE-RESOLVENT ...)
; compiling (DEFUN MAKE-RESOLVENTA ...)
; compiling (DEFUN MAKE-RESOLVENTB ...)
; compiling (DEFUN MAKE-RESOLVENTC ...)
; compiling (DEFUN MAKE-HYPERRESOLVENT-NUCLEUS-PART ...)
; compiling (DEFVAR *RESOLVE-FUNCTIONS-USED* ...)
; compiling (DEFUN MAKE-HYPERRESOLVENT ...)
; compiling (DEFUN MAKE-UR-RESOLVENT ...)
; compiling (DEFUN MAKE-PARAMODULANT-FORM ...)
; compiling (DEFUN MAKE-PARAMODULANT ...)
; compiling (DEFUN MAKE-PARAMODULANTA ...)
; compiling (DEFUN CANONICALIZE-WFF ...)
; compiling (DEFUN INDEX-TERMS-IN-ATOM-OF-DERIVED-WFF ...)
; compiling (DEFUN DONT-MAKE-EMBEDDING-P ...)
; compiling (DEFUN EMBEDDING-TYPES ...)
; compiling (DEFUN STORE-REWRITE2 ...)
; compiling (DEFUN STORE-REWRITE ...)
; compiling (DEFUN MAYBE-STORE-ATOM-REWRITE ...)
; compiling (DEFUN STORE-GIVEN-ROW ...)
; compiling (DEFUN STORE-GIVEN-ROW-EQUALITY ...)
; compiling (DEFUN STORE-DERIVED-WFF ...)
; compiling (DEFUN RECURSIVELY-UNSTORE-WFF ...)
; compiling (DEFUN UNSTORE-WFF ...)
; compiling (DEFUN DELETE-ROW ...)
; compiling (DEFUN DELETE-ROWS ...)
; compiling (DEFUN MAKE-SPLIT ...)
; compiling (DEFUN FACTORER ...)
; compiling (DEFUN RESOLVE-WITH-X=X ...)
; compiling (DEFUN RESOLVE-WITH-X-EQ-X ...)
; compiling (DEFUN RESOLVE-WITH-X-EQ-X2 ...)
; compiling (DEFUN FUNCTION-RESOLVE-CODE2 ...)
; compiling (DEFUN RESOLVER ...)
; compiling (DEFUN CODE-RESOLVER ...)
; compiling (DEFINLINE HYPERRESOLUTION-ELECTRON-POLARITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFINLINE HYPERRESOLUTION-ELECTRON-POLARITY
;     (SNARK-LISP:DEFINLINE SNARK::HYPERRESOLUTION-ELECTRON-POLARITY
;         NIL
;       (IF SNARK::*NEGATIVE-HYPERRESOLUTION*
;           :NEG
;           :POS))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::HYPERRESOLUTION-ELECTRON-POLARITY
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::HYPERRESOLUTION-ELECTRON-POLARITY)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::HYPERRESOLUTION-ELECTRON-POLARITY
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK
;                                         SNARK::HYPERRESOLUTION-ELECTRON-POLARITY
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::HYPERRESOLUTION-ELECTRON-POLARITY was compiled before a
;   compiler-macro was defined for it. A declaration of NOTINLINE at the call site
;   will eliminate this warning, as will defining the compiler-macro before its
;   first potential use.

; compiling (DEFINLINE HYPERRESOLUTION-NUCLEUS-POLARITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFINLINE HYPERRESOLUTION-NUCLEUS-POLARITY
;     (SNARK-LISP:DEFINLINE SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY
;         NIL
;       (IF SNARK::*NEGATIVE-HYPERRESOLUTION*
;           :POS
;           :NEG))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK
;                                         SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::HYPERRESOLUTION-NUCLEUS-POLARITY was compiled before a
;   compiler-macro was defined for it. A declaration of NOTINLINE at the call site
;   will eliminate this warning, as will defining the compiler-macro before its
;   first potential use.

; compiling (DEFINLINE ROW-HYPERRESOLUTION-ELECTRON-P ...)
; compiling (DEFINLINE HYPERRESOLUTION-ORDERFUN ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFINLINE HYPERRESOLUTION-ORDERFUN
;     (SNARK-LISP:DEFINLINE SNARK::HYPERRESOLUTION-ORDERFUN
;         NIL
;       (IF SNARK::*NEGATIVE-HYPERRESOLUTION*
;           (SNARK:USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION?)
;           (SNARK:USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION?)))
; --> PROGN DEFINE-COMPILER-MACRO PROGN EVAL-WHEN 
; ==>
;   (SB-C::%DEFINE-COMPILER-MACRO 'SNARK::HYPERRESOLUTION-ORDERFUN
;                                 (SB-INT:NAMED-LAMBDA (COMPILER-MACRO
;                                                       SNARK::HYPERRESOLUTION-ORDERFUN)
;                                     (#:EXPR #:ENV)
;                                   (DECLARE
;                                    (SB-C::LAMBDA-LIST
;                                     (&REST SNARK-LISP::ARG-LIST)))
;                                   (DECLARE (IGNORE #:ENV))
;                                   (SB-C::NAMED-DS-BIND (:MACRO
;                                                         SNARK::HYPERRESOLUTION-ORDERFUN
;                                                         . DEFINE-COMPILER-MACRO)
;                                       (&REST SNARK-LISP::ARG-LIST)
;                                       (SB-C::COMPILER-MACRO-ARGS #:EXPR)
;                                     (BLOCK SNARK::HYPERRESOLUTION-ORDERFUN
;                                       (CONS '# SNARK-LISP::ARG-LIST)))))
; 
; caught STYLE-WARNING:
;   1 call to SNARK::HYPERRESOLUTION-ORDERFUN was compiled before a compiler-macro
;   was defined for it. A declaration of NOTINLINE at the call site will eliminate
;   this warning, as will defining the compiler-macro before its first potential
;   use.

; compiling (DEFUN HYPERRESOLVER ...)
; compiling (DEFUN HYPERRESOLVER1 ...)
; compiling (DEFUN HYPERRESOLVER2 ...)
; compiling (DEFUN UR-RESOLVER ...)
; compiling (DEFUN UR-RESOLVER1 ...)
; compiling (DEFUN UR-RESOLVE1 ...)
; compiling (DEFUN BACKWARD-DEMODULATE-BY ...)
; compiling (DEFUN PARAMODULATER-FROM ...)
; compiling (DEFUN PARAMODULATER-FROM1 ...)
; compiling (DEFUN PARAMODULATER-TO ...)
; compiling (DEFUN PARAMODULATER-TO1 ...)
; compiling (DEFUN PARAMODULATION-ALLOWABLE-P ...)
; compiling (DEFUN ROWS-CONTAINING-PARAMODULATABLE-TERM ...)
; compiling (DEFUN MAKE-EMBEDDINGS ...)
; compiling (DEFUN MAKE-EMBEDDINGS1 ...)
; compiling (DEFUN MAKE-EMBEDDING ...)
; compiling (DEFUN EMBEDDING-VARIABLES ...)
; compiling (DEFUN ALLOWABLE-EMBEDDING-SUPERPOSITION ...)
; compiling (DEFUN DO-NOT-PARAMODULATE ...)
; compiling (DEFUN MEETS-BINARY-RESTRICTIONS-P ...)
; compiling (DEFUN IMPOSE-BINARY-RESTRICTIONS ...)
; compiling (DEFUN PROCESS-NEW-ROW-MSG ...)
; compiling (DEFUN MAYBE-NEW-ROW ...)
; compiling (DEFUN PROCESS-NEW-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PROCESS-NEW-ROW
;     (SETF (SNARK::FUNCTION-CREATED-P SNARK::FN) T)
; --> LET* 
; ==>
;   SNARK::FN
; 
; note: deleting unreachable code

; compiling (DEFUN ROW-PREF ...)
; compiling (DEFUN AGENDA-ITEM-ROW ...)
; compiling (DEFUN AGENDA-ITEM-VAL ...)
; compiling (DEFUN SAME-AGENDA-ITEM-P ...)
; compiling (DEFUN UNSTORE-AGENDA-ITEM ...)
; compiling (DEFUN INSERT-ROW-INTO-AGENDA ...)
; compiling (DEFUN DELETE-ROW-FROM-AGENDA ...)
; compiling (DEFUN POP-FORM-FROM-AGENDA ...)
; compiling (DEFUN RECORD-NEW-EMBEDDING ...)
; compiling (DEFUN RECORD-NEW-INPUT-WFF ...)
; compiling (DEFUN RECORD-BACKWARD-SIMPLIFIABLE-WFF ...)
; compiling (DEFUN RECORD-NEW-DERIVED-ROW ...)
; compiling (DEFUN RECORD-NEW-ROW-TO-GIVE ...)
; compiling (DEFUN RECORD-NEW-ROW-TO-GIVE-AGAIN ...)
; compiling (DEFUN GIVER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN GIVER
;     (RETURN-FROM SNARK::GIVER NIL)
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

; compiling (DEFUN GIVE-CONSTRAINT-ROW ...)
; compiling (DEFUN INITIALIZE-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS ...)
; compiling (DEFUN CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS ...)
; compiling (DEFUN CLOSURE-INIT ...)
; compiling (DEFUN GIVE-IS-NEXT-IN-AGENDA ...)
; compiling (DEFUN CLOSURE ...)
; compiling (DEFUN PROOF ...)
; compiling (DEFUN PROOFS ...)
; compiling (DEFUN ANSWER ...)
; compiling (DEFUN ANSWERS ...)
; compiling (DEFUN MAKE-SNARK-SYSTEM ...)
; compiling (DEFUN SAVE-SNARK-SYSTEM ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.fasl written
; compilation finished in 0:00:01.205
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *FALSE-ROWS* ...))
; compiling (DEFVAR *SUBSUMING* ...)
; compiling (DEFUN MAKE-AND-FREEZE-VARIABLE ...)
; compiling (DEFUN SUBSUME ...)
; compiling (DEFUN SUBSUMES-P ...)
; compiling (DEFUN SUBSUMES-P1 ...)
; compiling (DEFUN SUBSUMED-P ...)
; compiling (DEFUN SUBSUMED-P1 ...)
; compiling (DEFUN SUBSUMERS ...)
; compiling (DEFUN SUBSUMERS1 ...)
; compiling (DEFVAR CLAUSE-SUBSUMPTION ...)
; compiling (DEFVAR SUBSUMPTION-MARK)
; compiling (DEFUN FORWARD-SUBSUMED ...)
; compiling (DEFUN FORWARD-SUBSUMPTION ...)
; compiling (DEFUN BACKWARD-SUBSUMPTION ...)
; compiling (DEFUN FORWARD-CLAUSE-SUBSUMPTION ...)
; compiling (DEFUN BACKWARD-CLAUSE-SUBSUMPTION ...)
; compiling (DEFUN CLAUSE-SUBSUMPTION ...)
; compiling (DEFUN CLAUSE-SUBSUMPTION1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN CLAUSE-SUBSUMPTION1
;     (SNARK::CLAUSE-P SNARK::SUBSUMING-ANSWER)
; ==>
;   SNARK::SUBSUMING-ANSWER
; 
; note: deleting unreachable code

;     (SNARK::CLAUSE-P SNARK::SUBSUMED-ANSWER)
; ==>
;   SNARK::SUBSUMED-ANSWER
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (COND
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMING-ANSWER)
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;          SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMED-ANSWER))
;        ((AND NIL (SNARK::CLAUSE-P SNARK::SUBSUMING-ANSWER)
;              (SNARK::CLAUSE-P SNARK::SUBSUMED-ANSWER))
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMING-ANSWER SNARK::-> SNARK::ANS1)
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMED-ANSWER SNARK::-> SNARK::ANS2)
;         (ASSERT
;          (SNARK::DISJOINT-ANSWER-RELATIONS-P SNARK::L1 SNARK::L2 SNARK::ANS1
;           SNARK::ANS2))
;         (SNARK::CLAUSE-SUBSUMES1 (APPEND SNARK::ANS1 SNARK::L1)
;          (APPEND SNARK::ANS2 SNARK::L2) SNARK::*FROZEN-VARIABLES* SNARK::->*
;          SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        (T
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;          SNARK::->* SUBST)
;         (SNARK::SUBSUME-ANSWERS SNARK::SUBSUMING-ANSWER SNARK::SUBSUMED-ANSWER
;          SUBST SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))))
; --> BLOCK COND IF COND LET IF COND IF PROGN LET SNARK::ATOMS-IN-CLAUSE2 
; ==>
;   SNARK::SUBSUMING-ANSWER
; 
; note: deleting unreachable code

;     (SNARK::DISJOINT-ANSWER-RELATIONS-P SNARK::L1 SNARK::L2 SNARK::ANS1
;      SNARK::ANS2)
; ==>
;   SNARK::L1
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (COND
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMING-ANSWER)
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;          SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMED-ANSWER))
;        ((AND NIL (SNARK::CLAUSE-P SNARK::SUBSUMING-ANSWER)
;              (SNARK::CLAUSE-P SNARK::SUBSUMED-ANSWER))
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMING-ANSWER SNARK::-> SNARK::ANS1)
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMED-ANSWER SNARK::-> SNARK::ANS2)
;         (ASSERT
;          (SNARK::DISJOINT-ANSWER-RELATIONS-P SNARK::L1 SNARK::L2 SNARK::ANS1
;           SNARK::ANS2))
;         (SNARK::CLAUSE-SUBSUMES1 (APPEND SNARK::ANS1 SNARK::L1)
;          (APPEND SNARK::ANS2 SNARK::L2) SNARK::*FROZEN-VARIABLES* SNARK::->*
;          SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        (T
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;          SNARK::->* SUBST)
;         (SNARK::SUBSUME-ANSWERS SNARK::SUBSUMING-ANSWER SNARK::SUBSUMED-ANSWER
;          SUBST SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))))
; --> BLOCK COND IF COND LET IF COND IF PROGN LET LET SNARK::CLAUSE-SUBSUMES1 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> BLOCK COND IF COND LET IF COND IF PROGN LET LET SNARK::ATOMS-IN-CLAUSE2 
; ==>
;   SNARK::SUBSUMED-ANSWER
; 
; note: deleting unreachable code

; compiling (DEFUN DISJOINT-ANSWER-RELATIONS-P ...)
; compiling (DEFUN FORWARD-OR-BACKWARD-WFF-SUBSUMPTION ...)
; compiling (DEFUN FORWARD-OR-BACKWARD-ATOM-SUBSUMPTION ...)
; compiling (DEFUN WFF-SUBSUMPTION ...)
; compiling (DEFUN WFF-SUBSUMPTION* ...)
; compiling (DEFUN WFF-SUBSUMPTION*1 ...)
; compiling (DEFUN NMATCHES ...)
; compiling (DEFUN SUBSUME-ANSWERS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.fasl written
; compilation finished in 0:00:00.115
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN CLAUSE-SUBSUMES-P ...)
; compiling (DEFUN CLAUSE-SUBSUMES-P1 ...)
; compiling (DEFUN CLAUSE-SUBSUMES1 ...)
; compiling (DEFUN CLAUSE-SUBSUMES2 ...)
; compiling (DEFUN MAKE-SUBSUMPTION-TEST-DP-CLAUSE-SET ...)
; compiling (DEFUN REORDER-ATOMS2 ...)
; compiling (DEFUN REFINE-SUBSTS ...)
; compiling (DEFUN MAKE-SUBSUMPTION-TEST-CLAUSES ...)
; compiling (DEFUN MAKE-SUBSUMPTION-TEST-DP-CLAUSE-SET1 ...)
; compiling (DEFUN CONDENSER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.fasl written
; compilation finished in 0:00:00.130
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-file.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO IN-LANGUAGE ...)
; compiling (DEFMACRO IN-KB ...)
; compiling (DEFMACRO HAS-AUTHOR ...)
; compiling (DEFMACRO HAS-DOCUMENTATION ...)
; compiling (DEFMACRO HAS-NAME ...)
; compiling (DEFMACRO HAS-SOURCE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-COMMANDS ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-KEYWORDS ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-FORMAT ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-IF-DOES-NOT-EXIST ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-VERBOSE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-PACKAGE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-READTABLE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-NEGATE-CONJECTURES ...)
; compiling (DEFUN READ-ASSERTION-FILE ...)
; compiling (DEFUN MUST-PRECEDE-IN-ASSERTION-FILE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-INITIALIZE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-CLOSURE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-OPTIONS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-ACTIONS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-IGNORE-ERRORS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-VERBOSE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-OUTPUT-FILE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-IF-EXISTS ...)
; compiling (DEFUN REFUTE-FILE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-file.fasl written
; compilation finished in 0:00:00.151
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN PRINT-ROW-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFF-IN-TPTP-FORMAT1 ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-ROW-NAME-OR-NUMBER-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT2 ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT3 ...)
; compiling (DEFUN PRINT-ROW-SOURCE-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFF-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFFS-IN-TPTP-FORMAT ...)
; compiling (DEFUN TPTP-FUNCTION-NAME ...)
; compiling (DEFUN PRINT-TERM-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-VARSPECS ...)
; compiling (DEFUN PRINT-LIST-IN-TPTP-FORMAT ...)
; compiling (DEFUN QUOTE-TPTP-SYMBOL? ...)
; compiling (DEFUN PRINT-SYMBOL-IN-TPTP-FORMAT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN PRINT-SYMBOL-IN-TPTP-FORMAT
;     (READTABLE-CASE *READTABLE*)
; 
; note: deleting unreachable code

;     (SOME #'UPPER-CASE-P STRING)
; --> BLOCK SB-INT:DX-FLET FLET SB-KERNEL:%MAP 
; ==>
;   STRING
; 
; note: deleting unreachable code

;     (SOME #'LOWER-CASE-P STRING)
; --> BLOCK SB-INT:DX-FLET FLET SB-KERNEL:%MAP 
; ==>
;   STRING
; 
; note: deleting unreachable code

;     (PRINC SNARK::X)
; ==>
;   SNARK::X
; 
; note: deleting unreachable code

;     (SNARK-LISP:CHAR-INVERT-CASE SNARK::CH)
; ==>
;   SNARK::CH
; 
; note: deleting unreachable code

; compiling (DEFUN TPTP-SORT-NAME ...)
; compiling (DEFVAR *TPTP-ENVIRONMENT-VARIABLE* ...)
; compiling (DEFUN TPTP-INCLUDE-FILE-NAME ...)
; compiling (DEFUN TPTP-FILE-SOURCE-STRING ...)
; compiling (DEFUN MAPNCONC-TPTP-FILE-FORMS ...)
; compiling (DEFUN TPTP-TO-SNARK-REASON ...)
; compiling (DEFUN INPUT-TPTP-TYPE-DECLARATION ...)
; compiling (DEFUN TPTP-TYPE-PRODUCT-P ...)
; compiling (DEFUN TPTP-TYPE-PRODUCT-LIST ...)
; compiling (DEFUN NUMBER-LIST ...)
; compiling (DEFVAR *TPTP-FORMAT* ...)
; compiling (DEFVAR *TPTP-INPUT-DIRECTORY* ...)
; compiling (DEFVAR *TPTP-INPUT-DIRECTORY-HAS-DOMAIN-SUBDIRECTORIES* ...)
; compiling (DEFVAR *TPTP-INPUT-FILE-TYPE* ...)
; compiling (DEFVAR *TPTP-OUTPUT-DIRECTORY* ...)
; compiling (DEFVAR *TPTP-OUTPUT-DIRECTORY-HAS-DOMAIN-SUBDIRECTORIES* ...)
; compiling (DEFVAR *TPTP-OUTPUT-FILE-TYPE* ...)
; compiling (DEFUN TPTP-PROBLEM-PATHNAME0 ...)
; compiling (DEFUN TPTP-PROBLEM-INPUT-PATHNAME ...)
; compiling (DEFUN TPTP-PROBLEM-OUTPUT-PATHNAME ...)
; compiling (DEFUN DO-TPTP-PROBLEM ...)
; compiling (DEFUN DO-TPTP-PROBLEM0 ...)
; compiling (DEFUN DO-TPTP-PROBLEM1 ...)
; compiling (DEFUN TRANSLATE-ASSERTION-FILE-TO-TPTP-FORMAT ...)
; compiling (DEFUN DECLARE-TPTP-OPERATORS ...)
; compiling (DEFUN TPTP-TO-SNARK-INPUT ...)
; compiling (DEFUN FIX-TPTP-SYMBOL ...)
; compiling (DEFUN TPTP-TO-SNARK-INPUT-ARGS ...)
; compiling (DEFUN STRIP-COLONS ...)
; compiling (DEFUN READ-TPTP-TERM1 ...)
; compiling (DEFUN READ-TPTP-TERM ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.fasl written
; compilation finished in 0:00:00.195
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp-symbols.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN DECLARE-TPTP-SORT ...)
; compiling (DEFUN DECLARE-TPTP-SYMBOLS1 ...)
; compiling (DEFUN DECLARE-TPTP-SYMBOLS2 ...)
; compiling (DEFUN TO_RAT-TERM-REWRITER ...)
; compiling (DEFUN TO_REAL-TERM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp-symbols.fasl written
; compilation finished in 0:00:00.022
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFSTRUCT (PROOF-LINE # ...) ...)
; compiling (DEFVAR *CODER-START-TIME*)
; compiling (DEFVAR *CODER-RUN-TIME-LIMIT*)
; compiling (DEFVAR *CODER-STEP-COUNT*)
; compiling (DEFVAR *CODER-DERIVATION-COUNT*)
; compiling (DEFVAR *CODER-PRINT-STATE-INTERVAL* ...)
; compiling (DEFVAR *CODER-MAXIMUM-TERM-SIZE-FOUND*)
; compiling (DEFVAR *CODER-MAXIMUM-TARGET-SIZE*)
; compiling (DEFVAR *CODER-TERM-SIZE-LIMIT*)
; compiling (DEFVAR *CODER-TERM-VARS-LIMIT*)
; compiling (DEFVAR *CODER-ORDERING* ...)
; compiling (DEFVAR *CODER-DO-REVERSE-CD*)
; compiling (DEFVAR *TEST1* ...)
; compiling (DEFVAR *TEST2* ...)
; compiling (DEFUN CODER ...)
; compiling (DEFUN CODER1 ...)
; compiling (DEFUN SORT-NEW-LINES ...)
; compiling (DEFUN SELECTED-LINES ...)
; compiling (DEFUN CODER-DEFAULT-SYMBOL-ORDERING ...)
; compiling (DEFUN FORWARD-SUBSUMED? ...)
; compiling (DEFUN BACKWARD-SUBSUMES? ...)
; compiling (DEFUN DO-CD ...)
; compiling (DEFUN JUST-LINE-NUMBER ...)
; compiling (DEFUN JUST-LIST ...)
; compiling (DEFUN PRINT-PROOF-LINE-JUST ...)
; compiling (DEFUN PRINT-PROOF-LINE ...)
; compiling (DEFUN PRINT-PROOF-LINES ...)
; compiling (DEFUN PRINT-PROOF ...)
; compiling (DEFUN CODER-STATE ...)
; compiling (DEFUN PRINT-CODER-STATE ...)
; compiling (DEFVAR *INPUT-TARGET-ALIST*)
; compiling (DEFUN INPUT-TARGET ...)
; compiling (DEFUN TOGETHER-TARGET? ...)
; compiling (DEFUN CONTAINS-TEST-TARGET? ...)
; compiling (DEFUN WRAP2 ...)
; compiling (DEFUN CODER-INPUT-TERM ...)
; compiling (DEFUN INPUT-TOGETHER-TARGET ...)
; compiling (DEFUN INPUT-NORMAL-TARGET ...)
; compiling (DEFUN INPUT-SINGLE-TARGET ...)
; compiling (DEFUN TARGET? ...)
; compiling (DEFUN REMOVE-TARGET ...)
; compiling (DEFUN REMOVE-STEP-TO-USE ...)
; compiling (DEFUN PRINT-PROOF-FOR-OTTER-VERIFICATION ...)
; compiling (DEFUN PRINT-TERM-FOR-OTTER2 ...)
; compiling (DEFUN PRINT-TERM-FOR-OTTER ...)
; compiling (DEFUN COMB ...)
; compiling (DEFUN SHORTEN-PROOF ...)
; compiling (DEFUN STRIP-ORS ...)
; compiling (DEFUN CONDENSED-DETACHMENT-RULE-P ...)
; compiling (DEFUN CONDENSED-DETACHMENT-PROBLEM-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.fasl written
; compilation finished in 0:00:00.292
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/overbeek-test.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN OVERBEEK-TEST ...)
; compiling (DEFUN REFUTE-SNARK-EXAMPLE-FILE ...)
; compiling (DEFUN OVERBEEK1 ...)
; compiling (DEFUN OVERBEEK2 ...)
; compiling (DEFUN OVERBEEK3 ...)
; compiling (DEFUN OVERBEEK4 ...)
; compiling (DEFUN OVERBEEK5 ...)
; compiling (DEFUN OVERBEEK6 ...)
; compiling (DEFUN OVERBEEK7 ...)
; compiling (DEFUN OVERBEEK4-1 ...)
; compiling (DEFUN OVERBEEK5-1 ...)
; compiling (DEFUN OVERBEEK6-1 ...)
; compiling (DEFUN OVERBEEK7-1 ...)
; compiling (DEFUN OVERBEEK1E ...)
; compiling (DEFUN OVERBEEK2E ...)
; compiling (DEFUN OVERBEEK3E ...)
; compiling (DEFUN OVERBEEK4E ...)
; compiling (DEFUN OVERBEEK5E ...)
; compiling (DEFUN OVERBEEK6E ...)
; compiling (DEFUN OVERBEEK7E ...)
; compiling (DEFUN OVERBEEK7E-1 ...)
; compiling (DEFUN OVERBEEK8E ...)
; compiling (DEFUN OVERBEEK9E ...)
; compiling (DEFUN OVERBEEK10E ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/overbeek-test.fasl written
; compilation finished in 0:00:00.030
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/front-last-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN FRONT-LAST-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/front-last-example.fasl written
; compilation finished in 0:00:00.003
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/steamroller-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN STEAMROLLER-EXAMPLE0 ...)
; compiling (DEFUN STEAMROLLER-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/steamroller-example.fasl written
; compilation finished in 0:00:00.003
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/reverse-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN REVERSE-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/reverse-example.fasl written
; compilation finished in 0:00:00.006
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN ROW-PREDICATE-NAMES ...)
; compiling (DEFUN ROW-RELATION-NAMES ...)
; compiling (DEFUN PARTITION-COMMUNICATION ...)
; compiling (DEFUN HOT-DRINK-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.fasl written
; compilation finished in 0:00:00.019
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/coder-examples.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN CODER-TEST ...)
; compiling (DEFUN CODER-XCB-REFLEX ...)
; compiling (DEFUN CODER-OVERBEEK6 ...)
; compiling (DEFUN CODER-OVERBEEK4 ...)
; compiling (DEFUN CODER-YCL-RST ...)
; compiling (DEFUN CODER-YCL-RST-TOGETHER ...)
; compiling (DEFUN CODER-VEROFF-5-2 ...)
; compiling (DEFUN CODER-VEROFF-4-1 ...)
; compiling (DEFUN II-SCHEMA ...)
; compiling (DEFUN ID-SCHEMA ...)
; compiling (DEFUN CR-SCHEMA1 ...)
; compiling (DEFUN CR-SCHEMA2 ...)
; compiling (DEFUN EQ-SCHEMA1 ...)
; compiling (DEFUN EQ-SCHEMA2 ...)
; compiling (DEFUN EQ-SCHEMA3 ...)
; compiling (DEFUN OR-SCHEMA ...)
; compiling (DEFUN AND-SCHEMA ...)
; compiling (DEFUN ALT-AND-SCHEMA ...)
; compiling (DEFUN CODER-EX1 ...)
; compiling (DEFUN CODER-EX2 ...)
; compiling (DEFUN CODER-EX3 ...)
; compiling (DEFUN CODER-EX4 ...)
; compiling (DEFUN CODER-EX5 ...)
; compiling (DEFUN CODER-EX6 ...)
; compiling (DEFUN CODER-EX6A ...)
; compiling (DEFUN CODER-EX6B ...)
; compiling (DEFUN CODER-EX7A ...)
; compiling (DEFUN CODER-EX7B ...)
; compiling (DEFUN CODER-EX8 ...)
; compiling (DEFUN CODER-EX9 ...)
; compiling (DEFUN CODER-EX10 ...)
; compiling (DEFUN CODER-EX11 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/coder-examples.fasl written
; compilation finished in 0:00:00.067
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN LATIN-SQUARE-CLAUSES ...)
; compiling (DEFUN MODEL-TO-LATIN-SQUARE ...)
; compiling (DEFUN GENERATE-LATIN-SQUARES ...)
; compiling (DEFUN PRINT-LATIN-SQUARE ...)
; compiling (DEFUN LATIN-SQUARE-CONJUGATE ...)
; compiling (DEFUN LATIN-SQUARE-STANDARD-FORM ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/patches.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-INSTANCE-GRAPH ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/patches.fasl written
; compilation finished in 0:00:00.002
; 
; compilation unit finished
;   caught 20 STYLE-WARNING conditions
;   printed 86 notes
; Running SNARK from /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/snark-system.lisp in SBCL 1.3.1.debian (64-bit) on gitlab at 2018-04-27T20:04:29
NIL
* 
(OPTIMIZE (SAFETY 1) (SPACE 1) (SPEED 3) (DEBUG 1)) 
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFMACRO MVLET ...)
; compiling (DEFMACRO MVLET* ...)
; compiling (DEFUN BINDING-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.lisp
; in: DEFUN BINDING-P
;     (<= 2 SNARK-LISP::N)
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

;     (+ SNARK-LISP::N 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN LIST-BINDINGS ...)
; compiling (DEFUN MVLET-EXPANSION ...)
; compiling (DEFUN EXPAND-MVLET ...)
; compiling (DEFUN EXPAND-MVLET1 ...)
; compiling (DEFUN TYPE-SYMBOL-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.lisp
; in: DEFUN TYPE-SYMBOL-P
;     (TYPEP NIL SNARK-LISP::X)
; 
; note: unable to optimize because: can't open-code test of non-constant type

; compiling (DEFUN EXTRACT-DECLARATION-SPECIFIERS ...)
; compiling (DEFUN FILTER-DECLARATION-SPECIFIERS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.lisp
; in: DEFUN FILTER-DECLARATION-SPECIFIERS
;     (MEMBER (SECOND SNARK-LISP::D) SNARK-LISP::V)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER (THIRD SNARK-LISP::D) SNARK-LISP::V)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC (SECOND SNARK-LISP::D) SUBST)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER SNARK-LISP::X SNARK-LISP::V)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC (THIRD SNARK-LISP::D) SUBST)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER SNARK-LISP::X SNARK-LISP::V)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN MVLET-TEST1 ...)
; compiling (DEFUN MVLET-TEST2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/mvlet.fasl written
; compilation finished in 0:00:00.176
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFPARAMETER *PROG->-FUNCTION-SECOND-FORMS* ...)
; compiling (DEFPARAMETER *PROG->-SPECIAL-FORMS* ...)
; compiling (DEFUN PROG->*-FUNCTION-SECOND-FORM-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.lisp
; in: DEFUN PROG->*-FUNCTION-SECOND-FORM-P
;     (MEMBER SNARK-LISP::FN SNARK-LISP:*PROG->-FUNCTION-SECOND-FORMS*)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN PROG->-SPECIAL-FORM ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-PATTERN ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-ARGS ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-RESULT ...)
; compiling (DEFUN PROG->-SPECIAL-FORM-MATCH-ERROR ...)
; compiling (DEFUN PROG->-NO-VARIABLE-ERROR ...)
; compiling (DEFUN PROG->-TOO-MANY-VARIABLES-ERROR ...)
; compiling (DEFUN PROG->-TOO-MANY->S-ERROR ...)
; compiling (DEFUN PROG->-UNRECOGNIZED->-ATOM ...)
; compiling (DEFUN PROG->-ATOM ...)
; compiling (DEFUN PROG->*-FUNCTION-ARGUMENT ...)
; compiling (DEFUN PROCESS-PROG-> ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.lisp
; in: DEFUN PROCESS-PROG->
;     (STRING (FIRST SNARK-LISP::FORMALS))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (STRING (FIRST SNARK-LISP::ARGS))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (STRING= (STRING (FIRST SNARK-LISP::FORMALS))
;              (STRING (FIRST SNARK-LISP::ARGS)))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-BASE-STRING.The second argument is a STRING, not a SIMPLE-BASE-STRING.

;     (STRING (FIRST SNARK-LISP::X))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DEFUN PROG->*-CALL ...)
; compiling (DEFUN WRAP-PROGN ...)
; compiling (DEFUN WRAP-BLOCK ...)
; compiling (DEFUN PROCESS-PROG->-PROGN ...)
; compiling (DEFUN PROCESS-PROG->-BLOCK ...)
; compiling (DEFMACRO UNNAMED-PROG-> ...)
; compiling (DEFMACRO PROG-> ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/progc.fasl written
; compilation finished in 0:00:00.105
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFCONSTANT NONE ...)
; compiling (DEFCONSTANT TRUE ...)
; compiling (DEFCONSTANT FALSE ...)
; compiling (DEFMACRO DEFINLINE ...)
; compiling (DEFINLINE NEQ ...)
; compiling (DEFINLINE NEQL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFINLINE NEQL
;     (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFINLINE NEQUAL ...)
; compiling (DEFINLINE NEQUALP ...)
; compiling (DEFINLINE IFF ...)
; compiling (DEFMACRO IMPLIES ...)
; compiling (DEFMACRO IF-LET ...)
; compiling (DEFMACRO WHEN-LET ...)
; compiling (DEFUN KWOTE ...)
; compiling (DEFUN UNQUOTE ...)
; compiling (DEFINLINE RREST ...)
; compiling (DEFINLINE RRREST ...)
; compiling (DEFINLINE RRRREST ...)
; compiling (DEFINLINE MKLIST ...)
; compiling (DEFUN FIRSTN ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN FIRSTN
;     (- SNARK-LISP::NUM 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN CONSN ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN CONSN
;     (DOTIMES (SNARK-LISP::DUMMY SNARK-LISP::NUM)
;       (DECLARE (TYPE INTEGER SNARK-LISP::DUMMY)
;                (IGNORABLE SNARK-LISP::DUMMY))
;       (PUSH SNARK-LISP::X SNARK-LISP::Y))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-LISP::DUMMY 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN LEAFP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN LEAFP
;     (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN NATURALP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN NATURALP
;     (MINUSP SNARK-LISP::X)
; ==>
;   (< SNARK-LISP::X 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; compiling (DEFUN RATIOP ...)
; compiling (DEFMACRO CARC ...)
; compiling (DEFMACRO CDRC ...)
; compiling (DEFMACRO CAARCC ...)
; compiling (DEFMACRO CADRCC ...)
; compiling (DEFMACRO CDARCC ...)
; compiling (DEFMACRO CDDRCC ...)
; compiling (DEFMACRO LCONS ...)
; compiling (DEFINLINE CONS-UNLESS-NIL ...)
; compiling (DEFMACRO PUSH-UNLESS-NIL ...)
; compiling (DEFMACRO PUSHNEW-UNLESS-NIL ...)
; compiling (DEFMACRO DOTAILS ...)
; compiling (DEFMACRO DOPAIRS ...)
; compiling (DEFUN CHOOSE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN CHOOSE
;     (LENGTH LIST)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (MINUSP SNARK-LISP::K)
; ==>
;   (< SNARK-LISP::K 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (FUNCALL SNARK-LISP::CC NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-LISP::CC SNARK-LISP::L)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-LISP::CC (CONS SNARK-LISP::X SNARK-LISP::RES))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSERT (<= 0 SNARK-LISP::K SNARK-LISP::LEN))
; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LABELS ((SNARK-LISP::CHOOSE*
;                  (SNARK-LISP::CC SNARK-LISP::L SNARK-LISP::K SNARK-LISP::N)
;                (COND (# #) (# #) (T # #))))
;       (LET ((SNARK-LISP::LEN (LENGTH LIST)))
;         (WHEN (MINUSP SNARK-LISP::K) (INCF SNARK-LISP::K SNARK-LISP::LEN))
;         (ASSERT (<= 0 SNARK-LISP::K SNARK-LISP::LEN))
;         (SNARK-LISP::CHOOSE* FUNCTION LIST SNARK-LISP::K SNARK-LISP::LEN)
;         NIL))
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

;     (EQL SNARK-LISP::N SNARK-LISP::K)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       etc.

;     (DECF SNARK-LISP::N)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-LISP::K 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MINUSP SNARK-LISP::K)
; ==>
;   (< SNARK-LISP::K 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (INCF SNARK-LISP::K SNARK-LISP::LEN)
; --> SETQ THE 
; ==>
;   (+ SNARK-LISP::LEN SNARK-LISP::K)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (ASSERT (<= 0 SNARK-LISP::K SNARK-LISP::LEN))
; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> TAGBODY LET WHEN IF <= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (<= #:G626 #:G625) (IF (<= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; compiling (DEFUN INTEGERS-BETWEEN ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN INTEGERS-BETWEEN
;     (< SNARK-LISP::I SNARK-LISP::LOW)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (DECF SNARK-LISP::I)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INTS ...)
; compiling (DEFUN LENGTH= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN LENGTH=
;     (<= 0 SNARK-LISP::Y)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (- SNARK-LISP::Y 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN LENGTH< ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN LENGTH<
;     (> 0 SNARK-LISP::X)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (<= 1 SNARK-LISP::Y)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (> 0 SNARK-LISP::X)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (- SNARK-LISP::X 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= 1 SNARK-LISP::Y)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (- SNARK-LISP::Y 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN LENGTH<= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN LENGTH<=
;     (> 1 SNARK-LISP::X)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (<= 0 SNARK-LISP::Y)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (> 1 SNARK-LISP::X)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (- SNARK-LISP::X 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= 0 SNARK-LISP::Y)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (- SNARK-LISP::Y 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE LENGTH> ...)
; compiling (DEFINLINE LENGTH>= ...)
; compiling (DEFUN ACONS+ ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN ACONS+
;     (= 0 SNARK-LISP::DELTA)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (FUNCALL SNARK-LISP::TEST SNARK-LISP::KEY (CAR SNARK-LISP::PAIR))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (= 0 SNARK-LISP::DATUM)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (EQL SNARK-LISP::KEY (CAR SNARK-LISP::PAIR))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (+ (CDR SNARK-LISP::PAIR) SNARK-LISP::DELTA)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ALIST-NOTANY-PLUSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN ALIST-NOTANY-PLUSP
;     (PLUSP (CDR SNARK-LISP::PAIR))
; ==>
;   (> (CDR SNARK-LISP::PAIR) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN ALIST-NOTANY-MINUSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN ALIST-NOTANY-MINUSP
;     (MINUSP (CDR SNARK-LISP::PAIR))
; ==>
;   (< (CDR SNARK-LISP::PAIR) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN CONS-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN CONS-COUNT
;     (+ 1 (SNARK-LISP:CONS-COUNT (SNARK-LISP:CARC SNARK-LISP::X)) SNARK-LISP::N)
; --> + 
; ==>
;   (+ 1 (SNARK-LISP:CONS-COUNT (SNARK-LISP:CARC SNARK-LISP::X)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; ==>
;   (+ (+ 1 (SNARK-LISP:CONS-COUNT (SNARK-LISP:CARC SNARK-LISP::X)))
;      SNARK-LISP::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN CHAR-INVERT-CASE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN CHAR-INVERT-CASE
;     (CHAR-UPCASE SNARK-LISP::CH)
; 
; note: unable to open code due to type uncertainty: The first argument is a CHARACTER, not a BASE-CHAR.

;     (CHAR-DOWNCASE SNARK-LISP::CH)
; 
; note: unable to open code due to type uncertainty: The first argument is a CHARACTER, not a BASE-CHAR.

; compiling (LET (#) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN CASE-PRESERVED-READTABLE
;     (ASSOC READTABLE SNARK-LISP::CASE-PRESERVED-READTABLE-CACHE)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN TO-STRING ...)
; compiling (DEFUN FIND-OR-MAKE-PACKAGE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN FIND-OR-MAKE-PACKAGE
;     (STRING SNARK-LISP::PKG)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DEFUN PERCENTAGE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN PERCENTAGE
;     (* 100 SNARK-LISP::M)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-TIME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN PRINT-TIME
;     (FORMAT SNARK-LISP::DESTINATION
;             (IF SNARK-LISP::BASIC
;                 "~4D~2,'0D~2,'0DT~2,'0D~2,'0D~2,'0D"
;                 "~4D-~2,'0D-~2,'0DT~2,'0D:~2,'0D:~2,'0D")
;             SNARK-LISP::YEAR SNARK-LISP::MONTH SNARK-LISP::DATE SNARK-LISP::HOUR
;             SNARK-LISP::MINUTE SECOND)
; 
; note: unable to optimize because: The control string is not a constant.

; compiling (DEFUN PRINT-UNIVERSAL-TIME ...)
; compiling (DEFUN PRINT-CURRENT-TIME ...)
; compiling (DEFUN LEAP-YEAR-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN LEAP-YEAR-P
;     (MOD SNARK-LISP::YEAR 4)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-4) (4)) (DOUBLE-FLOAT -4.0d0 4.0d0) (SINGLE-FLOAT -4.0 4.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-4) (4)) (DOUBLE-FLOAT -4.0d0 4.0d0) (SINGLE-FLOAT -4.0 4.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-4) (4)) (DOUBLE-FLOAT -4.0d0 4.0d0) (SINGLE-FLOAT -4.0 4.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MOD SNARK-LISP::YEAR 100)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-100) (100)) (DOUBLE-FLOAT -100.0d0 100.0d0) (SINGLE-FLOAT -100.0 100.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-100) (100)) (DOUBLE-FLOAT -100.0d0 100.0d0) (SINGLE-FLOAT -100.0 100.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-100) (100)) (DOUBLE-FLOAT -100.0d0 100.0d0) (SINGLE-FLOAT -100.0 100.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MOD SNARK-LISP::YEAR 400)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-400) (400)) (DOUBLE-FLOAT -400.0d0 400.0d0) (SINGLE-FLOAT -400.0 400.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-400) (400)) (DOUBLE-FLOAT -400.0d0 400.0d0) (SINGLE-FLOAT -400.0 400.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-400) (400)) (DOUBLE-FLOAT -400.0d0 400.0d0) (SINGLE-FLOAT -400.0 400.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MOD SNARK-LISP::YEAR 4)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-4) (4)) (DOUBLE-FLOAT -4.0d0 4.0d0) (SINGLE-FLOAT -4.0 4.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 8.0d0) (SINGLE-FLOAT (0.0) 8.0) (RATIONAL (0) (8))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-4) (4)) (DOUBLE-FLOAT -4.0d0 4.0d0) (SINGLE-FLOAT -4.0 4.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 8.0d0) (SINGLE-FLOAT (0.0) 8.0) (RATIONAL (0) (8))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MOD SNARK-LISP::YEAR 100)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-100) (100)) (DOUBLE-FLOAT -100.0d0 100.0d0) (SINGLE-FLOAT -100.0 100.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 200.0d0) (SINGLE-FLOAT (0.0) 200.0) (RATIONAL (0) (200))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-100) (100)) (DOUBLE-FLOAT -100.0d0 100.0d0) (SINGLE-FLOAT -100.0 100.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 200.0d0) (SINGLE-FLOAT (0.0) 200.0) (RATIONAL (0) (200))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MOD SNARK-LISP::YEAR 400)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-400) (400)) (DOUBLE-FLOAT -400.0d0 400.0d0) (SINGLE-FLOAT -400.0 400.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 800.0d0) (SINGLE-FLOAT (0.0) 800.0) (RATIONAL (0) (800))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-400) (400)) (DOUBLE-FLOAT -400.0d0 400.0d0) (SINGLE-FLOAT -400.0 400.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 800.0d0) (SINGLE-FLOAT (0.0) 800.0) (RATIONAL (0) (800))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN DAYS-PER-MONTH ...)
; compiling (DEFUN MONTH-NUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN MONTH-NUMBER
;     (STRING SNARK-LISP::MONTH)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (<= 1 SNARK-LISP::MONTH 12)
; --> 
; --> (LAMBDA (#:G920 #:G919 #:G918) (DECLARE (TYPE REAL #:G920 #:G919 #:G918)) (IF (<= #:G920 #:G919) (IF (<= #:G919 #:G918) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G920 #:G919 #:G918) (DECLARE (TYPE REAL #:G920 #:G919 #:G918)) (IF (<= #:G920 #:G919) (IF (<= #:G919 #:G918) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       etc.

; compiling (DEFUN PRINT-ARGS ...)
; compiling (DEFMACRO DEFINE-PLIST-SLOT-ACCESSOR ...)
; compiling (DEFVAR *PRINT-PRETTY2* ...)
; compiling (DEFMACRO WITH-STANDARD-IO-SYNTAX2 ...)
; compiling (DEFUN QUIT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.lisp
; in: DEFUN QUIT
;     (QUIT)
; 
; caught STYLE-WARNING:
;   The function SB-EXT:QUIT has been deprecated as of SBCL version 1.0.56.55.
;   
;   Use SB-EXT:EXIT or SB-THREAD:ABORT-THREAD instead.
;   In future SBCL versions SB-EXT:QUIT will signal a full warning at compile-time.
;   See also:
;     The SBCL Manual, Node "Deprecation Conditions"


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/lisp.fasl written
; compilation finished in 0:00:00.249
WARNING: Reference to deprecated function (SB-EXT:QUIT) from QUIT
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/collectors.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN MAKE-COLLECTOR ...)
; compiling (DEFUN COLLECTOR-VALUE ...)
; compiling (DEFUN COLLECT-ITEM ...)
; compiling (DEFUN COLLECT-LIST ...)
; compiling (DEFSTRUCT (QUEUE # ...) ...)
; compiling (DEFUN QUEUE-EMPTY-P ...)
; compiling (DEFUN ENQUEUE ...)
; compiling (DEFUN DEQUEUE ...)
; compiling (DEFMACRO COLLECT ...)
; compiling (DEFMACRO NCOLLECT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/collectors.fasl written
; compilation finished in 0:00:00.240
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN MAPNCONC-FILE-FORMS ...)
; compiling (DEFUN MAPNCONC-FILE-LINES ...)
; compiling (DEFUN MAPNCONC-STREAM-FORMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.lisp
; in: DEFUN MAPNCONC-STREAM-FORMS
;     (FUNCALL FUNCTION SNARK-LISP::FORM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAPNCONC-STREAM-LINES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.lisp
; in: DEFUN MAPNCONC-STREAM-LINES
;     (FUNCALL FUNCTION SNARK-LISP::LINE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAPNCONC-STREAM0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.lisp
; in: DEFUN MAPNCONC-STREAM0
;     (FUNCALL SNARK-LISP::READ-FUNCTION STREAM NIL SNARK-LISP::EOF)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::READ-FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-LISP::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN READ-FILE ...)
; compiling (DEFUN READ-FILE-LINES ...)
; compiling (DEFUN READ-FILE-TO-STRING ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/map-file.fasl written
; compilation finished in 0:00:00.027
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFVAR *CLOCKS* ...)
; compiling (DEFUN MAKE-CLOCK-VARIABLE ...)
; compiling (MAPC (FUNCTION MAKE-CLOCK-VARIABLE) ...)
; compiling (DEFVAR *EXCLUDED-CLOCKS* ...)
; compiling (DEFVAR *RUNNING-CLOCKS* ...)
; compiling (DEFVAR *FIRST-REAL-TIME-VALUE* ...)
; compiling (DEFVAR *FIRST-RUN-TIME-VALUE* ...)
; compiling (DEFVAR *LAST-RUN-TIME-VALUE* ...)
; compiling (DEFVAR *RUN-TIME-MARK* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *TOTAL-SECONDS* ...)
; compiling (DEFUN INITIALIZE-CLOCKS ...)
; compiling (DEFMACRO WITH-CLOCK-ON ...)
; compiling (DEFMACRO WITH-CLOCK-OFF ...)
; compiling (DEFUN CLOCK-NAME ...)
; compiling (DEFUN PRINT-CLOCKS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.lisp
; in: DEFUN PRINT-CLOCKS
;     (/ SNARK-LISP::OTHER-TIME (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to convert to multiplication by reciprocal due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.

;     (/ SNARK-LISP::TOTAL-TICKS (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to convert to multiplication by reciprocal due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.

;     (MEMBER SNARK-LISP::CLK SNARK-LISP::EXCLUDED-CLOCKS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (/ SNARK-LISP::RUN-TIME (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to convert to multiplication by reciprocal due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.

;     (FORMAT T
;             (IF (EQL 0 SNARK-LISP::TIME-EXCLUDED)
;                 " excluding ~(~A~)"
;                 ", ~(~A~)")
;             (SNARK-LISP::CLOCK-NAME SNARK-LISP::CLK))
; 
; note: unable to optimize because: The control string is not a constant.

;     (- (GET-INTERNAL-RUN-TIME) SNARK-LISP::*FIRST-RUN-TIME-VALUE*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-LISP::TIME-INCLUDED SNARK-LISP::RUN-TIME)
; --> SETQ THE 
; ==>
;   (+ SNARK-LISP::RUN-TIME SNARK-LISP::TIME-INCLUDED)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK-LISP::TIME-EXCLUDED SNARK-LISP::RUN-TIME)
; --> SETQ THE 
; ==>
;   (+ SNARK-LISP::RUN-TIME SNARK-LISP::TIME-EXCLUDED)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DECF SNARK-LISP::TOTAL-TICKS SNARK-LISP::TIME-EXCLUDED)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (/ SNARK-LISP::RUN-TIME (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

;     (- SNARK-LISP::TOTAL-TICKS SNARK-LISP::TIME-INCLUDED)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ SNARK-LISP::OTHER-TIME (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

;     (/ SNARK-LISP::TOTAL-TICKS (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

;     (- (GET-INTERNAL-REAL-TIME) SNARK-LISP::*FIRST-REAL-TIME-VALUE*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN TOTAL-RUN-TIME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.lisp
; in: DEFUN TOTAL-RUN-TIME
;     (/ SNARK-LISP::TOTAL-TICKS (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to convert to multiplication by reciprocal due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.

;     (MEMBER SNARK-LISP::CLK SNARK-LISP::EXCLUDED-CLOCKS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (- (GET-INTERNAL-RUN-TIME) SNARK-LISP::*FIRST-RUN-TIME-VALUE*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DECF SNARK-LISP::TOTAL-TICKS (SYMBOL-VALUE SNARK-LISP::CLK))
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ SNARK-LISP::TOTAL-TICKS (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

; compiling (DEFUN PRINT-INCREMENTAL-TIME-USED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.lisp
; in: DEFUN PRINT-INCREMENTAL-TIME-USED
;     (- TIME SNARK-LISP::*RUN-TIME-MARK*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/clocks.fasl written
; compilation finished in 0:00:00.052
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFSTRUCT (COUNTER # ...) ...)
; compiling (DEFUN INCREMENT-COUNTER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN INCREMENT-COUNTER
;     (INCF (SNARK-LISP::COUNTER-INCREMENTS SNARK-LISP::COUNTER) SNARK-LISP::N)
; --> LET* 
; ==>
;   (+ SNARK-LISP::N
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-LISP::COUNTER #:OBJ) 1)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN DECREMENT-COUNTER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN DECREMENT-COUNTER
;     (- (SNARK-LISP::COUNTER-INCREMENTS SNARK-LISP::COUNTER) SNARK-LISP::D)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (> SNARK-LISP::V
;        (SNARK-LISP::COUNTER-PREVIOUS-PEAK-VALUE SNARK-LISP::COUNTER))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (+ SNARK-LISP::D SNARK-LISP::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN COUNTER-VALUE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN COUNTER-VALUE
;     (- (SNARK-LISP::COUNTER-INCREMENTS SNARK-LISP::COUNTER)
;        (SNARK-LISP::COUNTER-DECREMENTS SNARK-LISP::COUNTER))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN COUNTER-VALUES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN COUNTER-VALUES
;     (- SNARK-LISP::I SNARK-LISP::D)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (MAX SNARK-LISP::V
;          (SNARK-LISP::COUNTER-PREVIOUS-PEAK-VALUE SNARK-LISP::COUNTER))
; --> LET LET IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFINLINE SHOW-COUNT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFINLINE SHOW-COUNT-P
;     (REM SNARK-LISP::N SNARK-LISP::V)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

;     (>= SNARK-LISP::N SNARK-LISP::V)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; compiling (DEFUN SHOW-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN SHOW-COUNT
;     (TRUNCATE SNARK-LISP::N 1000000)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).

;     (TRUNCATE SNARK-LISP::N 1000)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).

; compiling (DEFUN SHOW-COUNT0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN SHOW-COUNT0
;     (SNARK-LISP::SHOW-COUNT-P SNARK-LISP::N)
; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF RETURN RETURN-FROM EQL IF EQL REM NTH-VALUE MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; compiling (DEFUN SHOW-COUNT1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.lisp
; in: DEFUN SHOW-COUNT1
;     (SNARK-LISP::SHOW-COUNT-P SNARK-LISP::N)
; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF RETURN RETURN-FROM EQL IF EQL REM NTH-VALUE MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-LISP::N) (DOLIST (SNARK-LISP::V (QUOTE (1000000 100000 10000 1000 100 10)) T) (WHEN (>= SNARK-LISP::N SNARK-LISP::V) (RETURN (EQL 0 (REM SNARK-LISP::N SNARK-LISP::V)))))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

; compiling (DEFMACRO PRINCF ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/counters.fasl written
; compilation finished in 0:00:00.039
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/pattern-match.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN PATTERN-MATCH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/pattern-match.lisp
; in: DEFUN PATTERN-MATCH
;     (EQL SNARK-LISP::PAT SNARK-LISP::EXPR)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/pattern-match.fasl written
; compilation finished in 0:00:00.006
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-LISP)
; compiling (DEFUN TOPOLOGICAL-SORT* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.lisp
; in: DEFUN TOPOLOGICAL-SORT*
;     (FUNCALL SNARK-LISP::MAP-PREDECESSORS #'SNARK-LISP::DFS-VISIT SNARK-LISP::V
;              SNARK-LISP::ITEMS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::MAP-PREDECESSORS)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TOPOLOGICAL-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.lisp
; in: DEFUN TOPOLOGICAL-SORT
;     (FUNCALL SNARK-LISP::MUST-PRECEDE-PREDICATE SNARK-LISP::U SNARK-LISP::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::MUST-PRECEDE-PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-LISP::CC SNARK-LISP::U)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:NEQL SNARK-LISP::U SNARK-LISP::V)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/topological-sort.fasl written
; compilation finished in 0:00:00.007
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-DEQUE)
; compiling (DEFSTRUCT (DEQUE #) ...)
; compiling (DEFUN DEQUE-EMPTY? ...)
; compiling (DEFUN DEQUE-FIRST ...)
; compiling (DEFUN DEQUE-LAST ...)
; compiling (DEFUN DEQUE-REST ...)
; compiling (DEFUN DEQUE-BUTLAST ...)
; compiling (DEFUN DEQUE-POP-FIRST ...)
; compiling (DEFUN DEQUE-POP-LAST ...)
; compiling (DEFUN DEQUE-ADD-FIRST ...)
; compiling (DEFUN DEQUE-ADD-LAST ...)
; compiling (DEFUN DEQUE-PUSH-FIRST ...)
; compiling (DEFUN DEQUE-PUSH-LAST ...)
; compiling (DEFUN DEQUE-LENGTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp
; in: DEFUN DEQUE-LENGTH
;     (DEFUN SNARK-DEQUE:DEQUE-LENGTH (SNARK-DEQUE::DEQUE)
;       (+ (LENGTH (SNARK-DEQUE::DEQUE-FRONT SNARK-DEQUE::DEQUE))
;          (LENGTH (SNARK-DEQUE::DEQUE-REAR SNARK-DEQUE::DEQUE))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK-DEQUE:DEQUE-LENGTH
;         (SNARK-DEQUE::DEQUE)
;       (BLOCK SNARK-DEQUE:DEQUE-LENGTH
;         (+ (LENGTH (SNARK-DEQUE::DEQUE-FRONT SNARK-DEQUE::DEQUE))
;            (LENGTH (SNARK-DEQUE::DEQUE-REAR SNARK-DEQUE::DEQUE)))))
; 
; note: doing signed word to integer coercion (cost 20) to "<return value>"

; compiling (DEFUN DEQUE-DELETE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp
; in: DEFUN DEQUE-DELETE
;     (EQL SNARK-DEQUE::ITEM (FIRST SNARK-DEQUE::FRONT))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-DEQUE::ITEM (FIRST SNARK-DEQUE::REAR))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-DEQUE::ITEM (SECOND SNARK-DEQUE::L))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN DEQUE-DELETE-IF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp
; in: DEFUN DEQUE-DELETE-IF
;     (FUNCALL FUNCTION SNARK-DEQUE::ITEM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAPNCONC-DEQUE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.lisp
; in: DEFUN MAPNCONC-DEQUE
;     (FUNCALL FUNCTION SNARK-DEQUE::ITEM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/deque2.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFTYPE SPARSE-VECTOR-INDEX ...)
; compiling (DEFTYPE SPARSE-VECTOR-COUNT ...)
; compiling (DEFSTRUCT (SPARSE-VECTOR # ...) ...)
; compiling (DEFUN MAKE-SPARSE-VECTOR ...)
; compiling (DEFINLINE SPARSE-VECTOR-BOOLEAN ...)
; compiling (DEFINLINE SPARSE-VECTOR-DEFAULT-VALUE ...)
; compiling (DEFINLINE SPARSE-VECTOR-COUNT ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE-1 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2+1 ...)
; compiling (DEFCONSTANT B-TREE-NODE-SIZE/2-1 ...)
; compiling (DEFMACRO MAKE-B-TREE-NODE ...)
; compiling (DEFMACRO B-TREE-NODE-ALIST ...)
; compiling (DEFMACRO B-TREE-NODE-NONLEAF-LAST-VALUE ...)
; compiling (DEFINLINE B-TREE-NONLEAF-NODE-ALIST-SEARCH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFINLINE B-TREE-NONLEAF-NODE-ALIST-SEARCH
;     (>= SNARK-SPARSE-ARRAY::INDEX
;         (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;              (SNARK-LISP:CARC (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::ALIST))))
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFINLINE LASTC ...)
; compiling (DEFINLINE SMALLEST-KEY ...)
; compiling (DEFINLINE LARGEST-KEY ...)
; compiling (DEFINLINE B-TREE-NODE-SMALLEST-KEY* ...)
; compiling (DEFINLINE B-TREE-NODE-LARGEST-KEY* ...)
; compiling (DEFUN NESTN ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN NESTN
;     (DOTIMES (SNARK-SPARSE-ARRAY::I SNARK-SPARSE-ARRAY::N)
;       (SETF SNARK-SPARSE-ARRAY::Y
;               (SUBST SNARK-SPARSE-ARRAY::Y '*** SNARK-SPARSE-ARRAY::X)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-SPARSE-ARRAY::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMACRO UNROLL-SPAREF1-LEAF ...)
; compiling (DEFMACRO UNROLL-SPAREF1-NONLEAF ...)
; compiling (DEFMACRO UNROLL-FULL-ALIST ...)
; compiling (DEFINLINE FULL-ALIST ...)
; compiling (DEFUN SPAREF1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN SPAREF1
;     (=
;      (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-CACHED-KEY
;       SNARK-SPARSE-ARRAY:SPARSE-VECTOR)
;      SNARK-SPARSE-ARRAY::INDEX)
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK-SPARSE-ARRAY::UNROLL-SPAREF1-LEAF)
; --> LET IF LET IF COND IF OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= 
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR 
; --> THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR 
; --> LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= 
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF 
; --> OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR 
; --> LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND THE 
; --> PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = 
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER 
; --> IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL 
; --> IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER 
; --> IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= 
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR 
; --> THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR 
; --> LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF OR THE >= 
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR LET IF 
; --> OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN OR 
; --> LET IF OR THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND THE 
; --> PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = 
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER 
; --> IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF 
; --> PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL 
; --> IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF COND IF PROGN = EQL IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER 
; --> IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET IF LET IF COND IF PROGN = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK-SPARSE-ARRAY::UNROLL-SPAREF1-NONLEAF)
; --> LET* COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LET* COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND IF COND 
; --> IF COND IF COND IF COND IF COND IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFMACRO SPAREF ...)
; compiling (DEFUN SPARSE-VECTOR-SETTER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN SPARSE-VECTOR-SETTER
;     (+ (SNARK-SPARSE-ARRAY::LARGEST-KEY SNARK-SPARSE-ARRAY::ALIST1) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FLOOR
;      (+ (SNARK-SPARSE-ARRAY::SMALLEST-KEY SNARK-SPARSE-ARRAY::ALIST2)
;         (+ (SNARK-SPARSE-ARRAY::LARGEST-KEY SNARK-SPARSE-ARRAY::ALIST1) 1))
;      2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-2) (2)) (DOUBLE-FLOAT -2.0d0 2.0d0) (SINGLE-FLOAT -2.0 2.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (LABELS ((SNARK-SPARSE-ARRAY::SPLIT-LEAF-ALIST (LIST SNARK-SPARSE-ARRAY::NUM)
;                (DECLARE (TYPE FIXNUM SNARK-SPARSE-ARRAY::NUM))
;                (LET (REST)
;                  (LABELS #
;                    #)))
;              (SNARK-SPARSE-ARRAY::SPLIT-NONLEAF-ALIST
;                  (LIST SNARK-SPARSE-ARRAY::NUM)
;                (DECLARE (TYPE FIXNUM SNARK-SPARSE-ARRAY::NUM))
;                (LET (SNARK-SPARSE-ARRAY::K SNARK-SPARSE-ARRAY::V REST)
;                  (LABELS #
;                    #)))
;              (SNARK-SPARSE-ARRAY::LIST-UPDATE
;                  (LIST SNARK-SPARSE-ARRAY::INDEX SNARK-SPARSE-ARRAY::VALUE)
;                (DECLARE
;                 (TYPE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;                  SNARK-SPARSE-ARRAY::INDEX))
;                (LET (#)
;                  (LABELS #
;                    #)))
;              (SNARK-SPARSE-ARRAY::ALIST-UPDATE
;                  (SNARK-SPARSE-ARRAY::ALIST SNARK-SPARSE-ARRAY::INDEX
;                   SNARK-SPARSE-ARRAY::VALUE SNARK-SPARSE-ARRAY::DEFAULT-VALUE)
;                (DECLARE
;                 (TYPE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;                  SNARK-SPARSE-ARRAY::INDEX))
;                (LET (#)
;                  (LABELS #
;                    #)))
;              (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-SETTER1 (SNARK-SPARSE-ARRAY::N)
;                (LET (# #)
;                  (COND # #))))
;       (SNARK-LISP:MVLET (((VALUES SNARK-SPARSE-ARRAY::N1 SNARK-SPARSE-ARRAY::N2
;                                   SNARK-SPARSE-ARRAY::K2)
;                           (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-SETTER1
;                            SNARK-SPARSE-ARRAY::N)))
;         (COND ((EQ SNARK-SPARSE-ARRAY::N SNARK-SPARSE-ARRAY::N1))
;               ((EQ :DELETE SNARK-SPARSE-ARRAY::N1) (SETF #))
;               (SNARK-SPARSE-ARRAY::N2 (SETF #)) (T (SETF #)))))
; 
; note: Return type not fixed values, so can't use known return convention:
;   (VALUES T &OPTIONAL CONS T)

;     (>= SNARK-SPARSE-ARRAY::INDEX SNARK-SPARSE-ARRAY::K)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (= SNARK-SPARSE-ARRAY::INDEX SNARK-SPARSE-ARRAY::K)
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (>= SNARK-SPARSE-ARRAY::INDEX SNARK-SPARSE-ARRAY::K)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (= SNARK-SPARSE-ARRAY::INDEX SNARK-SPARSE-ARRAY::K)
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL SNARK-SPARSE-ARRAY::DEFAULT-VALUE SNARK-SPARSE-ARRAY::VALUE)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-SPARSE-ARRAY::VALUE (SNARK-LISP:CDRC SNARK-SPARSE-ARRAY::P))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-SPARSE-ARRAY::DEFAULT-VALUE SNARK-SPARSE-ARRAY::VALUE)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (+ (SNARK-SPARSE-ARRAY::LARGEST-KEY SNARK-SPARSE-ARRAY::ALIST1) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (SNARK-SPARSE-ARRAY::SMALLEST-KEY SNARK-SPARSE-ARRAY::ALIST2)
;        (+ (SNARK-SPARSE-ARRAY::LARGEST-KEY SNARK-SPARSE-ARRAY::ALIST1) 1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (FLOOR
;      (+ (SNARK-SPARSE-ARRAY::SMALLEST-KEY SNARK-SPARSE-ARRAY::ALIST2)
;         (+ (SNARK-SPARSE-ARRAY::LARGEST-KEY SNARK-SPARSE-ARRAY::ALIST1) 1))
;      2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-SPARSE-ARRAY::B-TREE-NONLEAF-NODE-ALIST-SEARCH
;      SNARK-SPARSE-ARRAY::ALIST SNARK-SPARSE-ARRAY::INDEX)
; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::ALIST SNARK-SPARSE-ARRAY::INDEX) (DECLARE (TYPE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX SNARK-SPARSE-ARRAY::INDEX)) (LOOP (WHEN (OR (>= SNARK-SPARSE-ARRAY::INDEX (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX #)) (NULL (SETF SNARK-SPARSE-ARRAY::ALIST #))) (RETURN SNARK-SPARSE-ARRAY::ALIST)))) 
; --> SB-C::%FUNCALL LOOP BLOCK TAGBODY PROGN WHEN IF OR LET >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (=
;      (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-CACHED-KEY
;       SNARK-SPARSE-ARRAY:SPARSE-VECTOR)
;      SNARK-SPARSE-ARRAY::INDEX)
; --> EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL
;      (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-CACHED-VALUE
;       SNARK-SPARSE-ARRAY:SPARSE-VECTOR)
;      SNARK-SPARSE-ARRAY::VALUE)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL
;      (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-DEFAULT-VALUE
;       SNARK-SPARSE-ARRAY:SPARSE-VECTOR)
;      SNARK-SPARSE-ARRAY::VALUE)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN COPY-SPARSE-VECTOR ...)
; compiling (DEFINLINE SPACONS ...)
; compiling (DEFMACRO DO-MAP-SPARSE-VECTOR-BACKWARD ...)
; compiling (DEFMACRO DO-MAP-SPARSE-VECTOR-FORWARD ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD NIL NIL NIL NIL)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD NIL NIL NIL :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-INDEXES-ONLY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD-INDEXES-ONLY
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD NIL NIL NIL :INDEXES-ONLY)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD NIL NIL NIL NIL)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD NIL NIL NIL :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-INDEXES-ONLY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD-INDEXES-ONLY
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD NIL NIL NIL :INDEXES-ONLY)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD T T NIL NIL)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET AND 
; --> IF AND THE OR LET < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN LET LOOP BLOCK TAGBODY PROGN COND 
; --> LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-SMALLEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD T T NIL :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET AND 
; --> IF AND THE OR LET < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN LET LOOP BLOCK TAGBODY PROGN COND 
; --> LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-SMALLEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-INDEXES-ONLY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-BACKWARD-BOUNDED-INDEXES-ONLY
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD T T NIL :INDEXES-ONLY)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET AND 
; --> IF AND THE OR LET < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN LET LOOP BLOCK TAGBODY PROGN COND 
; --> LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-SMALLEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD T T NIL NIL)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN COND LET AND IF AND 
; --> THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD T T NIL :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN COND LET AND IF AND 
; --> THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-INDEXES-ONLY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR-FORWARD-BOUNDED-INDEXES-ONLY
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD T T NIL :INDEXES-ONLY)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN COND LET AND IF AND 
; --> THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD NIL NIL T NIL)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD NIL NIL T :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD NIL NIL T NIL)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD NIL NIL T :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD T T T NIL)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET AND 
; --> IF AND THE OR LET < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN LET LOOP BLOCK TAGBODY PROGN COND 
; --> LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-SMALLEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-BACKWARD-BOUNDED-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-BACKWARD T T T :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET AND 
; --> IF AND THE OR LET < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN LET LOOP BLOCK TAGBODY PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN LET LOOP BLOCK TAGBODY PROGN COND 
; --> LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE < IF 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-SMALLEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD T T T NIL)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN COND LET AND IF AND 
; --> THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-BOOLEAN-SPARSE-VECTOR-FORWARD-BOUNDED-WITH-INDEXES
;     (SNARK-SPARSE-ARRAY::DO-MAP-SPARSE-VECTOR-FORWARD T T T :WITH-INDEXES)
; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE 
; --> PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF COND THE PROGN FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF COND THE PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (LABELS ((SNARK-SPARSE-ARRAY::MAP1 (SNARK-SPARSE-ARRAY::N)
;              (LET (# #)
;                (COND # #))))
;     (SNARK-SPARSE-ARRAY::MAP1 SNARK-SPARSE-ARRAY::N)
;     NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND 
; --> IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF 
; --> COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND 
; --> THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN LET WHEN IF PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET AND IF AND THE OR LET > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF PROGN MACROLET LET SNARK-SPARSE-ARRAY::DOMAP1 
; --> PROGN COND LET IF COND IF AND IF AND THE 
; ==>
;   (< (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MAX) SNARK-SPARSE-ARRAY::K)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY*
;            SNARK-SPARSE-ARRAY::LAST-VALUE)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE 
; --> > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN LET WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN LET 
; --> WHEN IF PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN LET WHEN IF PROGN COND 
; --> LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN LET WHEN IF PROGN COND LET AND IF AND 
; --> THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> LABELS BLOCK LET COND IF COND THE PROGN MACROLET LET 
; --> SNARK-SPARSE-ARRAY::DOMAP1 PROGN COND LET AND IF AND THE > IF 
; ==>
;   (> (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX MIN)
;      (THE SNARK-SPARSE-ARRAY::SPARSE-VECTOR-INDEX
;           (SNARK-SPARSE-ARRAY::B-TREE-NODE-LARGEST-KEY* SNARK-SPARSE-ARRAY::V)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN MAP-SPARSE-VECTOR0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.lisp
; in: DEFUN MAP-SPARSE-VECTOR0
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::P)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::P SNARK-SPARSE-ARRAY::P)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::P)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION (SNARK-LISP:CDRC SNARK-SPARSE-ARRAY::P))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION (SNARK-LISP:CDRC SNARK-SPARSE-ARRAY::P)
;              (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION (SNARK-LISP:CARC SNARK-SPARSE-ARRAY::P))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE MAP-SPARSE-VECTOR ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-WITH-INDEXES ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-INDEXES-ONLY ...)
; compiling (DEFUN FIRST-SPAREF ...)
; compiling (DEFUN LAST-SPAREF ...)
; compiling (DEFUN POP-FIRST-SPAREF ...)
; compiling (DEFUN POP-LAST-SPAREF ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector5.fasl written
; compilation finished in 0:00:01.553
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFSTRUCT (SPARSE-MATRIX # ...) ...)
; compiling (DEFUN MAKE-SPARSE-MATRIX ...)
; compiling (DEFUN SPARSE-MATRIX-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp
; in: DEFUN SPARSE-MATRIX-COUNT
;     (INCF SNARK-SPARSE-ARRAY::N
;           (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK-SPARSE-ARRAY::V))
; --> SETQ THE 
; ==>
;   (+ (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK-SPARSE-ARRAY::V)
;      SNARK-SPARSE-ARRAY::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN SPAREF2 ...)
; compiling (DEFUN SPARSE-MATRIX-ROW ...)
; compiling (DEFUN (SETF SPARSE-MATRIX-ROW) ...)
; compiling (DEFUN SPARSE-MATRIX-COLUMN ...)
; compiling (DEFUN (SETF SPARSE-MATRIX-COLUMN) ...)
; compiling (DEFUN ADD-SPARSE-MATRIX-ROW-OR-COLUMN ...)
; compiling (DEFUN DELETE-SPARSE-MATRIX-ROW-OR-COLUMN ...)
; compiling (DEFUN (SETF SPAREF1) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp
; in: DEFUN (SETF SPAREF1)
;     (EQL
;      (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-DEFAULT-VALUE SNARK-SPARSE-ARRAY::VALUE)
;      (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-DEFAULT-VALUE SNARK-SPARSE-ARRAY::MATRIX))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-SPARSE-ARRAY::VALUE
;          (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-DEFAULT-VALUE
;           SNARK-SPARSE-ARRAY:SPARSE-VECTOR))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN (SETF SPAREF2) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp
; in: DEFUN (SETF SPAREF2)
;     (EQL SNARK-SPARSE-ARRAY::VALUE
;          (SNARK-SPARSE-ARRAY:SPARSE-MATRIX-DEFAULT-VALUE
;           SNARK-SPARSE-ARRAY:SPARSE-MATRIX))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-SPARSE-MATRIX ...)
; compiling (DEFUN MAP-SPARSE-MATRIX-WITH-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp
; in: DEFUN MAP-SPARSE-MATRIX-WITH-INDEXES
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::VALUE SNARK-SPARSE-ARRAY::ROW-INDEX
;              SNARK-SPARSE-ARRAY::COL-INDEX)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-SPARSE-MATRIX-INDEXES-ONLY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.lisp
; in: DEFUN MAP-SPARSE-MATRIX-INDEXES-ONLY
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::ROW-INDEX SNARK-SPARSE-ARRAY::COL-INDEX)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PRINT-SPARSE-VECTOR3 ...)
; compiling (DEFUN PRINT-SPARSE-MATRIX3 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-array.fasl written
; compilation finished in 0:00:00.060
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-SPARSE-ARRAY)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFINLINE MEM-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFUN MEM-SPARSE-VECTOR-EXPRESSION1 ...)
; compiling (DEFMACRO MAP-SPARSE-VECTOR-EXPRESSION-MACRO ...)
; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES0
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V
;              SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::FILTER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-MACRO
;      (IF (NULL SNARK-SPARSE-ARRAY::FILTER)
;          (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES FUNCTION
;                                                             SNARK-SPARSE-ARRAY::EXPR
;                                                             :REVERSE REVERSE)
;          (SNARK-LISP:PROG->
;            (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;             SNARK-SPARSE-ARRAY::EXPR :REVERSE REVERSE SNARK-SPARSE-ARRAY::->*
;             SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
;            (WHEN
;                (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V
;                         SNARK-SPARSE-ARRAY::K)
;              (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K))))
;      (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES0
;       SNARK-SPARSE-ARRAY::E1 REVERSE SNARK-SPARSE-ARRAY::FILTER
;       SNARK-SPARSE-ARRAY::->* SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
;      (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K))
; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY0
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::FILTER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-MACRO
;      (IF (NULL SNARK-SPARSE-ARRAY::FILTER)
;          (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-INDEXES-ONLY FUNCTION
;                                                             SNARK-SPARSE-ARRAY::EXPR
;                                                             :REVERSE REVERSE)
;          (SNARK-LISP:PROG->
;            (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-INDEXES-ONLY
;             SNARK-SPARSE-ARRAY::EXPR :REVERSE REVERSE SNARK-SPARSE-ARRAY::->*
;             SNARK-SPARSE-ARRAY::K)
;            (WHEN (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::K)
;              (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::K))))
;      (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY0
;       SNARK-SPARSE-ARRAY::E1 REVERSE SNARK-SPARSE-ARRAY::FILTER
;       SNARK-SPARSE-ARRAY::->* SNARK-SPARSE-ARRAY::K)
;      (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::K))
; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN MAP-SPARSE-VECTOR-EXPRESSION0
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::FILTER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-MACRO
;      (IF (NULL SNARK-SPARSE-ARRAY::FILTER)
;          (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR FUNCTION SNARK-SPARSE-ARRAY::EXPR
;                                                :REVERSE REVERSE)
;          (SNARK-LISP:PROG->
;            (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR SNARK-SPARSE-ARRAY::EXPR
;                                                  :REVERSE REVERSE
;                                                  SNARK-SPARSE-ARRAY::->*
;                                                  SNARK-SPARSE-ARRAY::V)
;            (WHEN (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V)
;              (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V))))
;      (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-VALUES2
;       SNARK-SPARSE-ARRAY::E1 REVERSE SNARK-SPARSE-ARRAY::FILTER
;       SNARK-SPARSE-ARRAY::->* SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
;      (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V))
; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN MAP-SPARSE-VECTOR-EXPRESSION-VALUES2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN MAP-SPARSE-VECTOR-EXPRESSION-VALUES2
;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::FILTER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-MACRO
;      (IF (NULL SNARK-SPARSE-ARRAY::FILTER)
;          (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES FUNCTION
;                                                             SNARK-SPARSE-ARRAY::EXPR
;                                                             :REVERSE REVERSE)
;          (SNARK-LISP:PROG->
;            (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;             SNARK-SPARSE-ARRAY::EXPR :REVERSE REVERSE SNARK-SPARSE-ARRAY::->*
;             SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
;            (WHEN (FUNCALL SNARK-SPARSE-ARRAY::FILTER SNARK-SPARSE-ARRAY::V)
;              (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K))))
;      (SNARK-SPARSE-ARRAY::MAP-SPARSE-VECTOR-EXPRESSION-VALUES2
;       SNARK-SPARSE-ARRAY::E1 REVERSE SNARK-SPARSE-ARRAY::FILTER
;       SNARK-SPARSE-ARRAY::->* SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K)
;      (FUNCALL FUNCTION SNARK-SPARSE-ARRAY::V SNARK-SPARSE-ARRAY::K))
; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF <= OR LET IF OR 
; --> THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF 
; --> SNARK-LISP:IMPLIES IF AND IF AND THE SNARK-LISP:PROG-> BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION AND IF AND IF AND THE >= 
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF >= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET <= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF <= OR LET IF OR THE = 
; --> IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> COND IF COND THE PROGN ECASE LET COND IF PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET LET LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION WHEN IF LET 
; --> FLET BLOCK WHEN IF SNARK-LISP:IMPLIES IF IF AND IF AND THE OR LET >= OR 
; --> LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION-WITH-INDEXES ...)
; compiling (DEFINLINE MAP-SPARSE-VECTOR-EXPRESSION-INDEXES-ONLY ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN SPARSE-VECTOR-EXPRESSION-SIZE
;     (INCF SNARK-SPARSE-ARRAY::SIZE
;           (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-EXPRESSION-SIZE
;            SNARK-SPARSE-ARRAY::E))
; --> SETQ THE 
; ==>
;   (+ (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-EXPRESSION-SIZE SNARK-SPARSE-ARRAY::E)
;      SNARK-SPARSE-ARRAY::SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-MAXCOUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;     (< SNARK-SPARSE-ARRAY::N COUNT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (INCF COUNT
;           (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;            SNARK-SPARSE-ARRAY::E))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-SPARSE-ARRAY::SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;     SNARK-SPARSE-ARRAY::E)
;    COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN OPTIMIZED-SPARSE-VECTOR-EXPRESSION-MAXCOUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN OPTIMIZED-SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;     (INCF COUNT
;           (SNARK-SPARSE-ARRAY::OPTIMIZED-SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;            SNARK-SPARSE-ARRAY::E))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-SPARSE-ARRAY::OPTIMIZED-SPARSE-VECTOR-EXPRESSION-MAXCOUNT
;     SNARK-SPARSE-ARRAY::E)
;    COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-INDEX-BOUNDS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN SPARSE-VECTOR-EXPRESSION-INDEX-BOUNDS
;     (> MIN SNARK-SPARSE-ARRAY::M)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< MAX SNARK-SPARSE-ARRAY::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< MIN SNARK-SPARSE-ARRAY::M)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> MAX SNARK-SPARSE-ARRAY::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< MIN SNARK-SPARSE-ARRAY::M)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (> MAX SNARK-SPARSE-ARRAY::N)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (> MIN SNARK-SPARSE-ARRAY::M)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< MAX SNARK-SPARSE-ARRAY::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-GENERATES-IN-ORDER-P ...)
; compiling (DEFUN EQUAL-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFUN EQUAL-OPTIMIZED-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFINLINE OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFINLINE OPTIMIZE-AND-SORT-SHORT-LISTS-OF-SPARSE-VECTOR-EXPRESSIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in:
;      DEFINLINE OPTIMIZE-AND-SORT-SHORT-LISTS-OF-SPARSE-VECTOR-EXPRESSIONS
;     (FUNCALL SNARK-SPARSE-ARRAY::PREDICATE SNARK-SPARSE-ARRAY::N2
;              SNARK-SPARSE-ARRAY::N1)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::PREDICATE SNARK-SPARSE-ARRAY::N3
;              SNARK-SPARSE-ARRAY::N2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::PREDICATE SNARK-SPARSE-ARRAY::N3
;              SNARK-SPARSE-ARRAY::N1)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::PREDICATE SNARK-SPARSE-ARRAY::N3
;              SNARK-SPARSE-ARRAY::N2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-SPARSE-ARRAY::PREDICATE SNARK-SPARSE-ARRAY::N3
;              SNARK-SPARSE-ARRAY::N1)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN OPTIMIZE-SPARSE-VECTOR-EXPRESSION1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.lisp
; in: DEFUN OPTIMIZE-SPARSE-VECTOR-EXPRESSION1
;     (SNARK-SPARSE-ARRAY::OPTIMIZE-AND-SORT-SHORT-LISTS-OF-SPARSE-VECTOR-EXPRESSIONS
;      SNARK-SPARSE-ARRAY::ARGS SNARK-SPARSE-ARRAY::PREDICATE)
; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF LET* COND IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF IF LET* COND IF FUNCALL SB-C::%FUNCALL 
; --> THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF IF LET* COND IF PROGN COND IF FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF IF LET* COND IF PROGN COND IF COND IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF IF LET* COND IF COND IF FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> 
; --> (LAMBDA (SNARK-SPARSE-ARRAY::L1 SNARK-SPARSE-ARRAY::PREDICATE) (IF (NULL SNARK-SPARSE-ARRAY::L1) T (LET ((SNARK-SPARSE-ARRAY::L2 (REST SNARK-SPARSE-ARRAY::L1))) (IF (NULL SNARK-SPARSE-ARRAY::L2) T (LET (#) (IF # # #)))))) 
; --> SB-C::%FUNCALL IF LET IF LET IF IF LET* COND IF COND IF PROGN COND IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-SPARSE-ARRAY::PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DELETE-IF
;      (LAMBDA (SNARK-SPARSE-ARRAY::ARG)
;        (AND (CONSP SNARK-SPARSE-ARRAY::ARG) (NOT (SNARK-LISP:IFF # #))
;             (DOLIST (SNARK-SPARSE-ARRAY::X SNARK-SPARSE-ARRAY::ARGS)
;               (COND # #))))
;      SNARK-SPARSE-ARRAY::ARGS)
; 
; note: unable to open code due to type uncertainty: The second argument is a SEQUENCE, not a LIST.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sparse-vector-expression.fasl written
; compilation finished in 0:00:00.236
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-NUMBERING)
; compiling (DEFVAR *NONCE* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *STANDARD-EQL-NUMBERING*)
; compiling (DEFINLINE NONCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.lisp
; in: DEFINLINE NONCE
;     (INCF SNARK-NUMBERING::*NONCE*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INITIALIZE-NUMBERINGS ...)
; compiling (DEFUN MAKE-NUMBERING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.lisp
; in: DEFUN MAKE-NUMBERING
;     (SNARK-NUMBERING:NONCE)
; --> (LAMBDA NIL (INCF SNARK-NUMBERING::*NONCE*)) SB-C::%FUNCALL INCF SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/numbering.fasl written
; compilation finished in 0:00:00.017
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-AGENDA)
; compiling (DEFSTRUCT (AGENDA # ...) ...)
; compiling (DEFUN FIND-AGENDA-BUCKET ...)
; compiling (DEFUN FIRST-OR-LAST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFINLINE FIRST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFINLINE LAST-NONEMPTY-AGENDA-BUCKET ...)
; compiling (DEFUN COLLECT-AGENDA-BUCKETS ...)
; compiling (DEFUN AGENDA-INSERT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN AGENDA-INSERT
;     (FUNCALL (SNARK-AGENDA::AGENDA-SAME-ITEM-P SNARK-AGENDA::AGENDA)
;              SNARK-AGENDA::ITEM
;              (IF SNARK-AGENDA::AT-FRONT
;                  (SNARK-DEQUE:DEQUE-FIRST SNARK-AGENDA::Q)
;                  (SNARK-DEQUE:DEQUE-LAST SNARK-AGENDA::Q)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SNARK-AGENDA::AGENDA-SAME-ITEM-P SNARK-AGENDA::AGENDA))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL
;      (SNARK-AGENDA::AGENDA-LENGTH-LIMIT-DELETION-ACTION SNARK-AGENDA::AGENDA)
;      SNARK-AGENDA::DELETED-ITEM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SNARK-AGENDA::AGENDA-LENGTH-LIMIT-DELETION-ACTION SNARK-AGENDA::AGENDA))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (+ LENGTH 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (<= SNARK-AGENDA::LIMIT LENGTH)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (EQL SNARK-AGENDA::ITEM SNARK-AGENDA::DELETED-ITEM)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (+ LENGTH 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN AGENDA-DELETE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN AGENDA-DELETE
;     (- LENGTH 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN AGENDA-FIRST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN AGENDA-FIRST
;     (- LENGTH 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN POP-AGENDA ...)
; compiling (DEFUN MAP-AGENDA-BUCKETS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN MAP-AGENDA-BUCKETS
;     (FUNCALL FUNCTION SNARK-AGENDA::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAPNCONC-AGENDA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN MAPNCONC-AGENDA
;     (FUNCALL FUNCTION SNARK-AGENDA::ITEM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN AGENDA-DELETE-IF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN AGENDA-DELETE-IF
;     (FUNCALL FUNCTION SNARK-AGENDA::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-AGENDA::DELETION-ACTION SNARK-AGENDA::V)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-AGENDA::DELETION-ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DECF (SNARK-AGENDA:AGENDA-LENGTH SNARK-AGENDA::AGENDA))
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN LIMIT-AGENDA-LENGTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN LIMIT-AGENDA-LENGTH
;     (< SNARK-AGENDA::LIMIT LENGTH)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (INCF SNARK-AGENDA::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-AGENDA::I)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (> (INCF SNARK-AGENDA::I) SNARK-AGENDA::LIMIT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (INCF SNARK-AGENDA::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-AGENDA::I)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> (INCF SNARK-AGENDA::I) SNARK-AGENDA::LIMIT)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK-AGENDA::LIMIT LENGTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFVAR *AGENDA*)
; compiling (DEFUN PRINT-AGENDA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN PRINT-AGENDA
;     (NBUTLAST (NTHCDR SNARK-AGENDA::K1 SNARK-AGENDA::BUCKETS)
;               (- SNARK-AGENDA::K SNARK-AGENDA::K1 SNARK-AGENDA::K2))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN PRINT-AGENDA3 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.lisp
; in: DEFUN PRINT-AGENDA3
;     (FORMAT STREAM "~S" (SNARK-AGENDA:AGENDA-NAME SNARK-AGENDA::AGENDA))
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM #:FORMAT-ARG532 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (PRIN1 #:FORMAT-ARG532 STREAM))
;             NIL)
;           #:G531)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/agenda.fasl written
; compilation finished in 0:00:00.077
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-INFIX-READER)
; compiling (DEFVAR *INFIX-OPERATORS* ...)
; compiling (DEFVAR *PREFIX-OPERATORS* ...)
; compiling (DEFVAR *POSTFIX-OPERATORS* ...)
; compiling (DEFPARAMETER INFIX-TYPES ...)
; compiling (DEFPARAMETER PREFIX-TYPES ...)
; compiling (DEFPARAMETER POSTFIX-TYPES ...)
; compiling (DEFSTRUCT (OPERATOR #) ...)
; compiling (DEFINLINE INFIX-OPERATOR-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE INFIX-OPERATOR-P
;     (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP)
;             SNARK-INFIX-READER::INFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFINLINE PREFIX-OPERATOR-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE PREFIX-OPERATOR-P
;     (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP)
;             SNARK-INFIX-READER::PREFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFINLINE POSTFIX-OPERATOR-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE POSTFIX-OPERATOR-P
;     (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP)
;             SNARK-INFIX-READER::POSTFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN INITIALIZE-OPERATOR-SYNTAX ...)
; compiling (DEFINLINE OPERATOR-LOOKUP0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE OPERATOR-LOOKUP0
;     (STRING= SNARK-INFIX-READER::INPUT-STRING
;              (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFINLINE INFIX-OPERATOR-LOOKUP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE INFIX-OPERATOR-LOOKUP
;     (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING
;                                           SNARK-INFIX-READER::*INFIX-OPERATORS*)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFINLINE PREFIX-OPERATOR-LOOKUP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE PREFIX-OPERATOR-LOOKUP
;     (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING
;                                           SNARK-INFIX-READER::*PREFIX-OPERATORS*)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFINLINE POSTFIX-OPERATOR-LOOKUP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE POSTFIX-OPERATOR-LOOKUP
;     (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING
;                                           SNARK-INFIX-READER::*POSTFIX-OPERATORS*)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFUN UPDATE-OPERATOR-SYNTAX ...)
; compiling (DEFUN DECLARE-OPERATOR-SYNTAX ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFUN DECLARE-OPERATOR-SYNTAX
;     (MEMBER TYPE SNARK-INFIX-READER::INFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER TYPE SNARK-INFIX-READER::PREFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER TYPE SNARK-INFIX-READER::POSTFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (STRING SNARK-INFIX-READER::INPUT-STRING)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (STRING SNARK-INFIX-READER::OUTPUT-SYMBOL)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (MEMBER TYPE SNARK-INFIX-READER::INFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER TYPE SNARK-INFIX-READER::PREFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER TYPE SNARK-INFIX-READER::POSTFIX-TYPES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFINLINE REDUCE-BEFORE? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.lisp
; in: DEFINLINE REDUCE-BEFORE?
;     (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-operators.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-INFIX-READER)
; compiling (DEFINLINE ORDINARY-CHAR-P ...)
; compiling (DEFINLINE SEPARATOR-CHAR-P ...)
; compiling (DEFINLINE WHITESPACE-CHAR-P ...)
; compiling (DEFINLINE QUOTATION-CHAR-P ...)
; compiling (DEFINLINE COMMENT-CHAR-P ...)
; compiling (DEFUN TOKENIZE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.lisp
; in: DEFUN TOKENIZE1
;     (SNARK-INFIX-READER::INFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::NAME)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*INFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (SNARK-INFIX-READER::PREFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::NAME)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*PREFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (SNARK-INFIX-READER::POSTFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::NAME)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*POSTFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (* 10 SNARK-INFIX-READER::EXPONENT)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (- SNARK-INFIX-READER::EXPONENT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-INFIX-READER::EXPONENT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 10 SNARK-INFIX-READER::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 10 SNARK-INFIX-READER::D)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 10 SNARK-INFIX-READER::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 10 SNARK-INFIX-READER::NUM)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (/ SNARK-INFIX-READER::N SNARK-INFIX-READER::D)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (/ SNARK-INFIX-READER::NUM SNARK-INFIX-READER::N)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (EXPT 10 SNARK-INFIX-READER::EXPONENT)
; 
; note: unable to optimize due to type uncertainty: The second argument is a NUMBER, not a INTEGER.
; 
; note: unable to optimize due to type uncertainty: The second argument is a NUMBER, not a UNSIGNED-BYTE.

;     (* SNARK-INFIX-READER::NUM (EXPT 10 SNARK-INFIX-READER::EXPONENT))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (COERCE SNARK-INFIX-READER::CHARS 'STRING)
; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

; --> THE IF REPLACE MAKE-ARRAY LOCALLY MAKE-ARRAY 
; ==>
;   (LENGTH SB-C::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; --> THE IF 
; ==>
;   (REPLACE (MAKE-ARRAY (LENGTH SB-C::X) :ELEMENT-TYPE 'CHARACTER) SB-C::X)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (SIMPLE-ARRAY CHARACTER (*)).
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a SIMPLE-BASE-STRING.

;     (- SNARK-INFIX-READER::V)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-INFIX-READER::V))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 10 SNARK-INFIX-READER::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* 10 SNARK-INFIX-READER::N) SNARK-INFIX-READER::CV)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a (OR (MOD 36) NULL), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a (OR (MOD 36) NULL), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 10 SNARK-INFIX-READER::D)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 10 SNARK-INFIX-READER::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* 10 SNARK-INFIX-READER::N) SNARK-INFIX-READER::CV)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a (OR (MOD 36) NULL), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a (OR (MOD 36) NULL), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 10 SNARK-INFIX-READER::NUM)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a (OR NULL NUMBER), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* 10 SNARK-INFIX-READER::NUM) SNARK-INFIX-READER::CV)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a (OR (MOD 36) NULL), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a (OR (MOD 36) NULL), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 10 SNARK-INFIX-READER::EXPONENT)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a (OR NULL NUMBER), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* 10 SNARK-INFIX-READER::EXPONENT) SNARK-INFIX-READER::CV)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a (OR (MOD 36) NULL), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a (OR (MOD 36) NULL), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (- SNARK-INFIX-READER::EXPONENT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-INFIX-READER::EXPONENT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ SNARK-INFIX-READER::N SNARK-INFIX-READER::D)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK-INFIX-READER::NUM (/ SNARK-INFIX-READER::N SNARK-INFIX-READER::D))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (/ SNARK-INFIX-READER::NUM SNARK-INFIX-READER::N)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a (OR NULL NUMBER), not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK-INFIX-READER::NUM (EXPT 10 SNARK-INFIX-READER::EXPONENT))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a (OR NULL NUMBER), not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (FLOAT SNARK-INFIX-READER::NUM)
; --> IF 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::N)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 64).

;     (- SNARK-INFIX-READER::V)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-INFIX-READER::V))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK-INFIX-READER::UPPER-CASE-VAR-PREFIX
;          (FIRST SNARK-INFIX-READER::CHARS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK-INFIX-READER::UPPER-CASE-VAR-PREFIX SNARK-INFIX-READER::C)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN TOKENIZE ...)
; compiling (DEFUN TOKENS-TO-LISP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.lisp
; in: DEFUN TOKENS-TO-LISP
;     (SNARK-INFIX-READER::REDUCE-BEFORE? (FIRST SNARK-INFIX-READER::STACK)
;                                         SNARK-INFIX-READER::OP)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET < IF 
; ==>
;   (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (SNARK-INFIX-READER::REDUCE-BEFORE? (SECOND SNARK-INFIX-READER::STACK)
;                                         SNARK-INFIX-READER::OP)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET < IF 
; ==>
;   (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (SNARK-INFIX-READER::POSTFIX-OPERATOR-P SNARK-INFIX-READER::TOP)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP) (AND SNARK-INFIX-READER::*POSTFIX-OPERATORS* (SNARK-INFIX-READER::OPERATOR-P SNARK-INFIX-READER::OP) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP) SNARK-INFIX-READER::POSTFIX-TYPES))) 
; --> SB-C::%FUNCALL AND IF AND IF AND THE MEMBER 
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK-INFIX-READER::INFIX-OPERATOR-P SNARK-INFIX-READER::Y)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP) (AND (SNARK-INFIX-READER::OPERATOR-P SNARK-INFIX-READER::OP) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP) SNARK-INFIX-READER::INFIX-TYPES))) 
; --> SB-C::%FUNCALL AND IF AND THE MEMBER 
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK-INFIX-READER::PREFIX-OPERATOR-P SNARK-INFIX-READER::Y)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP) (AND (SNARK-INFIX-READER::OPERATOR-P SNARK-INFIX-READER::OP) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP) SNARK-INFIX-READER::PREFIX-TYPES))) 
; --> SB-C::%FUNCALL AND IF AND THE MEMBER 
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK-INFIX-READER::POSTFIX-OPERATOR-P SNARK-INFIX-READER::X)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP) (AND SNARK-INFIX-READER::*POSTFIX-OPERATORS* (SNARK-INFIX-READER::OPERATOR-P SNARK-INFIX-READER::OP) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP) SNARK-INFIX-READER::POSTFIX-TYPES))) 
; --> SB-C::%FUNCALL AND IF AND IF AND THE MEMBER 
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (STRING= "|"
;              (SNARK-INFIX-READER::OPERATOR-INPUT-STRING
;               SNARK-INFIX-READER::TOKEN1))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (SNARK-INFIX-READER::PREFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::TOKEN1)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*PREFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (SNARK-INFIX-READER::INFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::TOKEN1)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*INFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (SNARK-INFIX-READER::POSTFIX-OPERATOR-LOOKUP SNARK-INFIX-READER::TOKEN1)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING) (SNARK-INFIX-READER::OPERATOR-LOOKUP0 SNARK-INFIX-READER::INPUT-STRING SNARK-INFIX-READER::*POSTFIX-OPERATORS*)) 
; --> SB-C::%FUNCALL SNARK-INFIX-READER::OPERATOR-LOOKUP0 
; --> (LAMBDA (SNARK-INFIX-READER::INPUT-STRING LIST) (DOLIST (SNARK-INFIX-READER::OP LIST NIL) (WHEN (STRING= SNARK-INFIX-READER::INPUT-STRING (SNARK-INFIX-READER::OPERATOR-INPUT-STRING SNARK-INFIX-READER::OP)) (RETURN SNARK-INFIX-READER::OP)))) 
; --> SB-C::%FUNCALL DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY WHEN 
; --> IF STRING= 
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (EQL SNARK-INFIX-READER::TOKEN1 (POP SNARK-INFIX-READER::BRACKETS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-INFIX-READER::REDUCE-BEFORE? (FIRST SNARK-INFIX-READER::STACK)
;                                         SNARK-INFIX-READER::OP)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET < IF 
; ==>
;   (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET IF OR THE AND IF 
; ==>
;   (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-INFIX-READER::REDUCE-BEFORE? (SECOND SNARK-INFIX-READER::STACK)
;                                         SNARK-INFIX-READER::OP)
; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET < IF 
; ==>
;   (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-INFIX-READER::OP1 SNARK-INFIX-READER::OP2) (LET ((SNARK-INFIX-READER::P1 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP1)) (SNARK-INFIX-READER::P2 (SNARK-INFIX-READER::OPERATOR-PRECEDENCE SNARK-INFIX-READER::OP2))) (OR (< SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (AND (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP2) (QUOTE #)) (MEMBER (SNARK-INFIX-READER::OPERATOR-TYPE SNARK-INFIX-READER::OP1) (QUOTE #)))))) 
; --> SB-C::%FUNCALL LET OR LET IF OR THE AND IF 
; ==>
;   (EQL SNARK-INFIX-READER::P1 SNARK-INFIX-READER::P2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN READ-INFIX-TERM ...)
; compiling (DEFUN READ-INFIX-TERMS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/infix-reader.fasl written
; compilation finished in 0:00:00.177
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-FEATURE)
; compiling (DEFVAR *FEATURE-TREE*)
; compiling (DEFSTRUCT (FEATURE-TREE #) ...)
; compiling (DEFSTRUCT (FEATURE # ...) ...)
; compiling (DEFSTRUCT (FEATURE-COMBO # ...) ...)
; compiling (DEFUN INITIALIZE-FEATURES ...)
; compiling (DEFUN MAKE-FEATURE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN MAKE-FEATURE1
;     (+ (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::PARENT) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (+ (SNARK-FEATURE::FEATURE-PREORDER-MAX (FIRST LAST)) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (+ (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::PARENT) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FLOOR (+ SNARK-FEATURE::M SNARK-FEATURE::N) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-2) (2)) (DOUBLE-FLOAT -2.0d0 2.0d0) (SINGLE-FLOAT -2.0 2.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK-FEATURE::M SNARK-FEATURE::N)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (FLOOR (+ SNARK-FEATURE::M SNARK-FEATURE::N) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::PARENT) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::PARENT) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (SNARK-FEATURE::FEATURE-PREORDER-MAX (FIRST LAST)) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= SNARK-FEATURE::M SNARK-FEATURE::N)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ SNARK-FEATURE::M SNARK-FEATURE::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (FLOOR (+ SNARK-FEATURE::M SNARK-FEATURE::N) 2)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-FEATURE ...)
; compiling (DEFUN DECLARE-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN DECLARE-FEATURE
;     (MAKE-SYMBOL (SNARK-LISP:TO-STRING "*" SNARK-FEATURE::NAME "*"))
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-STRING.

; compiling (DEFUN DECLARE-FEATURE-ALIASES ...)
; compiling (DEFUN CHARACTERISTIC-FEATURE-TYPE ...)
; compiling (DEFUN EXTRACT-A-CHARACTERISTIC-FEATURE ...)
; compiling (DEFUN RENAME-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN RENAME-FEATURE
;     (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::V)
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK-FEATURE::V
; 
; note: deleting unreachable code

;     (SETF (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE SNARK-FEATURE::X)
;             (NSUBSTITUTE SNARK-FEATURE::NEW-NAME SNARK-FEATURE::NAME
;                          (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE
;                           SNARK-FEATURE::X)))
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK-FEATURE::X
; 
; note: deleting unreachable code

; compiling (DEFUN DELETE-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN DELETE-FEATURE
;     (DELETE SNARK-FEATURE::CL
;             (SNARK-FEATURE::FEATURE-USERS-IN-CANONICAL-LISTS SNARK-FEATURE::N2)
;             :COUNT 1)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (DELETE SNARK-FEATURE::CL (SNARK-FEATURE::FEATURE-NOGOODS SNARK-FEATURE::N2)
;             :COUNT 1)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (- (FIRST SNARK-FEATURE::INCOMPAT2) 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE FEATURE-DELETED? ...)
; compiling (DEFUN CAN-BE-FEATURE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN CAN-BE-FEATURE-NAME
;     (FUNCALL SNARK-FEATURE::ACTION "~S cannot be the name of a feature."
;              SNARK-FEATURE::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-FEATURE::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN LOOKUP-FEATURE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN LOOKUP-FEATURE-NAME
;     (FUNCALL SNARK-FEATURE::ACTION "There is no feature named ~S."
;              SNARK-FEATURE::NAME)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-FEATURE::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DELETE-FEATURE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN DELETE-FEATURE-NAME
;     (DELETE SNARK-FEATURE::NAME
;             (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE SNARK-FEATURE::X) :COUNT
;             1)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (DELETE SNARK-FEATURE::NAME
;             (SNARK-FEATURE::FEATURE-USERS-IN-NAME-TABLE SNARK-FEATURE::V) :COUNT
;             1)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

; compiling (DEFUN THE-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN THE-FEATURE
;     (FUNCALL SNARK-FEATURE::ACTION2
;              "The conjunction of ~A~{ and ~A~} are incompatible."
;              (FIRST SNARK-FEATURE::X) (REST SNARK-FEATURE::X))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-FEATURE::ACTION2)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN FEATURE-TREE-PREORDER-LABELING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-TREE-PREORDER-LABELING
;     (INCF SNARK-FEATURE::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-FEATURE::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (+ SNARK-FEATURE::N 999)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK-FEATURE::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-FEATURE::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK-FEATURE::N 999)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE FEATURE> ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE>
;     (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2)
;         (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1)
;         (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2))
; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (#:G571 #:G570 #:G569) (DECLARE (TYPE REAL #:G571 #:G570 #:G569)) (IF (>= #:G571 #:G570) (IF (>= #:G570 #:G569) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE>= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE>=
;     (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2)
;         (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1)
;         (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2))
; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (#:G599 #:G598 #:G597) (DECLARE (TYPE REAL #:G599 #:G598 #:G597)) (IF (>= #:G599 #:G598) (IF (>= #:G598 #:G597) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE< ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE<
;     (SNARK-FEATURE::FEATURE> SNARK-FEATURE::N2 SNARK-FEATURE::N1)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (AND (NOT (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2)) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL AND IF AND THE >= 
; --> (LAMBDA (#:G626 #:G625 #:G624) (DECLARE (TYPE REAL #:G626 #:G625 #:G624)) (IF (>= #:G626 #:G625) (IF (>= #:G625 #:G624) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE<= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE<=
;     (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G654 #:G653 #:G652) (DECLARE (TYPE REAL #:G654 #:G653 #:G652)) (IF (>= #:G654 #:G653) (IF (>= #:G653 #:G652) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN FEATURE-ANCESTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-ANCESTOR
;     (DOTIMES (SNARK-FEATURE::I SNARK-FEATURE::N)
;       (DECLARE (IGNORABLE SNARK-FEATURE::I))
;       (SETF SNARK-FEATURE::NODE
;               (SNARK-FEATURE:FEATURE-PARENT SNARK-FEATURE::NODE)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE NEAREST-COMMON-FEATURE-ANCESTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE NEAREST-COMMON-FEATURE-ANCESTOR
;     (> SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (- SNARK-FEATURE::D2 SNARK-FEATURE::D1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-FEATURE::I (- SNARK-FEATURE::D2 SNARK-FEATURE::D1))
;       (DECLARE (IGNORABLE SNARK-FEATURE::I))
;       (LET ((SNARK-FEATURE::INCOMPAT
;              (SNARK-FEATURE::FEATURE-INCOMPATIBLE-FEATURES SNARK-FEATURE::NODE2)))
;         (WHEN SNARK-FEATURE::INCOMPAT
;           (INCF SNARK-FEATURE::NINCOMPAT2 (FIRST SNARK-FEATURE::INCOMPAT))))
;       (SETF SNARK-FEATURE::NODE2
;               (SNARK-FEATURE:FEATURE-PARENT SNARK-FEATURE::NODE2)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (INCF SNARK-FEATURE::NINCOMPAT2 (FIRST SNARK-FEATURE::INCOMPAT))
; --> SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-FEATURE::I (- SNARK-FEATURE::D2 SNARK-FEATURE::D1))
;       (DECLARE (IGNORABLE SNARK-FEATURE::I))
;       (LET ((SNARK-FEATURE::INCOMPAT
;              (SNARK-FEATURE::FEATURE-INCOMPATIBLE-FEATURES SNARK-FEATURE::NODE2)))
;         (WHEN SNARK-FEATURE::INCOMPAT
;           (INCF SNARK-FEATURE::NINCOMPAT2 (FIRST SNARK-FEATURE::INCOMPAT))))
;       (SETF SNARK-FEATURE::NODE2
;               (SNARK-FEATURE:FEATURE-PARENT SNARK-FEATURE::NODE2)))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-FEATURE::I (- SNARK-FEATURE::D1 SNARK-FEATURE::D2))
;       (DECLARE (IGNORABLE SNARK-FEATURE::I))
;       (LET ((SNARK-FEATURE::INCOMPAT
;              (SNARK-FEATURE::FEATURE-INCOMPATIBLE-FEATURES SNARK-FEATURE::NODE1)))
;         (WHEN SNARK-FEATURE::INCOMPAT
;           (INCF SNARK-FEATURE::NINCOMPAT1 (FIRST SNARK-FEATURE::INCOMPAT))))
;       (SETF SNARK-FEATURE::NODE1
;               (SNARK-FEATURE:FEATURE-PARENT SNARK-FEATURE::NODE1)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (INCF SNARK-FEATURE::NINCOMPAT1 (FIRST SNARK-FEATURE::INCOMPAT))
; --> SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-FEATURE::I (- SNARK-FEATURE::D1 SNARK-FEATURE::D2))
;       (DECLARE (IGNORABLE SNARK-FEATURE::I))
;       (LET ((SNARK-FEATURE::INCOMPAT
;              (SNARK-FEATURE::FEATURE-INCOMPATIBLE-FEATURES SNARK-FEATURE::NODE1)))
;         (WHEN SNARK-FEATURE::INCOMPAT
;           (INCF SNARK-FEATURE::NINCOMPAT1 (FIRST SNARK-FEATURE::INCOMPAT))))
;       (SETF SNARK-FEATURE::NODE1
;               (SNARK-FEATURE:FEATURE-PARENT SNARK-FEATURE::NODE1)))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-FEATURE::NINCOMPAT1 (FIRST SNARK-FEATURE::INCOMPAT))
; --> SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK-FEATURE::NINCOMPAT2 (FIRST SNARK-FEATURE::INCOMPAT))
; --> SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN FEATURE-INCOMPATIBLE0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-INCOMPATIBLE0
;     (SNARK-FEATURE::NEAREST-COMMON-FEATURE-ANCESTOR SNARK-FEATURE::S1
;                                                     SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF 
; ==>
;   (> SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF 
; ==>
;   (< SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::Y SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::NEAREST-COMMON-FEATURE-ANCESTOR SNARK-FEATURE::S1
;                                                     SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF 
; ==>
;   (> SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF PROGN DOTIMES DO BLOCK LET 
; ==>
;   (- SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF PROGN DOTIMES DO BLOCK LET TAGBODY UNLESS IF 
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY LET 
; --> WHEN IF INCF SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF PROGN DOTIMES DO BLOCK LET TAGBODY PSETQ PROGN 
; --> SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF 
; ==>
;   (< SNARK-FEATURE::D1 SNARK-FEATURE::D2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF PROGN DOTIMES DO BLOCK LET 
; ==>
;   (- SNARK-FEATURE::D2 SNARK-FEATURE::D1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF PROGN DOTIMES DO BLOCK LET TAGBODY 
; --> UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF PROGN DOTIMES DO BLOCK LET TAGBODY 
; --> TAGBODY LET WHEN IF INCF SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET COND IF COND IF PROGN DOTIMES DO BLOCK LET TAGBODY 
; --> PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::Y SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G751 #:G750 #:G749) (DECLARE (TYPE REAL #:G751 #:G750 #:G749)) (IF (>= #:G751 #:G750) (IF (>= #:G750 #:G749) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::NEAREST-COMMON-FEATURE-ANCESTOR SNARK-FEATURE::S1
;                                                     SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (LET ((SNARK-FEATURE::D1 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE1)) (SNARK-FEATURE::D2 (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE2)) (SNARK-FEATURE::NINCOMPAT1 0) (SNARK-FEATURE::NINCOMPAT2 0)) (COND ((> SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE1 #))) ((< SNARK-FEATURE::D1 SNARK-FEATURE::D2) (DOTIMES (SNARK-FEATURE::I #) (DECLARE #) (LET # #) (SETF SNARK-FEATURE::NODE2 #)))) (LOOP (IF (EQ SNARK-FEATURE::NODE1 SNARK-FEATURE::NODE2) (RETURN (VALUES SNARK-FEATURE::NODE1 SNARK-FEATURE::NINCOMPAT1 SNARK-FEATURE::NINCOMPAT2)) (PROGN (LET # #) (LET # #) (SETF SNARK-FEATURE::NODE1 # SNARK-FEATURE::NODE2 #)))))) 
; --> SB-C::%FUNCALL LET LOOP BLOCK TAGBODY PROGN IF PROGN LET WHEN IF INCF 
; --> SETQ THE 
; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+ (FIRST SNARK-FEATURE::INCOMPAT) SNARK-FEATURE::NINCOMPAT2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFINLINE FEATURE-INCOMPATIBLE1 ...)
; compiling (DEFINLINE FEATURE-INCOMPATIBLE2 ...)
; compiling (DEFUN FEATURE-MERGE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-MERGE1
;     (< SNARK-FEATURE::N1
;        (SNARK-FEATURE::FEATURE-PREORDER-MIN (FIRST SNARK-FEATURE::S2)))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN FEATURE-MERGE2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-MERGE2
;     (< SNARK-FEATURE::N1 SNARK-FEATURE::N2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN FEATURE-SET-DIFFERENCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-SET-DIFFERENCE
;     (MEMBER SNARK-FEATURE::X SNARK-FEATURE::S2 :TEST SNARK-FEATURE::TEST)
; --> SB-KERNEL:%MEMBER-TEST 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE FEATURE-SUBSUMES1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE-SUBSUMES1
;     (<=
;      (SETF SNARK-FEATURE::S2MIN
;              (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S2))
;      SNARK-FEATURE::S1MAX)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK-FEATURE::S1MIN SNARK-FEATURE::S2MIN)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<=
;      (SETF SNARK-FEATURE::S2MIN
;              (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S2))
;      SNARK-FEATURE::S1MAX)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (<= SNARK-FEATURE::S1MIN SNARK-FEATURE::S2MIN)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE-SUBSUMES2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE-SUBSUMES2
;     (SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN FEATURE-SUBSUMES? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-SUBSUMES?
;     (SNARK-FEATURE::FEATURE-SUBSUMES2
;      (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::S1)
;      (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::S2))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1
;                                       (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                        SNARK-FEATURE::S2))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-SUBSUMES2
;      (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::S1)
;      (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::S2))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1
;                                       (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                        SNARK-FEATURE::S2))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1015 #:G1014 #:G1013) (DECLARE (TYPE REAL #:G1015 #:G1014 #:G1013)) (IF (>= #:G1015 #:G1014) (IF (>= #:G1014 #:G1013) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN FEATURE-CANONICAL-LIST-KEY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-CANONICAL-LIST-KEY
;     (LOGXOR SNARK-FEATURE::N
;             (OR (SNARK-FEATURE::FEATURE-CODE SNARK-FEATURE::S)
;                 (SETF (SNARK-FEATURE::FEATURE-CODE SNARK-FEATURE::S)
;                         (RANDOM MOST-POSITIVE-FIXNUM))))
; 
; note: forced to do static-fun Two-arg-xor (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 3) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN FEATURE-CANONICAL-LIST-UNKEY ...)
; compiling (DEFUN FEATURE-CANONIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-CANONIZE
;     (INCF SNARK-FEATURE::LEN)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-FEATURE::LEN)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (> SNARK-FEATURE::N SNARK-FEATURE::M)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ (FIRST SNARK-FEATURE::INCOMPAT1) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (+ (FIRST SNARK-FEATURE::INCOMPAT2) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (<= 3 SNARK-FEATURE::LEN)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-SUBSUMES2 SNARK-FEATURE::NG
;                                       (NREVERSE SNARK-FEATURE::S*))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (INCF SNARK-FEATURE::M
;           (IF (NULL (REST SNARK-FEATURE::NGS))
;               1
;               (LENGTH SNARK-FEATURE::NGS)))
; --> SETQ THE 
; ==>
;   (+
;    (IF (NULL (REST SNARK-FEATURE::NGS))
;        1
;        (LENGTH SNARK-FEATURE::NGS))
;    SNARK-FEATURE::M)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-FEATURE::LEN)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-FEATURE::LEN)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> SNARK-FEATURE::N SNARK-FEATURE::M)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (<= 3 SNARK-FEATURE::LEN)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK-FEATURE::FEATURE-SUBSUMES2 SNARK-FEATURE::NG
;                                       (NREVERSE SNARK-FEATURE::S*))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (AND (SNARK-LISP:LENGTH<= SNARK-FEATURE::S1 SNARK-FEATURE::S2) (DOLIST (SNARK-FEATURE::S1 SNARK-FEATURE::S1 T) (IF (OR (NULL SNARK-FEATURE::S2) (NULL #)) (RETURN NIL) (SETF SNARK-FEATURE::S2 (REST SNARK-FEATURE::S2)))))) 
; --> SB-C::%FUNCALL AND IF AND THE DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY IF OR LET IF OR THE NULL IF SETF SETQ THE 
; --> SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (FIRST SNARK-FEATURE::INCOMPAT1) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (FIRST SNARK-FEATURE::INCOMPAT2) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN CHARACTERISTIC-FEATURE-RESTRICTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN CHARACTERISTIC-FEATURE-RESTRICTION
;     (MEMBER SNARK-FEATURE::N1
;             (SNARK-FEATURE::FEATURE-COMBO-LIST (SECOND SNARK-FEATURE::V)))
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFINLINE FEATURE-UNION0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE-UNION0
;     (< SNARK-FEATURE::MINS1 SNARK-FEATURE::MINS2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (<= SNARK-FEATURE::MINS2
;         (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK-FEATURE::MINS1
;         (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S2))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< SNARK-FEATURE::MINS1 SNARK-FEATURE::MINS2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (<= SNARK-FEATURE::MINS1
;         (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S2))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (<= SNARK-FEATURE::MINS2
;         (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE-UNION1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFINLINE FEATURE-UNION1
;     (SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFINLINE FEATURE-UNION2 ...)
; compiling (DEFUN FEATURE-UNION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-UNION
;     (SNARK-FEATURE::FEATURE-UNION0 SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF 
; ==>
;   (< SNARK-FEATURE::MINS1 SNARK-FEATURE::MINS2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF PROGN COND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF PROGN COND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-UNION1 SNARK-FEATURE::S1
;                                    (IF (CONSP SNARK-FEATURE::S2)
;                                        SNARK-FEATURE::S2
;                                        (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                         SNARK-FEATURE::S2)))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-UNION1 SNARK-FEATURE::S2
;                                    (IF (CONSP SNARK-FEATURE::S1)
;                                        SNARK-FEATURE::S1
;                                        (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                         SNARK-FEATURE::S1)))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE-UNION0 SNARK-FEATURE::S1 SNARK-FEATURE::S2)
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF 
; ==>
;   (< SNARK-FEATURE::MINS1 SNARK-FEATURE::MINS2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF PROGN COND IF <= OR LET 
; --> < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((EQ SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S1) (T (LET ((SNARK-FEATURE::MINS1 #) (SNARK-FEATURE::MINS2 #)) (COND (# #) (T #)))))) 
; --> SB-C::%FUNCALL COND IF COND THE PROGN LET COND IF PROGN COND IF <= OR LET 
; --> IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::FEATURE-UNION1 SNARK-FEATURE::S1
;                                    (IF (CONSP SNARK-FEATURE::S2)
;                                        SNARK-FEATURE::S2
;                                        (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                         SNARK-FEATURE::S2)))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::FEATURE-UNION1 SNARK-FEATURE::S2
;                                    (IF (CONSP SNARK-FEATURE::S1)
;                                        SNARK-FEATURE::S1
;                                        (SNARK-FEATURE::FEATURE-COMBO-LIST
;                                         SNARK-FEATURE::S1)))
; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF NOT IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (COND ((SNARK-FEATURE::FEATURE-SUBSUMES1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) SNARK-FEATURE::S2) ((NULL (SETF SNARK-FEATURE::S2 (REMOVE SNARK-FEATURE::S1 SNARK-FEATURE::S2 :TEST #))) SNARK-FEATURE::S1) ((SNARK-FEATURE::FEATURE-INCOMPATIBLE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2) NIL) (T (SNARK-FEATURE::FEATURE-MERGE1 SNARK-FEATURE::S1 SNARK-FEATURE::S2)))) 
; --> SB-C::%FUNCALL COND IF SNARK-FEATURE::FEATURE-SUBSUMES1 
; --> (LAMBDA (SNARK-FEATURE::S1 SNARK-FEATURE::S2) (LET ((SNARK-FEATURE::S1MIN (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::S1)) (SNARK-FEATURE::S1MAX (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::S1))) (SNARK-LISP:DOTAILS (SNARK-FEATURE::L SNARK-FEATURE::S2 NIL) (LET ((SNARK-FEATURE::S2 #) SNARK-FEATURE::S2MIN) (COND (# #) (# #) (# #)))))) 
; --> SB-C::%FUNCALL LET SNARK-LISP:DOTAILS DO BLOCK LET TAGBODY TAGBODY LET 
; --> COND IF COND IF COND IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN FEATURE-LIVE? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-LIVE?
;     (FUNCALL SNARK-FEATURE::ACTION "Feature ~A has been deleted."
;              SNARK-FEATURE::S)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-FEATURE::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DECLARE-FEATURES-INCOMPATIBLE ...)
; compiling (DEFUN UNTHE-FEATURE ...)
; compiling (DEFUN FEATURE-SYM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN FEATURE-SYM
;     (MAKE-SYMBOL
;      (APPLY 'SNARK-LISP:TO-STRING (SECOND SNARK-FEATURE::EXPR)
;             (MAPCAN #'(LAMBDA (SNARK-FEATURE::X) (LIST "&" SNARK-FEATURE::X))
;                     (SNARK-LISP:RREST SNARK-FEATURE::EXPR))))
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-STRING.

; compiling (DEFUN PRINT-FEATURE3 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN PRINT-FEATURE3
;     (FORMAT STREAM "~S~{ ~S~}" (SNARK-FEATURE::FEATURE-NAME SNARK-FEATURE::N)
;             SNARK-FEATURE::L)
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA
;               (STREAM #:FORMAT-ARG1622 #:FORMAT-ARG1623 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (PRIN1 #:FORMAT-ARG1622 STREAM)
;               (LET* (# #)
;                 (DECLARE #)
;                 (LOOP #
;                       #
;                       #)))
;             NIL)
;           #:G1620 #:G1621)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.

;     (FORMAT STREAM "~A" (SNARK-FEATURE::FEATURE-NAME SNARK-FEATURE::N))
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM #:FORMAT-ARG1640 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (PRINC #:FORMAT-ARG1640 STREAM))
;             NIL)
;           #:G1639)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.

;     (FORMAT STREAM "~S~{ ~S~}" (FIRST SNARK-FEATURE::L) (REST SNARK-FEATURE::L))
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA
;               (STREAM #:FORMAT-ARG1655 #:FORMAT-ARG1656 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (PRIN1 #:FORMAT-ARG1655 STREAM)
;               (LET* (# #)
;                 (DECLARE #)
;                 (LOOP #
;                       #
;                       #)))
;             NIL)
;           #:G1653 #:G1654)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.

; compiling (DEFUN PRINT-FEATURE-COMBO3 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN PRINT-FEATURE-COMBO3
;     (FORMAT STREAM "~S~{ ~S~}"
;             (FIRST (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::X))
;             (REST (SNARK-FEATURE::FEATURE-COMBO-LIST SNARK-FEATURE::X)))
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA
;               (STREAM #:FORMAT-ARG1700 #:FORMAT-ARG1701 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (PRIN1 #:FORMAT-ARG1700 STREAM)
;               (LET* (# #)
;                 (DECLARE #)
;                 (LOOP #
;                       #
;                       #)))
;             NIL)
;           #:G1698 #:G1699)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.

; compiling (DEFUN PRINT-FEATURE ...)
; compiling (DEFUN PRINT-FEATURE-LIST ...)
; compiling (DEFUN PRINT-FEATURE-TREE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.lisp
; in: DEFUN PRINT-FEATURE-TREE
;     (< 0 (FIRST SNARK-FEATURE::INCOMPAT))
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MOD SNARK-FEATURE::I 5)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a UNSIGNED-BYTE, not a (UNSIGNED-BYTE 64).

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::NODE SNARK-FEATURE::X)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::NODE SNARK-FEATURE::V)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (- (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::N)
;        (SNARK-FEATURE::FEATURE-DEPTH SNARK-FEATURE::NODE))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-FEATURE::I SNARK-FEATURE::DEPTH)
;       (PRINC
;        (IF (EQL 0 (MOD SNARK-FEATURE::I 5))
;            (IF (EQL 0 SNARK-FEATURE::I)
;                "   "
;                "|  ")
;            ":  ")))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-FEATURE::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< 0 (FIRST SNARK-FEATURE::INCOMPAT))
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::NODE SNARK-FEATURE::X)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1763 #:G1762 #:G1761) (DECLARE (TYPE REAL #:G1763 #:G1762 #:G1761)) (IF (>= #:G1763 #:G1762) (IF (>= #:G1762 #:G1761) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1778 #:G1777 #:G1776) (DECLARE (TYPE REAL #:G1778 #:G1777 #:G1776)) (IF (>= #:G1778 #:G1777) (IF (>= #:G1777 #:G1776) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-FEATURE::FEATURE<= SNARK-FEATURE::NODE SNARK-FEATURE::V)
; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE>= SNARK-FEATURE::N2 SNARK-FEATURE::N1)) 
; --> SB-C::%FUNCALL SNARK-FEATURE::FEATURE>= 
; --> (LAMBDA (SNARK-FEATURE::N1 SNARK-FEATURE::N2) (OR (EQ SNARK-FEATURE::N1 SNARK-FEATURE::N2) (>= (SNARK-FEATURE::FEATURE-PREORDER-MAX SNARK-FEATURE::N2) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N1) (SNARK-FEATURE::FEATURE-PREORDER-MIN SNARK-FEATURE::N2)))) 
; --> SB-C::%FUNCALL OR LET IF OR THE >= 
; --> (LAMBDA (#:G1782 #:G1781 #:G1780) (DECLARE (TYPE REAL #:G1782 #:G1781 #:G1780)) (IF (>= #:G1782 #:G1781) (IF (>= #:G1781 #:G1780) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature.fasl written
; compilation finished in 0:00:00.541
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-DPLL)
; compiling (DEFPARAMETER DP-PROVER ...)
; compiling (DEFPARAMETER DP-VERSION ...)
; compiling (DEFVAR DP-TRACING ...)
; compiling (DEFVAR DP-TRACING-STATE ...)
; compiling (DEFVAR DP-TRACING-MODELS ...)
; compiling (DEFVAR DP-TRACING-CHOICES ...)
; compiling (DEFSTRUCT (DP-CLAUSE-SET # ...) ...)
; compiling (DEFSTRUCT (DP-CLAUSE # ...) ...)
; compiling (DEFSTRUCT (DP-ATOM # ...) ...)
; compiling (DEFVAR *DEFAULT-FIND-ALL-MODELS* ...)
; compiling (DEFVAR *DEFAULT-MODEL-TEST-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-DEPENDENCY-CHECK* ...)
; compiling (DEFVAR *DEFAULT-PURE-LITERAL-CHECK* ...)
; compiling (DEFVAR *DEFAULT-ATOM-CHOICE-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-MORE-UNITS-FUNCTION* ...)
; compiling (DEFVAR *DEFAULT-BRANCH-LIMIT* ...)
; compiling (DEFVAR *DEFAULT-TIME-LIMIT* ...)
; compiling (DEFVAR *DEFAULT-MINIMAL-MODELS-SUFFICE* ...)
; compiling (DEFVAR *DEFAULT-MINIMAL-MODELS-ONLY* ...)
; compiling (DEFVAR *DEFAULT-CONVERT-TO-CLAUSES* ...)
; compiling (DEFVAR *DEFAULT-DIMACS-CNF-FORMAT* ...)
; compiling (DEFVAR *DEFAULT-SUBSUMPTION* ...)
; compiling (DEFVAR *DEFAULT-PRINT-SUMMARY* ...)
; compiling (DEFVAR *DEFAULT-PRINT-WARNINGS* ...)
; compiling (DEFVAR *DEPENDENCY-CHECK*)
; compiling (DEFVAR *MORE-UNITS-FUNCTION*)
; compiling (DEFVAR *MINIMAL-MODELS-SUFFICE*)
; compiling (DEFVAR *CLAUSE-SET*)
; compiling (DEFVAR *FAILURE-BRANCH-COUNT* ...)
; compiling (DEFVAR *ASSIGNMENT-COUNT* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFVAR *DP-START-TIME*)
; compiling (DEFUN DP-SATISFIABLE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-SATISFIABLE-P
;     (FUNCALL SNARK-DPLL::ATOM-CHOICE-FUNCTION SNARK-DPLL::CLAUSE-SET)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::ATOM-CHOICE-FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ZEROP SNARK-DPLL::FIND-ALL-MODELS)
; ==>
;   (= SNARK-DPLL::FIND-ALL-MODELS 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= 0 SNARK-DPLL:DP-TRACING-CHOICES)
; --> <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (/ SNARK-DPLL::TIME-LIMIT TIME)
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The second argument is a REAL, not a INTEGER.

;     (CEILING
;      (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME))))
; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET 
; ==>
;   (SB-KERNEL:%UNARY-TRUNCATE SB-C::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.

; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF 
; --> ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT -1.0 1.0) (DOUBLE-FLOAT -1.0d0 1.0d0) (RATIONAL (-1) (1))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK-DPLL::OLD-FAILURE-BRANCH-COUNT
;         (SNARK-DPLL::DP-ATOM-USED-IN-REFUTATION ATOM))
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (CEILING
;      (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME))))
; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND 
; --> THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK-DPLL::PROCESS-SUCCESS-BRANCH)
; --> PROGN COND IF COND IF OR LET IF OR LET IF OR THE <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX SNARK-DPLL::BRANCH-LIMIT
;          (CEILING
;           (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME)))))
; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (FUNCALL SNARK-DPLL::MODEL-TEST-FUNCTION
;              (SNARK-DPLL::VALUED-ATOMS SNARK-DPLL::CLAUSE-SET
;                                        SNARK-DPLL::*MINIMAL-MODELS-SUFFICE*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MODEL-TEST-FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MAX SNARK-DPLL::BRANCH-LIMIT
;          (CEILING
;           (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME)))))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK-DPLL::PROCESS-SUCCESS-BRANCH)
; --> PROGN COND IF COND IF OR LET IF OR LET PLUSP > IF 
; ==>
;   (> SNARK-DPLL::FIND-ALL-MODELS 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> PROGN COND IF COND IF OR LET IF OR LET IF OR THE <= - 
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-DPLL::FIND-ALL-MODELS))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME))
; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (>= TIME SNARK-DPLL::TIME-LIMIT)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (REM SNARK-DPLL::BRANCH-COUNT SNARK-DPLL:DP-TRACING)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The second argument is a REAL, not a INTEGER.

;     (* SNARK-DPLL:DP-TRACING SNARK-DPLL:DP-TRACING-STATE)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (REM SNARK-DPLL::BRANCH-COUNT
;          (* SNARK-DPLL:DP-TRACING SNARK-DPLL:DP-TRACING-STATE))
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The second argument is a REAL, not a INTEGER.

;     (>= TIME SNARK-DPLL::TIME-LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK-DPLL::N SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (>= SNARK-DPLL::BRANCH-COUNT SNARK-DPLL::BRANCH-LIMIT)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*
;        SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; --> + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (PLUSP SNARK-DPLL::POSITIVE-PURE-LITERAL-COUNT)
; ==>
;   (> SNARK-DPLL::POSITIVE-PURE-LITERAL-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (PLUSP SNARK-DPLL::NEGATIVE-PURE-LITERAL-COUNT)
; ==>
;   (> SNARK-DPLL::NEGATIVE-PURE-LITERAL-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (PLUSP SNARK-DPLL::FORCED-CHOICE-COUNT)
; ==>
;   (> SNARK-DPLL::FORCED-CHOICE-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (>= SNARK-DPLL::BRANCH-COUNT SNARK-DPLL::BRANCH-LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (>= TIME SNARK-DPLL::TIME-LIMIT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (/ SNARK-DPLL::TIME-LIMIT TIME)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (CEILING
;      (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME))))
; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES (OR (SINGLE-FLOAT -1.0 1.0) (DOUBLE-FLOAT -1.0d0 1.0d0) (RATIONAL (-1) (1))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES (OR (SINGLE-FLOAT -1.0 1.0) (DOUBLE-FLOAT -1.0d0 1.0d0) (RATIONAL (-1) (1))) &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND 
; --> THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> CEILING MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MAX SNARK-DPLL::BRANCH-LIMIT
;          (CEILING
;           (* SNARK-DPLL::BRANCH-COUNT (MIN 100 (/ SNARK-DPLL::TIME-LIMIT TIME)))))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-DPLL::PROCESS-SUCCESS-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::SUCCESS-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN COND IF COND IF OR LET IF OR LET PLUSP > IF 
; ==>
;   (> SNARK-DPLL::FIND-ALL-MODELS 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; --> PROGN COND IF COND IF OR LET IF OR LET IF OR THE <= - 
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-DPLL::FIND-ALL-MODELS))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> PROGN COND IF COND IF OR LET IF OR LET IF OR THE <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> PROGN COND IF COND IF PROGN LET COND IF COND THE PROGN IF EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (< SNARK-DPLL::DEPTH SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (INCF SNARK-DPLL::BRANCH-COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< SNARK-DPLL::DEPTH SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (* SNARK-DPLL:DP-TRACING SNARK-DPLL:DP-TRACING-STATE)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (<= SNARK-DPLL::OLD-FAILURE-BRANCH-COUNT
;         (SNARK-DPLL::DP-ATOM-USED-IN-REFUTATION ATOM))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (EQL SNARK-DPLL::OLD-SUCCESS-BRANCH-COUNT SNARK-DPLL::SUCCESS-BRANCH-COUNT)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (< SNARK-DPLL::DEPTH SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (+ SNARK-DPLL::DEPTH SNARK-DPLL:DP-TRACING-CHOICES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (< SNARK-DPLL::N SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (SNARK-DPLL::PROCESS-CUTOFF-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::FORCED-CHOICE-COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::FORCED-CHOICE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< SNARK-DPLL::DEPTH SNARK-DPLL::DP-TRACING-CHOICES-DEPTH)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (>= 0 SNARK-DPLL:DP-TRACING-CHOICES)
; --> <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (INCF SNARK-DPLL::NEGATIVE-PURE-LITERAL-COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NEGATIVE-PURE-LITERAL-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::POSITIVE-PURE-LITERAL-COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::POSITIVE-PURE-LITERAL-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-DPLL::PROCESS-FAILURE-BRANCH)
; --> PROGN INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + + 
; ==>
;   (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> PROGN WHEN IF FORMAT + 
; ==>
;   (+ (+ SNARK-DPLL::SUCCESS-BRANCH-COUNT SNARK-DPLL::*FAILURE-BRANCH-COUNT*)
;      SNARK-DPLL::CUTOFF-BRANCH-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN DP-SATISFIABLE-FILE-P ...)
; compiling (DEFUN DP-INSERT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-INSERT
;     (INCF SNARK-DPLL::NLITS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NLITS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK-DPLL::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK-DPLL::P)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::P)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF (SNARK-DPLL::DP-ATOM-NUMBER-OF-OCCURRENCES ATOM))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-ATOM #:OBJ) 12)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NLITS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::P)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::P)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-CLAUSES SNARK-DPLL::CLAUSE-SET))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-CLAUSE-SET #:OBJ)
;                                          3)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-LITERALS SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NLITS)
; --> LET* 
; ==>
;   (+ SNARK-DPLL::NLITS
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-CLAUSE-SET #:OBJ)
;                                          4)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN DP-INSERT-SORTED ...)
; compiling (DEFUN DP-INSERT-WFF ...)
; compiling (DEFVAR *DP-READ-STRING*)
; compiling (DEFVAR *DP-READ-INDEX*)
; compiling (DEFUN DP-READ ...)
; compiling (DEFUN DP-INSERT-FILE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-INSERT-FILE
;     (LENGTH SNARK-DPLL::LITS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (LENGTH SNARK-DPLL::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITS (LENGTH SNARK-DPLL::LITS))
; --> SETQ THE 
; ==>
;   (+ (LENGTH SNARK-DPLL::LITS) SNARK-DPLL::NLITS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITS (LENGTH SNARK-DPLL::LITS))
; --> SETQ THE 
; ==>
;   (+ (LENGTH SNARK-DPLL::LITS) SNARK-DPLL::NLITS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITS (LENGTH SNARK-DPLL::X))
; --> SETQ THE 
; ==>
;   (+ (LENGTH SNARK-DPLL::X) SNARK-DPLL::NLITS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFMACRO CLAUSE-CONTAINS-TRUE-POSITIVE-LITERAL ...)
; compiling (DEFMACRO CLAUSE-CONTAINS-TRUE-NEGATIVE-LITERAL ...)
; compiling (DEFUN DP-HORN-CLAUSE-SET-P ...)
; compiling (DEFUN DP-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-COUNT
;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK-DPLL::NATOMS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NATOMS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;            SNARK-DPLL::CLAUSE))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;     SNARK-DPLL::CLAUSE)
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN DP-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-CLAUSES
;     (FUNCALL SNARK-DPLL::MAP-FUN
;              (SNARK-DPLL::DECODE-DP-CLAUSE SNARK-DPLL::CLAUSE
;                                            SNARK-DPLL::DECODE-FUN))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DP-OUTPUT-CLAUSES-TO-FILE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-OUTPUT-CLAUSES-TO-FILE
;     (FORMAT SNARK-DPLL::S "p cnf ~D ~D~%"
;             (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-ATOMS SNARK-DPLL::CLAUSE-SET)
;             (SNARK-DPLL:DP-COUNT SNARK-DPLL::CLAUSE-SET))
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA
;               (STREAM #:FORMAT-ARG2070 #:FORMAT-ARG2071 &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL
;               (WRITE-STRING "p cnf " STREAM)
;               (LET (# #)
;                 (PRINC #:FORMAT-ARG2070 STREAM))
;               (WRITE-STRING " " STREAM)
;               (LET (# #)
;                 (PRINC #:FORMAT-ARG2071 STREAM))
;               (TERPRI STREAM))
;             NIL)
;           #:G2068 #:G2069)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM NULL), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM NULL), not a NULL.

;     (PLUSP (SNARK-DPLL::DP-ATOM-NAME ATOM))
; ==>
;   (> (SNARK-DPLL::DP-ATOM-NAME ATOM) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN ASSERT-DP-CLAUSE-SET-P ...)
; compiling (DEFUN ASSERT-UNVALUED-DP-CLAUSE-SET-P ...)
; compiling (DEFUN ADD-MODEL-CONSTRAINT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN ADD-MODEL-CONSTRAINT
;     (INCF SNARK-DPLL::NLITS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NLITS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF (SNARK-DPLL::DP-ATOM-NUMBER-OF-OCCURRENCES ATOM))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-ATOM #:OBJ) 12)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NLITS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-CLAUSES SNARK-DPLL::CLAUSE-SET))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-CLAUSE-SET #:OBJ)
;                                          3)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-LITERALS SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NLITS)
; --> LET* 
; ==>
;   (+ SNARK-DPLL::NLITS
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-CLAUSE-SET #:OBJ)
;                                          4)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN VALUED-ATOMS ...)
; compiling (DEFUN DP-ATOM-NAMED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-ATOM-NAMED
;     (INCF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-ATOMS SNARK-DPLL::CLAUSE-SET))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF (THE SNARK-DPLL::DP-CLAUSE-SET #:OBJ)
;                                          2)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN NEGATIVE-LITERAL-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN NEGATIVE-LITERAL-P
;     (MINUSP SNARK-DPLL::LIT)
; ==>
;   (< SNARK-DPLL::LIT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (- SNARK-DPLL::LIT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-DPLL::LIT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (MINUSP SNARK-DPLL::LIT)
; ==>
;   (< SNARK-DPLL::LIT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (- SNARK-DPLL::LIT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-DPLL::LIT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN COMPLEMENTARY-LITERAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN COMPLEMENTARY-LITERAL
;     (- SNARK-DPLL::LIT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK-DPLL::LIT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN CLAUSE-CONTAINS-REPEATED-ATOM ...)
; compiling (DEFUN PRINT-DP-CLAUSE-SET3 ...)
; compiling (DEFUN DECODE-DP-CLAUSE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DECODE-DP-CLAUSE
;     (FUNCALL SNARK-DPLL::DECODE-FUN ATOM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::DECODE-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PRINT-DP-CLAUSE ...)
; compiling (DEFUN PRINT-DP-ATOM ...)
; compiling (DEFUN PRINT-DP-TRACE-LINE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN PRINT-DP-TRACE-LINE
;     (REM SNARK-DPLL::I 5)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a UNSIGNED-BYTE, not a (UNSIGNED-BYTE 64).

;     (DOTIMES (SNARK-DPLL::I SNARK-DPLL::DEPTH)
;       (PRINC
;        (IF (EQL 4 (REM SNARK-DPLL::I 5))
;            "| "
;            ": ")))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-DPLL::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PRINT-DP-CHOICE-POINTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN PRINT-DP-CHOICE-POINTS
;     (INCF SNARK-DPLL::DEPTH)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::DEPTH)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFVAR FLOAT-INTERNAL-TIME-UNITS-PER-SECOND ...)
; compiling (DEFUN RUN-TIME-SINCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN RUN-TIME-SINCE
;     (/ SNARK-DPLL::TICKS SNARK-DPLL::FLOAT-INTERNAL-TIME-UNITS-PER-SECOND)
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The second argument is a NUMBER, not a INTEGER.

;     (- (/ SNARK-DPLL::TICKS SNARK-DPLL::FLOAT-INTERNAL-TIME-UNITS-PER-SECOND)
;        SNARK-DPLL::START-TIME)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFMACRO FIRST-NONTRUE-ATOM ...)
; compiling (DEFMACRO FIRST-NONFALSE-ATOM ...)
; compiling (DEFMACRO FIRST-UNASSIGNED-ATOM ...)
; compiling (DEFMACRO NTH-UNASSIGNED-ATOM ...)
; compiling (DEFUN MARK-USED-ATOMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN MARK-USED-ATOMS
;     (EQL SNARK-DPLL::MARK (SNARK-DPLL::DP-ATOM-USED-IN-REFUTATION ATOM))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (DEFUN MAKE-LEMMA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN MAKE-LEMMA
;     (<= SNARK-DPLL::FBC (SNARK-DPLL::DP-ATOM-USED-IN-REFUTATION ATOM))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFVAR *LAST-TRIED-ATOM*)
; compiling (DEFUN ASSIGN-ATOMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN ASSIGN-ATOMS
;     (FUNCALL SNARK-DPLL::COMPUTE-MORE-UNITS SNARK-DPLL::*CLAUSE-SET*)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::COMPUTE-MORE-UNITS)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN UNASSIGN-ATOM ...)
; compiling (DEFUN UNASSIGN-ATOMS ...)
; compiling (DEFUN FIND-UNIT-CLAUSES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE*
;     (SNARK-DPLL::CHECK-CLAUSE)
; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; ==>
;   (RANDOM (INCF SNARK-DPLL::NFOUND))
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a SINGLE-FLOAT.
; 
; note: unable to Use inline float operations. due to type uncertainty: The first argument is a (OR (SINGLE-FLOAT (0.0)) (DOUBLE-FLOAT (0.0d0)) (INTEGER 1)), not a DOUBLE-FLOAT.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE EQL 
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF AND IF AND THE 
; --> EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF PROGN WHEN IF EQL 
; --> RANDOM INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> PROGN WHEN IF ECASE LET COND IF COND IF PROGN UNLESS IF DOLIST BLOCK LET 
; --> TAGBODY UNLESS IF PROGN LET TAGBODY WHEN IF LET COND IF COND IF 
; ==>
;   (> SNARK-DPLL::C SNARK-DPLL::NOCCURRENCES)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> PROGN WHEN IF ECASE LET COND IF PROGN IF COND IF PROGN WHEN IF EQL RANDOM 
; --> INCF SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NFOUND)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-DPLL::NTH-UNASSIGNED-ATOM (- SNARK-DPLL::N SNARK-DPLL::M)
;                                      (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS
;                                       SNARK-DPLL::CHOSEN-CLAUSE))
; --> LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY UNLESS IF IF 
; --> DECF SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER * 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER * 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER * 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-DPLL::NTH-UNASSIGNED-ATOM SNARK-DPLL::N
;                                      (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS
;                                       SNARK-DPLL::CHOSEN-CLAUSE))
; --> LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY UNLESS IF IF 
; --> DECF SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-DPLL::NTH-UNASSIGNED-ATOM (- SNARK-DPLL::N SNARK-DPLL::M)
;                                      (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS
;                                       SNARK-DPLL::CHOSEN-CLAUSE))
; ==>
;   (LET ((SNARK-DPLL::K (- SNARK-DPLL::N SNARK-DPLL::M)))
;     (DOLIST
;         (ATOM
;          (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS SNARK-DPLL::CHOSEN-CLAUSE))
;       (UNLESS (SNARK-DPLL::DP-ATOM-VALUE ATOM)
;         (IF (EQL 0 SNARK-DPLL::K)
;             (RETURN ATOM)
;             (DECF SNARK-DPLL::K)))))
; 
; note: doing signed word to integer coercion (cost 20) to K

; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-WITH-MOST-OCCURRENCES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-CLAUSE-WITH-MOST-OCCURRENCES-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-RANDOMLY ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-WITH-MOST-OCCURRENCES ...)
; compiling (DEFUN CHOOSE-AN-ATOM-OF-A-SHORTEST-POSITIVE-CLAUSE-WITH-MOST-OCCURRENCES-RANDOMLY ...)
; compiling (DEFUN FIX-DP-CLAUSE-SET ...)
; compiling (DEFUN CHECKPOINT-DP-CLAUSE-SET ...)
; compiling (DEFUN RESTORE-DP-CLAUSE-SET ...)
; compiling (DEFUN UNCHECKPOINT-DP-CLAUSE-SET ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN UNCHECKPOINT-DP-CLAUSE-SET
;     (EQL SNARK-DPLL::LEVEL2 (FIRST (SECOND SNARK-DPLL::ACPS)))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387905 4611686018427387902), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
; 
; note: doing signed word to integer coercion (cost 20) from LEVEL2, for:
;       the first argument of %EQL/INTEGER

;     (SETF (FIRST (FIRST SNARK-DPLL::ACPS)) SNARK-DPLL::LEVEL2)
; ==>
;   (SB-KERNEL:%RPLACA (FIRST SNARK-DPLL::ACPS) SNARK-DPLL::LEVEL2)
; 
; note: doing signed word to integer coercion (cost 20) from LEVEL2, for:
;       the second argument of SET-SLOT

; compiling (DEFUN CHECKPOINT-DP-ATOM ...)
; compiling (DEFUN RESTORE-DP-ATOM ...)
; compiling (DEFVAR *VERBOSE-LOOKAHEAD* ...)
; compiling (DEFVAR *VERBOSE-LOOKAHEAD-SHOW-COUNT* ...)
; compiling (DEFUN LOOKAHEAD-TRUE ...)
; compiling (DEFUN LOOKAHEAD-FALSE ...)
; compiling (DEFUN LOOKAHEAD-TRUE-FALSE ...)
; compiling (DEFUN LOOKAHEAD-FALSE-TRUE ...)
; compiling (DEFVAR VALUES-AND-PASSES1 ...)
; compiling (DEFVAR VALUES-AND-PASSES2 ...)
; compiling (DEFVAR VALUES-AND-PASSES3 ...)
; compiling (DEFVAR VALUES-AND-PASSES4 ...)
; compiling (DEFVAR VALUES-AND-PASSES5 ...)
; compiling (DEFVAR VALUES-AND-PASSES6 ...)
; compiling (DEFVAR VALUES-AND-PASSES7 ...)
; compiling (DEFVAR VALUES-AND-PASSES8 ...)
; compiling (DEFUN LOOKAHEAD* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN LOOKAHEAD*
;     (INCF SNARK-DPLL::NTRIALS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NTRIALS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN SHOW-COUNT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN SHOW-COUNT-P
;     (MOD SNARK-DPLL::N SNARK-DPLL::V)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-100000) (100000)) (DOUBLE-FLOAT -100000.0d0 100000.0d0) (SINGLE-FLOAT -100000.0 100000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK-DPLL::N SNARK-DPLL::V)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MOD SNARK-DPLL::N SNARK-DPLL::V)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (>= SNARK-DPLL::N SNARK-DPLL::V)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.

;     (MOD SNARK-DPLL::N SNARK-DPLL::V)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-100000) (100000)) (DOUBLE-FLOAT -100000.0d0 100000.0d0) (SINGLE-FLOAT -100000.0 100000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (SINGLE-FLOAT -99990.0 200000.0) (DOUBLE-FLOAT -99990.0d0 200000.0d0) (RATIONAL (-99990) (200000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (OR (RATIONAL (-100000) (100000)) (DOUBLE-FLOAT -100000.0d0 100000.0d0) (SINGLE-FLOAT -100000.0 100000.0)), not a (SIGNED-BYTE 64).
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (SINGLE-FLOAT -99990.0 200000.0) (DOUBLE-FLOAT -99990.0d0 200000.0d0) (RATIONAL (-99990) (200000))) &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN SHOW-COUNT ...)
; compiling (DEFUN VARIABLE-AND-RANGE-P ...)
; compiling (DEFUN VARIABLES-AND-RANGES-P ...)
; compiling (DEFUN QUOTEVAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN QUOTEVAL
;     (APPLY (FIRST SNARK-DPLL::X)
;            (MAPCAR
;             (LAMBDA (SNARK-DPLL::X)
;               (SNARK-DPLL::QUOTEVAL SNARK-DPLL::X SNARK-DPLL::ENV))
;             (REST SNARK-DPLL::X)))
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (FIRST SNARK-DPLL::X))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSOC SNARK-DPLL::X SNARK-DPLL::ENV)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN VARIABLE-RANGE ...)
; compiling (DEFUN RANGE-TERM-VALUE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN RANGE-TERM-VALUE
;     (ASSOC SNARK-DPLL::X SNARK-DPLL::RANGE-TERM-VALUES)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN EXPAND-RANGE-FORM ...)
; compiling (DEFUN REPLACE-VARIABLE-BY-VALUE-IN-TERM ...)
; compiling (DEFUN WFF-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN WFF-CLAUSES
;     (FUNCALL SNARK-DPLL::MAP-FUN (REVERSE SNARK-DPLL::LITS))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-DPLL::MAP-FUN SNARK-DPLL::LITS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-DPLL::MAP-FUN
;              (IF (EQ
;                   (IF SNARK-DPLL::POS
;                       SNARK-LISP:FALSE
;                       SNARK-LISP:TRUE)
;                   SNARK-DPLL::WFF)
;                  SNARK-DPLL::LITS
;                  (CONS
;                   (IF SNARK-DPLL::POS
;                       SNARK-DPLL::WFF
;                       SNARK-DPLL::-WFF)
;                   SNARK-DPLL::LITS)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-DPLL::MAP-FUN SNARK-DPLL::LITS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-DPLL::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (LENGTH (REST SNARK-DPLL::WFF))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFVAR *VERBOSE-SUBSUMPTION* ...)
; compiling (DEFVAR *SUBSUMPTION-SHOW-COUNT* ...)
; compiling (DEFUN DP-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN DP-SUBSUMPTION
;     (INCF SNARK-DPLL::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (MEMBER ATOM SNARK-DPLL::POSLITS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER ATOM SNARK-DPLL::POSLITS2)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER ATOM SNARK-DPLL::NEGLITS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (PUSHNEW ATOM SNARK-DPLL::RESOLVENT-POSLITS)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER ATOM SNARK-DPLL::NEGLITS2)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (INCF (CDR SNARK-DPLL::SUBSUMPTION-MARK))
; --> LET* 
; ==>
;   (+ 1 (CDR #:SUBSUMPTION-MARK4361))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (DELETE-IF
;      (LAMBDA (SNARK-DPLL::CLAUSE)
;        (WHEN
;            (EQ :SUBSUMED
;                (SNARK-DPLL::DP-CLAUSE-SUBSUMPTION-MARK SNARK-DPLL::CLAUSE))
;          (INCF SNARK-DPLL::N)))
;      (SNARK-DPLL::DP-ATOM-CONTAINED-POSITIVELY-CLAUSES ATOM))
; 
; note: unable to open code due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (DELETE-IF
;      (LAMBDA (SNARK-DPLL::CLAUSE)
;        (WHEN
;            (EQ :SUBSUMED
;                (SNARK-DPLL::DP-CLAUSE-SUBSUMPTION-MARK SNARK-DPLL::CLAUSE))
;          (INCF SNARK-DPLL::N)))
;      (SNARK-DPLL::DP-ATOM-CONTAINED-NEGATIVELY-CLAUSES ATOM))
; 
; note: unable to open code due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (INCF (CAR SNARK-DPLL::SUBSUMPTION-MARK))
; --> LET* 
; ==>
;   (+ 1 (CAR #:SUBSUMPTION-MARK4356))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LABELS ((SNARK-DPLL::SAME-LITERAL (SNARK-DPLL::CLAUSES)
;                (DOLIST (SNARK-DPLL::CLAUSE2 SNARK-DPLL::CLAUSES)
;                  (LET #
;                    #)))
;              (SNARK-DPLL::COMP-LITERAL (SNARK-DPLL::CLAUSES)
;                (DOLIST (SNARK-DPLL::CLAUSE2 SNARK-DPLL::CLAUSES)
;                  (LET #
;                    #)))
;              (SNARK-DPLL::RESOLVE
;                  (SNARK-DPLL::CLAUSE SNARK-DPLL::CLAUSE2
;                   &OPTIONAL SNARK-DPLL::SUBSUME-BOTH)
;                (SETF SNARK-DPLL::CHANGED T)
;                (WHEN SNARK-DPLL::*VERBOSE-SUBSUMPTION*
;                  (IF SNARK-DPLL::SUBSUME-BOTH
;                      #
;                      #))
;                (SETF # :SUBSUMED)
;                (WHEN SNARK-DPLL::SUBSUME-BOTH (SETF #))
;                (LET (# # # # # #)
;                  (WHEN # #)
;                  (DOLIST # #)
;                  (DOLIST # #)
;                  (DOLIST # #)
;                  (DOLIST # #)
;                  (SNARK-DPLL:DP-INSERT # SNARK-DPLL::CLAUSE-SET)))
;              (SNARK-DPLL::DELETE-CLAUSES (FIRST)
;                (LET (# #)
;                  (LOOP #)
;                  (LET* #
;                    #)))
;              (SNARK-DPLL::SUBSUMPTION (SNARK-DPLL::CLAUSE)
;                (WHEN SNARK-DPLL::*SUBSUMPTION-SHOW-COUNT*
;                  (SNARK-DPLL::SHOW-COUNT #))
;                (UNLESS (EQ :SUBSUMED #)
;                  (DOLIST # # #)
;                  (DOLIST # # #)
;                  (LET #
;                    #
;                    #
;                    #
;                    #))))
;       (WHEN SNARK-DPLL::PRINT-SUMMARY (FORMAT T "~&Clause set subsumption "))
;       (LET ((SNARK-DPLL::P-CLAUSES (SNARK-DPLL::MAKE-DP-CLAUSE :NEXT #))
;             (SNARK-DPLL::N-CLAUSES (SNARK-DPLL::MAKE-DP-CLAUSE :NEXT #))
;             (SNARK-DPLL::M1-CLAUSES (SNARK-DPLL::MAKE-DP-CLAUSE :NEXT #))
;             (SNARK-DPLL::M2-CLAUSES (SNARK-DPLL::MAKE-DP-CLAUSE :NEXT #)))
;         (LET (SNARK-DPLL::NEXT)
;           (LOOP
;            (IF #
;                #
;                #))))
;       (WHEN SNARK-DPLL::*SUBSUMPTION-SHOW-COUNT*
;         (SNARK-DPLL::SHOW-COUNT COUNT NIL T))
;       (WHEN SNARK-DPLL::CHANGED
;         (DOLIST (ATOM (SNARK-DPLL::DP-CLAUSE-SET-ATOMS SNARK-DPLL::CLAUSE-SET))
;           (LET (#)
;             (SETF #)
;             (SETF #)
;             (DECF # SNARK-DPLL::N)))
;         (MULTIPLE-VALUE-BIND (FIRST LAST)
;             (SNARK-DPLL::DELETE-CLAUSES
;              (SNARK-DPLL::DP-CLAUSE-SET-P-CLAUSES SNARK-DPLL::CLAUSE-SET))
;           (SETF # FIRST)
;           (SETF # LAST))
;         (MULTIPLE-VALUE-BIND (FIRST LAST)
;             (SNARK-DPLL::DELETE-CLAUSES
;              (SNARK-DPLL::DP-CLAUSE-SET-N-CLAUSES SNARK-DPLL::CLAUSE-SET))
;           (SETF # FIRST)
;           (SETF # LAST))
;         (MULTIPLE-VALUE-BIND (FIRST LAST)
;             (SNARK-DPLL::DELETE-CLAUSES
;              (SNARK-DPLL::DP-CLAUSE-SET-M1-CLAUSES SNARK-DPLL::CLAUSE-SET))
;           (SETF # FIRST)
;           (SETF # LAST))
;         (MULTIPLE-VALUE-BIND (FIRST LAST)
;             (SNARK-DPLL::DELETE-CLAUSES
;              (SNARK-DPLL::DP-CLAUSE-SET-M2-CLAUSES SNARK-DPLL::CLAUSE-SET))
;           (SETF # FIRST)
;           (SETF # LAST)))
;       (WHEN SNARK-DPLL::PRINT-SUMMARY
;         (FORMAT T "took ~,1F seconds"
;                 (SNARK-DPLL::RUN-TIME-SINCE SNARK-DPLL::START-TIME))
;         (COND
;          (SNARK-DPLL::CHANGED (PRINC ".")
;           (SNARK-DPLL:DP-COUNT SNARK-DPLL::CLAUSE-SET T))
;          (T (PRINC " - no change."))))
;       NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

;     (INCF (CAR SNARK-DPLL::SUBSUMPTION-MARK))
; --> LET* 
; ==>
;   (+ 1 (CAR #:SUBSUMPTION-MARK4356))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS FIRST))
;              (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS FIRST))))
; --> SETQ THE 
; ==>
;   (+
;    (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS FIRST))
;       (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS FIRST)))
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (MOD 9223372036854775801), not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK-DPLL::NCLAUSES)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::NCLAUSES)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::NLITERALS
;           (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS SNARK-DPLL::NEXT))
;              (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS SNARK-DPLL::NEXT))))
; --> SETQ THE 
; ==>
;   (+
;    (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS SNARK-DPLL::NEXT))
;       (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS SNARK-DPLL::NEXT)))
;    SNARK-DPLL::NLITERALS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (MOD 9223372036854775801), not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DECF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-CLAUSES SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NCLAUSES)
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DECF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-LITERALS SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NLITERALS)
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DECF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-CLAUSES SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NCLAUSES)
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DECF (SNARK-DPLL::DP-CLAUSE-SET-NUMBER-OF-LITERALS SNARK-DPLL::CLAUSE-SET)
;           SNARK-DPLL::NLITERALS)
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL SNARK-DPLL::SAME-COUNT LENGTH)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.

;     (EQL SNARK-DPLL::SAME-COUNT
;          (+
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;            SNARK-DPLL::CLAUSE2)
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;            SNARK-DPLL::CLAUSE2)))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.

;     (DECF LENGTH)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER -9223372036854775809 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER -9223372036854775809 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+
;      (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;       SNARK-DPLL::CLAUSE2)
;      (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;       SNARK-DPLL::CLAUSE2)
;      -1)
; ==>
;   (+
;    (+
;     (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;      SNARK-DPLL::CLAUSE2)
;     (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;      SNARK-DPLL::CLAUSE2))
;    -1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER -9223372036854775809 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -9223372036854775808 9223372036854775806), not a FIXNUM.
;       The result is a (VALUES (INTEGER -9223372036854775809 9223372036854775805) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL (CAR SNARK-DPLL::SUBSUMPTION-MARK) LENGTH)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775809 9223372036854775806), not a FIXNUM.

;     (EQL (CAR SNARK-DPLL::SUBSUMPTION-MARK) SNARK-DPLL::LENGTH2)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775809 9223372036854775805), not a FIXNUM.
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a (INTEGER -9223372036854775809 9223372036854775805), not a FIXNUM.

;     (INCF (CDR SNARK-DPLL::SUBSUMPTION-MARK))
; --> LET* 
; ==>
;   (+ 1 (CDR #:SUBSUMPTION-MARK4361))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-DPLL::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-DPLL::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DECF (SNARK-DPLL::DP-ATOM-NUMBER-OF-OCCURRENCES ATOM) SNARK-DPLL::N)
; --> LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (LET ((LENGTH
;            (+
;             (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;              SNARK-DPLL::CLAUSE)
;             (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;              SNARK-DPLL::CLAUSE))))
;       (DOLIST (SNARK-DPLL::CLAUSE2 SNARK-DPLL::CANDIDATES)
;         (LET ((SNARK-DPLL::SAME-COUNT #))
;           (COND (# # # #) (# # # #))))
;       (DECF LENGTH)
;       (DOLIST (SNARK-DPLL::CLAUSE2 SNARK-DPLL::CANDIDATES)
;         (LET ((SNARK-DPLL::SUBSUMPTION-MARK #))
;           (UNLESS (EQ :SUBSUMED SNARK-DPLL::SUBSUMPTION-MARK)
;             (SETF #)
;             (UNLESS # #))))
;       (SETF SNARK-DPLL::CANDIDATES NIL))
; 
; note: doing signed word to integer coercion (cost 20) to LENGTH

;     (+
;      (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;       SNARK-DPLL::CLAUSE2)
;      (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;       SNARK-DPLL::CLAUSE2)
;      -1)
; ==>
;   (+
;    (+
;     (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;      SNARK-DPLL::CLAUSE2)
;     (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;      SNARK-DPLL::CLAUSE2))
;    -1)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-+

;     (EQL SNARK-DPLL::SAME-COUNT
;          (+
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-POSITIVE-LITERALS
;            SNARK-DPLL::CLAUSE2)
;           (SNARK-DPLL::DP-CLAUSE-NUMBER-OF-UNRESOLVED-NEGATIVE-LITERALS
;            SNARK-DPLL::CLAUSE2)))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of %EQL/INTEGER

;     (INCF SNARK-DPLL::NLITERALS
;           (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS SNARK-DPLL::NEXT))
;              (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS SNARK-DPLL::NEXT))))
; --> SETQ THE 
; ==>
;   (+
;    (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS SNARK-DPLL::NEXT))
;       (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS SNARK-DPLL::NEXT)))
;    SNARK-DPLL::NLITERALS)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-+

;     (INCF SNARK-DPLL::NLITERALS
;           (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS FIRST))
;              (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS FIRST))))
; --> SETQ THE 
; ==>
;   (+
;    (+ (LENGTH (SNARK-DPLL::DP-CLAUSE-POSITIVE-LITERALS FIRST))
;       (LENGTH (SNARK-DPLL::DP-CLAUSE-NEGATIVE-LITERALS FIRST)))
;    SNARK-DPLL::NLITERALS)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of GENERIC-+

; compiling (DEFUN ALLWAYS-3-PROBLEM ...)
; compiling (DEFUN PIGEONHOLE-PROBLEM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN PIGEONHOLE-PROBLEM
;     (+ SNARK-DPLL::NHOLES 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN QUEENS-PROBLEM ...)
; compiling (DEFUN GRAPH-COLORING-PROBLEM ...)
; compiling (DEFUN PIGEONHOLE-PROBLEM-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN PIGEONHOLE-PROBLEM-CLAUSES
;     (+ SNARK-DPLL::NHOLES 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN QUEENS-PROBLEM-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.lisp
; in: DEFUN QUEENS-PROBLEM-CLAUSES
;     (<= (+ SNARK-DPLL::J1 SNARK-DPLL::D) SNARK-DPLL::N)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (SNARK-DPLL:DP-INSERT
;               (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;                     SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I
;                                          ,SNARK-DPLL::J))
;               SNARK-DPLL::CLAUSE-SET))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::I #:LOOP-LIMIT-4888)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I ,SNARK-DPLL::J))
; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::J #:LOOP-LIMIT-4889)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ SNARK-DPLL::J 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (SNARK-DPLL:DP-INSERT
;               (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;                     SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I
;                                          ,SNARK-DPLL::J))
;               SNARK-DPLL::CLAUSE-SET))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (SNARK-DPLL:DP-INSERT
;               (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;                     SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I
;                                          ,SNARK-DPLL::J))
;               SNARK-DPLL::CLAUSE-SET))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::J #:LOOP-LIMIT-4893)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I ,SNARK-DPLL::J))
; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::I #:LOOP-LIMIT-4894)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ SNARK-DPLL::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (SNARK-DPLL:DP-INSERT
;               (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;                     SNARK-LISP:COLLECT `(SNARK-DPLL::Q ,SNARK-DPLL::I
;                                          ,SNARK-DPLL::J))
;               SNARK-DPLL::CLAUSE-SET))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::J 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                                     SNARK-DPLL::N
;                                                                                     1)
;                    DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::K SNARK-DPLL::FROM (+
;                                                                             SNARK-DPLL::J
;                                                                             1) SNARK-DPLL::TO SNARK-DPLL::N
;                             DO (SNARK-DPLL:DP-INSERT (LIST `# `#)
;                                                      SNARK-DPLL::CLAUSE-SET) (SNARK-DPLL:DP-INSERT
;                                                                               (LIST
;                                                                                `#
;                                                                                `#)
;                                                                               SNARK-DPLL::CLAUSE-SET))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::I #:LOOP-LIMIT-4898)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (- SNARK-DPLL::N 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I1 SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                             SNARK-DPLL::N
;                                                                             1)
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::I2 SNARK-DPLL::FROM (+
;                                                                     SNARK-DPLL::I1
;                                                                     1) SNARK-DPLL::TO SNARK-DPLL::N SNARK-DPLL::AS SNARK-DPLL::D = (-
;                                                                                                                                     SNARK-DPLL::I2
;                                                                                                                                     SNARK-DPLL::I1)
;                    DO ...))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::I1 #:LOOP-LIMIT-4901)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (+ SNARK-DPLL::I1 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I2 SNARK-DPLL::FROM (+ SNARK-DPLL::I1
;                                                              1) SNARK-DPLL::TO SNARK-DPLL::N SNARK-DPLL::AS SNARK-DPLL::D = (-
;                                                                                                                              SNARK-DPLL::I2
;                                                                                                                              SNARK-DPLL::I1)
;           DO ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::I2 #:LOOP-LIMIT-4902)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (- SNARK-DPLL::I2 SNARK-DPLL::I1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The second argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (INTEGER 2), not a (SIGNED-BYTE 64).
;       The second argument is a (INTEGER 1), not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J1 SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           WHEN (>= (- SNARK-DPLL::J1 SNARK-DPLL::D) 1)
;           DO (SNARK-DPLL:DP-INSERT
;               (LIST `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I1 ,SNARK-DPLL::J1))
;                     `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I2 ,#)))
;               SNARK-DPLL::CLAUSE-SET)
;           WHEN ...)
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::J1 #:LOOP-LIMIT-4903)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (- SNARK-DPLL::J1 SNARK-DPLL::D)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (INTEGER 1), not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (>= (- SNARK-DPLL::J1 SNARK-DPLL::D) 1)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (- SNARK-DPLL::J1 SNARK-DPLL::D)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (INTEGER 1), not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK-DPLL::J1 SNARK-DPLL::D)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (INTEGER 1), not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (<= (+ SNARK-DPLL::J1 SNARK-DPLL::D) SNARK-DPLL::N)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (+ SNARK-DPLL::J1 SNARK-DPLL::D)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a (INTEGER 1), not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J1 SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           WHEN (>= (- SNARK-DPLL::J1 SNARK-DPLL::D) 1)
;           DO (SNARK-DPLL:DP-INSERT
;               (LIST `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I1 ,SNARK-DPLL::J1))
;                     `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I2 ,#)))
;               SNARK-DPLL::CLAUSE-SET)
;           WHEN ...)
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::J1 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I2 SNARK-DPLL::FROM (+ SNARK-DPLL::I1
;                                                              1) SNARK-DPLL::TO SNARK-DPLL::N SNARK-DPLL::AS SNARK-DPLL::D = (-
;                                                                                                                              SNARK-DPLL::I2
;                                                                                                                              SNARK-DPLL::I1)
;           DO ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> THE 1+ 
; ==>
;   (+ SNARK-DPLL::I2 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The result is a (VALUES (INTEGER 3) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The result is a (VALUES (INTEGER 3) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I1 SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                             SNARK-DPLL::N
;                                                                             1)
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::I2 SNARK-DPLL::FROM (+
;                                                                     SNARK-DPLL::I1
;                                                                     1) SNARK-DPLL::TO SNARK-DPLL::N SNARK-DPLL::AS SNARK-DPLL::D = (-
;                                                                                                                                     SNARK-DPLL::I2
;                                                                                                                                     SNARK-DPLL::I1)
;                    DO ...))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::I1 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-DPLL::N 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                            SNARK-DPLL::N
;                                                                            1)
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::K SNARK-DPLL::FROM (+
;                                                                    SNARK-DPLL::J
;                                                                    1) SNARK-DPLL::TO SNARK-DPLL::N
;                    DO (SNARK-DPLL:DP-INSERT (LIST `(NOT #) `(NOT #))
;                                             SNARK-DPLL::CLAUSE-SET) (SNARK-DPLL:DP-INSERT
;                                                                      (LIST
;                                                                       `(NOT #)
;                                                                       `(NOT #))
;                                                                      SNARK-DPLL::CLAUSE-SET)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::J #:LOOP-LIMIT-4899)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::I SNARK-DPLL::FROM 1 SNARK-DPLL::TO SNARK-DPLL::N
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                                     SNARK-DPLL::N
;                                                                                     1)
;                    DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::K SNARK-DPLL::FROM (+
;                                                                             SNARK-DPLL::J
;                                                                             1) SNARK-DPLL::TO SNARK-DPLL::N
;                             DO (SNARK-DPLL:DP-INSERT (LIST `# `#)
;                                                      SNARK-DPLL::CLAUSE-SET) (SNARK-DPLL:DP-INSERT
;                                                                               (LIST
;                                                                                `#
;                                                                                `#)
;                                                                               SNARK-DPLL::CLAUSE-SET))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK-DPLL::J 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::K SNARK-DPLL::FROM (+ SNARK-DPLL::J
;                                                             1) SNARK-DPLL::TO SNARK-DPLL::N
;           DO (SNARK-DPLL:DP-INSERT
;               (LIST `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I ,SNARK-DPLL::J))
;                     `(NOT (SNARK-DPLL::Q ,SNARK-DPLL::I ,SNARK-DPLL::K)))
;               SNARK-DPLL::CLAUSE-SET) (SNARK-DPLL:DP-INSERT
;                                        (LIST
;                                         `(NOT
;                                           (SNARK-DPLL::Q ,SNARK-DPLL::J
;                                            ,SNARK-DPLL::I))
;                                         `(NOT
;                                           (SNARK-DPLL::Q ,SNARK-DPLL::K
;                                            ,SNARK-DPLL::I)))
;                                        SNARK-DPLL::CLAUSE-SET))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-DPLL::K #:LOOP-LIMIT-4900)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The result is a (VALUES (INTEGER 3) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 2), not a FIXNUM.
;       The result is a (VALUES (INTEGER 3) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK-DPLL::FOR SNARK-DPLL::J SNARK-DPLL::FROM 1 SNARK-DPLL::TO (-
;                                                                            SNARK-DPLL::N
;                                                                            1)
;           DO (LOOP SNARK-DPLL::FOR SNARK-DPLL::K SNARK-DPLL::FROM (+
;                                                                    SNARK-DPLL::J
;                                                                    1) SNARK-DPLL::TO SNARK-DPLL::N
;                    DO (SNARK-DPLL:DP-INSERT (LIST `(NOT #) `(NOT #))
;                                             SNARK-DPLL::CLAUSE-SET) (SNARK-DPLL:DP-INSERT
;                                                                      (LIST
;                                                                       `(NOT #)
;                                                                       `(NOT #))
;                                                                      SNARK-DPLL::CLAUSE-SET)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-DPLL::J 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN GRAPH-COLORING-PROBLEM-CLAUSES ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/davis-putnam3.fasl written
; compilation finished in 0:00:01.032
WARNING: SNARK also exports the following symbols:
  (SNARK:DEFAULT-NUMBER-OF-GIVEN-ROWS-LIMIT SNARK:DEFAULT-REFUTE-FILE-OPTIONS? SNARK:DEFAULT-PRINT-ROW-REASONS SNARK:DEFAULT-PRINT-TIME-USED? SNARK:DEFAULT-FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING? SNARK:ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS? SNARK:DEFAULT-PROVE-SEQUENTIAL SNARK:DEFAULT-PRINT-ROWS-PRETTILY SNARK:DEFAULT-TEST-OPTION53 SNARK:DEFAULT-ASSERT-SUPPORTED? SNARK:USE-MAGIC-TRANSFORMATION? SNARK:DEFAULT-PRINT-ROWS-WHEN-GIVEN SNARK:DEFAULT-ROW-PRIORITY-DEPTH-FACTOR SNARK:DEFAULT-USE-SIMPLIFICATION-BY-EQUALITIES? SNARK:TEST-OPTION56? SNARK:USE-RESOLUTION SNARK:TEST-OPTION29? SNARK:DEFAULT-EX-JOIN-NEGATION? SNARK:DEFAULT-TRACE-DPLL-SUBSUMPTION SNARK:USE-SUBSUMPTION-BY-FALSE SNARK:DEFAULT-PRINT-IRRELEVANT-ROWS? SNARK:PRINT-ROWS-WHEN-GIVEN SNARK:DEFAULT-TEST-OPTION19 SNARK:TRACE-DP-REFUTE SNARK:TEST-OPTION43 SNARK:DEFAULT-VARIABLE-SYMBOL-PREFIXES SNARK:DEFAULT-TIME-INTERVAL-SORT-NAME? SNARK:EX-JOIN-NEGATION? SNARK:CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION? SNARK:DEFAULT-FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING SNARK:ASSERTION-FILE-FORMAT SNARK:TEST-OPTION49 SNARK:DEFAULT-TEST-OPTION51? SNARK:ROW-PRIORITY-WEIGHT-FACTOR SNARK:DEFAULT-CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION? SNARK:DEFAULT-REFUTE-FILE-INITIALIZE? SNARK:REWRITE-CONSTRAINTS SNARK:TEST-OPTION37? SNARK:DEFAULT-PRINT-ROWS-PRETTILY? SNARK:USE-SUBSUME-BAG? SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION SNARK:USE-UNIT-RESTRICTION SNARK:DEFAULT-TEST-OPTION3? SNARK:DEFAULT-PARTITION-COMMUNICATION-TABLE SNARK:DEFAULT-USE-HYPERRESOLUTION SNARK:USE-QUANTIFIER-PRESERVATION SNARK:DEFAULT-CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION SNARK:AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT SNARK:REWRITE-CONSTRAINTS? SNARK:PRINT-ROWS-PRETTILY? SNARK:DEFAULT-REFUTE-FILE-OPTIONS SNARK:ASSERTION-FILE-COMMANDS? SNARK:DEFAULT-USE-ASSERTION-ANALYSIS? SNARK:DEFAULT-USE-DP-SUBSUMPTION? SNARK:DEFAULT-TEST-OPTION55 SNARK:USE-ASSERTION-ANALYSIS? SNARK:DEFAULT-USE-INDEFINITE-ANSWERS? SNARK:DEFAULT-USE-TERM-ORDERING-CACHE? SNARK:DEFAULT-USE-FUNCTION-CREATION SNARK:DEFAULT-PRINT-ROWS-WHEN-DERIVED SNARK:DEFAULT-PRINT-REWRITE-ORIENTATION SNARK:DEFAULT-METER-UNIFY-BAG SNARK:VARIABLE-SORT-MARKER? SNARK:DEFAULT-TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION? SNARK:USE-REPLACEMENT-RESOLUTION-WITH-X=X? SNARK:RUN-TIME-LIMIT? SNARK:USE-EXTENDED-IMPLICATIONS SNARK:DEFAULT-USE-DP-SUBSUMPTION SNARK:USE-DEFAULT-ORDERING SNARK:USE-LITERAL-ORDERING-WITH-PARAMODULATION SNARK:USE-LITERAL-ORDERING-WITH-PARAMODULATION? SNARK:ASSERTION-FILE-NEGATE-CONJECTURES SNARK:TRACE-DPLL-SUBSUMPTION SNARK:DEFAULT-VARIABLE-WEIGHT SNARK:DEFAULT-PRINT-ROWS-WHEN-PROCESSED? SNARK:DEFAULT-TEST-OPTION2 SNARK:DEFAULT-USE-CLOSURE-WHEN-SATISFIABLE SNARK:TEST-OPTION8? SNARK:DECLARE-ROOT-SORT? SNARK:DEFAULT-USE-PARAMODULATION-ONLY-INTO-UNITS? SNARK:DEFAULT-PRINT-OPTIONS-WHEN-STARTING SNARK:DEFAULT-ASSERTION-FILE-VERBOSE SNARK:CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION SNARK:DEFAULT-UNIFY-BAG-BASIS-SIZE-LIMIT SNARK:DEFAULT-REWRITE-ANSWERS SNARK:DEFAULT-TEST-OPTION37? SNARK:TEST-OPTION41 SNARK:KBO-STATUS SNARK:USE-DP-SUBSUMPTION? SNARK:USE-CONDENSING SNARK:DEFAULT-TEST-OPTION52 SNARK:USE-PURITY-TEST? SNARK:DEFAULT-ASSERTION-FILE-NEGATE-CONJECTURES? SNARK:DEFAULT-TEST-OPTION6 SNARK:DEFAULT-USE-SINGLE-REPLACEMENT-PARAMODULATION? SNARK:DEFAULT-PRINT-FINAL-ROWS? SNARK:DEFAULT-USE-CONDENSING? SNARK:DEFAULT-ASSERTION-FILE-KEYWORDS SNARK:DEFAULT-TEST-OPTION6? SNARK:REFUTE-FILE-IGNORE-ERRORS SNARK:DEFAULT-USE-PURITY-TEST? SNARK:DEFAULT-TRACE-UNIFY-BAG-BASIS? SNARK:DEFAULT-USE-WELL-SORTING SNARK:PRINT-TERM-MEMORY-WHEN-FINISHED? SNARK:TEST-OPTION54? SNARK:VARIABLE-SYMBOL-PREFIXES? SNARK:ASSERTION-FILE-IF-DOES-NOT-EXIST SNARK:USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION? SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-PARAMODULATION? SNARK:DEFAULT-TEST-OPTION59 SNARK:PRUNING-TESTS SNARK:TEST-OPTION14 SNARK:PRUNING-TESTS-BEFORE-SIMPLIFICATION? SNARK:DEFAULT-USE-QUANTIFIER-PRESERVATION SNARK:DEFAULT-TEST-OPTION39? SNARK:DEFAULT-TEST-OPTION52? SNARK:DEFAULT-RUN-TIME-LIMIT SNARK:PRINT-IRRELEVANT-ROWS? SNARK:METER-UNIFY-BAG SNARK:DEFAULT-PRINT-TIME-USED SNARK:DEFAULT-ROW-WEIGHT-LIMIT SNARK:DEFAULT-VARIABLE-TO-LISP-CODE? SNARK:PRINT-ROWS-TEST? SNARK:USE-SUBSUME-BAG SNARK:USE-CONSTRAINT-PURIFICATION SNARK:ROW-PRIORITY-SIZE-FACTOR? SNARK:USE-ANSWERS-DURING-SUBSUMPTION? SNARK:DEFAULT-TEST-OPTION36 SNARK:ROW-PRIORITY-SIZE-FACTOR SNARK:DEFAULT-ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS SNARK:DEFAULT-ROW-PRIORITY-SIZE-FACTOR? SNARK:ORDERING-FUNCTIONS>CONSTANTS? SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION? SNARK:ORDERING-FUNCTIONS>CONSTANTS SNARK:PRINT-ROWS-WHEN-FINISHED? SNARK:TEST-OPTION45? SNARK:DEFAULT-LEVEL-PREF-FOR-GIVING? SNARK:TEST-OPTION36 SNARK:REFUTE-FILE-OUTPUT-FILE? SNARK:USE-PARAMODULATION? SNARK:USE-ASSOCIATIVE-IDENTITY SNARK:PRINT-SUMMARY-WHEN-FINISHED SNARK:RPO-STATUS? SNARK:USE-WELL-SORTING? SNARK:USE-SIMPLIFICATION-BY-UNITS SNARK:PRINT-ROW-REASONS? SNARK:USE-PARTITIONS? SNARK:INPUT-FLOATS-AS-RATIOS SNARK:TEST-OPTION50? SNARK:DEFAULT-TEST-OPTION23? SNARK:DEFAULT-PRINT-ROWS-WHEN-FINISHED? SNARK:DEFAULT-ROW-PRIORITY-DEPTH-FACTOR? SNARK:DEFAULT-REFUTE-FILE-IF-EXISTS SNARK:TEST-OPTION36? SNARK:DEFAULT-TEST-OPTION44 SNARK:DEFAULT-PRINT-AGENDA-WHEN-FINISHED? SNARK:TEST-OPTION44? SNARK:USE-TO-LISP-CODE? SNARK:DEFAULT-TRACE-UNIFY SNARK:USE-WELL-SORTING SNARK:USE-RESOLVE-CODE? SNARK:KBO-STATUS? SNARK:DEFAULT-EX-JOIN-NEGATION SNARK:DEFAULT-TEST-OPTION38 SNARK:DEFAULT-USE-SUBSUMPTION SNARK:DEFAULT-TEST-OPTION59? SNARK:DEFAULT-TEST-OPTION49? SNARK:USE-TO-LISP-CODE SNARK:PROVE-CLOSURE? SNARK:TEST-OPTION17 SNARK:USE-EXTENDED-IMPLICATIONS? SNARK:TEST-OPTION60 SNARK:DEFAULT-ASSERTION-FILE-PACKAGE SNARK:EX-JOIN-NEGATION SNARK:DEFAULT-USE-TERM-ORDERING-CACHE SNARK:DEFAULT-TEST-OPTION60 SNARK:PRINT-ROWS-TEST SNARK:DEFAULT-PRINT-OPTIONS-WHEN-STARTING? SNARK:DEFAULT-PRINT-ROW-GOALS? SNARK:DEFAULT-USE-UR-RESOLUTION SNARK:DEFAULT-ROW-PRIORITY-WEIGHT-FACTOR? SNARK:DEFAULT-PRINT-ROWS-TEST? SNARK:TEST-OPTION39? SNARK:USE-TERM-ORDERING? SNARK:DEFAULT-PRINT-ROW-ANSWERS SNARK:DEFAULT-RCC8-REGION-SORT-NAME SNARK:DEFAULT-AGENDA-LENGTH-LIMIT? SNARK:DEFAULT-TEST-OPTION58 SNARK:USE-RELEVANCE-TEST SNARK:TEST-OPTION52 SNARK:DEFAULT-USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION SNARK:DEFAULT-PRINT-CLOCKS-WHEN-FINISHED SNARK:DEFAULT-PROVE-SUPPORTED SNARK:PRINT-ROW-PARTITIONS SNARK:USE-FACTORING? SNARK:TRACE-UNIFY? SNARK:PRINT-CLOCKS-WHEN-FINISHED SNARK:DEFAULT-REFUTE-FILE-ACTIONS? SNARK:LEVEL-PREF-FOR-GIVING? SNARK:DEFAULT-ASSERTION-FILE-IF-DOES-NOT-EXIST? SNARK:DEFAULT-USE-UNIT-RESTRICTION? SNARK:USE-ANSWERS-DURING-SUBSUMPTION SNARK:DEFAULT-USE-RESOLVE-CODE SNARK:USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION SNARK:DEFAULT-PRINT-ROW-LENGTH-LIMIT? SNARK:DEFAULT-USE-FUNCTION-CREATION? SNARK:PRINT-ROWS-SHORTENED SNARK:DEFAULT-USE-INPUT-RESTRICTION? SNARK:DEFAULT-KBO-VARIABLE-WEIGHT? SNARK:USE-FUNCTION-CREATION SNARK:BAG-WEIGHT-FACTORIAL? SNARK:DEFAULT-USE-SORT-RELATIVIZATION SNARK:USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION SNARK:DEFAULT-ASSERTION-FILE-READTABLE? SNARK:DEFAULT-PRINT-GIVEN-ROW-LINES-SIGNALLING SNARK:DEFAULT-USE-AC-CONNECTIVES? SNARK:ASSERT-SUPPORTED? SNARK:DEFAULT-PRINT-SYMBOL-TABLE-WARNINGS? SNARK:RUN-TIME-LIMIT SNARK:DEFAULT-PROVE-SUPPORTED? SNARK:AGENDA-ORDERING-FUNCTION? SNARK:PRINT-GIVEN-ROW-LINES-SIGNALLING SNARK:USE-INDEFINITE-ANSWERS SNARK:FLATTEN-CONNECTIVES SNARK:DEFAULT-TEST-OPTION2? SNARK:TRACE-UNIFY-BAG-BASIS SNARK:USE-UR-RESOLUTION SNARK:DEFAULT-AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT SNARK:DEFAULT-TIME-POINT-SORT-NAME SNARK:DEFAULT-TEST-OPTION50 SNARK:VARIABLE-WEIGHT SNARK:ASSERTION-FILE-KEYWORDS SNARK:DEFAULT-TEST-OPTION23 SNARK:DEFAULT-USE-QUANTIFIER-PRESERVATION? SNARK:DEFAULT-USE-TO-LISP-CODE? SNARK:PROVE-SUPPORTED? SNARK:TEST-OPTION29 SNARK:REFUTE-FILE-INITIALIZE SNARK:USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION? SNARK:DEFAULT-TEST-OPTION53? SNARK:TEST-OPTION6? SNARK:DEFAULT-USE-ASSOCIATIVE-IDENTITY? SNARK:TEST-OPTION51? SNARK:DEFAULT-USE-SUBSUMPTION-BY-FALSE? SNARK:PRINT-ROW-ANSWERS SNARK:DEFAULT-ASSERTION-FILE-NEGATE-CONJECTURES SNARK:PRINT-ROW-GOALS? SNARK:DEFAULT-PRINT-REWRITE-ORIENTATION? SNARK:DEFAULT-REFUTE-FILE-OUTPUT-FILE? SNARK:DEFAULT-TRACE-REWRITE? SNARK:TEST-OPTION14? SNARK:DEFAULT-TEST-OPTION60? SNARK:DEFAULT-ASSERTION-FILE-VERBOSE? SNARK:DEFAULT-1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING SNARK:USE-CLAUSIFICATION SNARK:TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION? SNARK:TEST-OPTION55? SNARK:DEFAULT-PRINT-TERM-MEMORY-WHEN-FINISHED? SNARK:PRINT-ROWS-WHEN-DERIVED SNARK:TEST-OPTION57 SNARK:PRINT-AGENDA-WHEN-FINISHED? SNARK:TEST-OPTION21? SNARK:TEST-OPTION8 SNARK:PRINT-ROW-WFFS-PRETTILY? SNARK:USE-LITERAL-ORDERING-WITH-RESOLUTION? SNARK:DEFAULT-USE-RESOLUTION? SNARK:USE-CONSTRAINT-PURIFICATION? SNARK:VARIABLE-TO-LISP-CODE SNARK:PRINT-OPTIONS-WHEN-STARTING? SNARK:TEST-OPTION40? SNARK:DEFAULT-1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING? SNARK:DEFAULT-TEST-OPTION39 SNARK:DEFAULT-USE-FACTORING SNARK:TEST-OPTION2 SNARK:PRINT-GIVEN-ROW-LINES-SIGNALLING? SNARK:DEFAULT-ASSUME-SEQUENTIAL? SNARK:PRINT-IRRELEVANT-ROWS SNARK:REWRITE-ANSWERS SNARK:DEFAULT-ASSERTION-FILE-COMMANDS SNARK:DEFAULT-INPUT-FLOATS-AS-RATIOS? SNARK:TRACE-UNIFY-BAG-BINDINGS? SNARK:DEFAULT-ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT? SNARK:DEFAULT-ORDERING-FUNCTIONS>CONSTANTS? SNARK:DEFAULT-ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT SNARK:PRINT-GIVEN-ROW-LINES-PRINTING SNARK:USE-MAGIC-TRANSFORMATION SNARK:DEFAULT-PRINT-ROW-GOALS SNARK:1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING? SNARK:DEFAULT-USE-CLAUSIFICATION SNARK:TEST-OPTION3? SNARK:USE-PARAMODULATION-ONLY-INTO-UNITS? SNARK:DEFAULT-USE-REPLACEMENT-RESOLUTION-WITH-X=X SNARK:1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING SNARK:PRINT-ROW-LENGTH-LIMIT SNARK:BUILTIN-CONSTANT-WEIGHT SNARK:USE-EQUALITY-ELIMINATION? SNARK:DEFAULT-DECLARE-STRING-SORT SNARK:DEFAULT-PRINT-ROWS-WHEN-FINISHED SNARK:TEST-OPTION52? SNARK:USE-SIMPLIFICATION-BY-EQUALITIES? SNARK:REFUTE-FILE-INITIALIZE? SNARK:TEST-OPTION41? SNARK:DEFAULT-TRACE-UNIFY-BAG-BASIS SNARK:USE-SUBSUMPTION SNARK:TIME-POINT-SORT-NAME? SNARK:TRACE-UNIFY SNARK:PRINT-SUMMARY-WHEN-FINISHED? SNARK:DEFAULT-TEST-OPTION58? SNARK:TEST-OPTION19? SNARK:DEFAULT-TEST-OPTION14? SNARK:DEFAULT-ASSERTION-FILE-PACKAGE? SNARK:DEFAULT-TIME-POINT-SORT-NAME? SNARK:USE-EQUALITY-ELIMINATION SNARK:ROW-PRIORITY-DEPTH-FACTOR SNARK:DEFAULT-TEST-OPTION30 SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-RESOLUTION? SNARK:DEFAULT-RPO-STATUS SNARK:DEFAULT-TRACE-DPLL-SUBSUMPTION? SNARK:DEFAULT-CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT SNARK:DEFAULT-AGENDA-ORDERING-FUNCTION SNARK:TIME-INTERVAL-SORT-NAME SNARK:DEFAULT-INPUT-FLOATS-AS-RATIOS SNARK:DEFAULT-USE-SUBSUMPTION? SNARK:DEFAULT-USE-PARTITIONS SNARK:DEFAULT-USE-PARAMODULATION SNARK:TRACE-UNIFY-BAG-BASIS? SNARK:RCC8-REGION-SORT-NAME? SNARK:DECLARE-ROOT-SORT SNARK:ROW-PRIORITY-LEVEL-FACTOR SNARK:USE-ASSOCIATIVE-IDENTITY? SNARK:USE-EXTENDED-QUANTIFIERS SNARK:DEFAULT-TEST-OPTION17 SNARK:USE-TERM-MEMORY-DELETION SNARK:TEST-OPTION44 SNARK:USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION? SNARK:DEFAULT-TEST-OPTION3 SNARK:DEFAULT-PRINT-ROWS-WHEN-PROCESSED SNARK:DEFAULT-BUILTIN-CONSTANT-WEIGHT SNARK:PRINT-FINAL-ROWS? SNARK:DEFAULT-PRINT-ROW-PARTITIONS? SNARK:USE-TERM-ORDERING-CACHE SNARK:DEFAULT-USE-TERM-ORDERING SNARK:DEFAULT-ELIMINATE-NEGATIONS? SNARK:DEFAULT-PROVE-SEQUENTIAL? SNARK:USE-SUBSUMPTION? SNARK:USE-UR-PTTP? SNARK:DEFAULT-USE-DEFAULT-ORDERING? SNARK:PRINT-UNORIENTABLE-ROWS? SNARK:USE-SORT-RELATIVIZATION? SNARK:DEFAULT-USE-DEFAULT-ORDERING SNARK:VARIABLE-SYMBOL-PREFIXES SNARK:TEST-OPTION60? SNARK:DEFAULT-USE-REPLACEMENT-RESOLUTION-WITH-X=X? SNARK:DEFAULT-TEST-OPTION41? SNARK:USE-DEFAULT-ORDERING? SNARK:DEFAULT-TEST-OPTION56? SNARK:PRINT-FINAL-ROWS SNARK:TEST-OPTION49? SNARK:USE-CONDITIONAL-ANSWER-CREATION? SNARK:DEFAULT-USE-UNIT-RESTRICTION SNARK:DEFAULT-RPO-STATUS? SNARK:DEFAULT-PRINT-ROWS-WHEN-DERIVED? SNARK:KBO-BUILTIN-CONSTANT-WEIGHT? SNARK:DEFAULT-TIME-INTERVAL-SORT-NAME SNARK:TEST-OPTION43? SNARK:USE-RESOLVE-CODE SNARK:ELIMINATE-NEGATIONS SNARK:PRINT-ROW-WFFS-PRETTILY SNARK:DEFAULT-USE-CONSTRAINT-PURIFICATION? SNARK:DEFAULT-REFUTE-FILE-OUTPUT-FILE SNARK:DEFAULT-TRACE-UNIFY? SNARK:DEFAULT-USE-INPUT-RESTRICTION SNARK:DEFAULT-AGENDA-LENGTH-LIMIT SNARK:LISTEN-FOR-COMMANDS SNARK:DEFAULT-TEST-OPTION45 SNARK:DEFAULT-PRINT-ROW-WFFS-PRETTILY? SNARK:DEFAULT-USE-EQUALITY-ELIMINATION? SNARK:DEFAULT-PRINT-TERM-MEMORY-WHEN-FINISHED SNARK:USE-LITERAL-ORDERING-WITH-RESOLUTION SNARK:USE-LITERAL-ORDERING-WITH-UR-RESOLUTION? SNARK:PRINT-ROW-PARTITIONS? SNARK:REFUTE-FILE-IGNORE-ERRORS? SNARK:DEFAULT-USE-PARAMODULATION-ONLY-FROM-UNITS? SNARK:DEFAULT-USE-VARIABLE-NAME-SORTS SNARK:DEFAULT-PRUNING-TESTS SNARK:DEFAULT-AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT? SNARK:DEFAULT-VARIABLE-SYMBOL-PREFIXES? SNARK:DEFAULT-RUN-TIME-LIMIT? SNARK:DEFAULT-TRACE-DP-REFUTE SNARK:ASSERTION-FILE-PACKAGE? SNARK:ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT? SNARK:DEFAULT-PRINT-ROWS-SHORTENED? SNARK:DEFAULT-TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION SNARK:DEFAULT-REFUTE-FILE-CLOSURE SNARK:DEFAULT-USE-CLOSURE-WHEN-SATISFIABLE? SNARK:TEST-OPTION50 SNARK:PRINT-ROWS-SHORTENED? SNARK:DEFAULT-USE-SIMPLIFICATION-BY-EQUALITIES SNARK:DEFAULT-UNIFY-BAG-BASIS-SIZE-LIMIT? SNARK:PRINT-TERM-MEMORY-WHEN-FINISHED SNARK:PROVE-CLOSURE SNARK:DEFAULT-ROW-ARGUMENT-COUNT-LIMIT? SNARK:DEFAULT-USE-AC-CONNECTIVES SNARK:DEFAULT-USE-PARAMODULATION-ONLY-FROM-UNITS SNARK:TEST-OPTION20? SNARK:DEFAULT-PRINT-ROW-WFFS-PRETTILY SNARK:USE-CONDITIONAL-ANSWER-CREATION SNARK:DEFAULT-USE-CONSTRUCTIVE-ANSWER-RESTRICTION? SNARK:TRACE-DPLL-SUBSUMPTION? SNARK:TEST-OPTION59? SNARK:AGENDA-ORDERING-FUNCTION SNARK:TEST-OPTION59 SNARK:AGENDA-LENGTH-LIMIT? SNARK:DEFAULT-ASSUME-SUPPORTED SNARK:TEST-OPTION6 SNARK:ASSUME-SUPPORTED SNARK:DEFAULT-ASSERTION-FILE-COMMANDS? SNARK:PRUNING-TESTS-BEFORE-SIMPLIFICATION SNARK:DEFAULT-PRINT-ROW-LENGTH-LIMIT SNARK:USE-VARIABLE-NAME-SORTS? SNARK:DEFAULT-USE-EXTENDED-IMPLICATIONS? SNARK:DEFAULT-DECLARE-ROOT-SORT? SNARK:FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING SNARK:DEFAULT-USE-SIMPLIFICATION-BY-UNITS SNARK:DEFAULT-TEST-OPTION56 SNARK:DEFAULT-USE-EQUALITY-FACTORING SNARK:DECLARE-STRING-SORT SNARK:DEFAULT-TEST-OPTION54 SNARK:DEFAULT-TEST-OPTION30? SNARK:DEFAULT-TEST-OPTION43? SNARK:USE-ASSOCIATIVE-UNIFICATION SNARK:TRACE-REWRITE SNARK:PRINT-ASSERTION-ANALYSIS-NOTES? SNARK:ASSERTION-FILE-VERBOSE? SNARK:DEFAULT-USE-TERM-ORDERING? SNARK:DEFAULT-USE-TERM-MEMORY-DELETION SNARK:TEST-OPTION40 SNARK:DEFAULT-ASSERT-SEQUENTIAL? SNARK:DEFAULT-PRINT-ROWS-SHORTENED SNARK:USE-UR-RESOLUTION? SNARK:USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION SNARK:DEFAULT-VARIABLE-SORT-MARKER? SNARK:DEFAULT-TEST-OPTION20? SNARK:DEFAULT-TEST-OPTION40 SNARK:ROW-WEIGHT-LIMIT SNARK:DEFAULT-TEST-OPTION54? SNARK:DEFAULT-KBO-STATUS SNARK:USE-AC-CONNECTIVES? SNARK:DEFAULT-VARIABLE-TO-LISP-CODE SNARK:DEFAULT-USE-TO-LISP-CODE SNARK:NUMBER-OF-ROWS-LIMIT SNARK:DEFAULT-TEST-OPTION20 SNARK:DEFAULT-TEST-OPTION45? SNARK:DEFAULT-REFUTE-FILE-ACTIONS SNARK:TEST-OPTION42 SNARK:TEST-OPTION38? SNARK:TRACE-REWRITE? SNARK:ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT SNARK:DEFAULT-USE-UR-RESOLUTION? SNARK:DEFAULT-USE-RESOLVE-CODE? SNARK:DEFAULT-NUMBER-OF-GIVEN-ROWS-LIMIT? SNARK:ASSUME-SEQUENTIAL SNARK:USE-EQUALITY-FACTORING SNARK:REFUTE-FILE-ACTIONS? SNARK:USE-HYPERRESOLUTION? SNARK:PROVE-SUPPORTED SNARK:ASSERTION-FILE-NEGATE-CONJECTURES? SNARK:USE-INPUT-RESTRICTION SNARK:DEFAULT-USE-CONDITIONAL-ANSWER-CREATION? SNARK:DEFAULT-USE-MAGIC-TRANSFORMATION? SNARK:DEFAULT-REWRITE-ANSWERS? SNARK:DEFAULT-ROW-PRIORITY-WEIGHT-FACTOR SNARK:DEFAULT-PRINT-UNORIENTABLE-ROWS SNARK:PRINT-ROWS-PRETTILY SNARK:PRINT-ROW-ANSWERS? SNARK:DEFAULT-KBO-VARIABLE-WEIGHT SNARK:PROVE-SEQUENTIAL? SNARK:ELIMINATE-NEGATIONS? SNARK:RPO-STATUS SNARK:DEFAULT-ASSERTION-FILE-KEYWORDS? SNARK:DEFAULT-ROW-PRIORITY-SIZE-FACTOR SNARK:USE-AC-CONNECTIVES SNARK:DEFAULT-PRINT-ROW-PARTITIONS SNARK:DEFAULT-RCC8-REGION-SORT-NAME? SNARK:USE-EMBEDDED-REWRITES? SNARK:DEFAULT-PRINT-ASSERTION-ANALYSIS-NOTES? SNARK:DEFAULT-USE-CONSTRUCTIVE-ANSWER-RESTRICTION SNARK:PRINT-AGENDA-WHEN-FINISHED SNARK:DEFAULT-PRINT-PURE-ROWS SNARK:PRINT-ROWS-WHEN-PROCESSED? SNARK:TEST-OPTION51 SNARK:DEFAULT-AGENDA-ORDERING-FUNCTION? SNARK:DEFAULT-ROW-PRIORITY-LEVEL-FACTOR? SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-PARAMODULATION SNARK:DEFAULT-TEST-OPTION50? SNARK:ASSUME-SUPPORTED? SNARK:ROW-PRIORITY-LEVEL-FACTOR? SNARK:DEFAULT-USE-SUBSUME-BAG SNARK:DEFAULT-TEST-OPTION29 SNARK:DEFAULT-ASSUME-SEQUENTIAL SNARK:TEST-OPTION42? SNARK:DEFAULT-TEST-OPTION19? SNARK:TEST-OPTION53 SNARK:TEST-OPTION57? SNARK:USE-TERM-MEMORY-DELETION? SNARK:DEFAULT-USE-EQUALITY-FACTORING? SNARK:DEFAULT-FLATTEN-CONNECTIVES? SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT SNARK:USE-SIMPLIFICATION-BY-UNITS? SNARK:PRINT-ROW-CONSTRAINTS? SNARK:DEFAULT-LISTEN-FOR-COMMANDS? SNARK:DEFAULT-PRINT-ROW-REASONS? SNARK:DEFAULT-ASSERTION-FILE-READTABLE SNARK:ASSERTION-FILE-COMMANDS SNARK:DEFAULT-USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION? SNARK:DEFAULT-ROW-PRIORITY-LEVEL-FACTOR SNARK:ROW-PRIORITY-WEIGHT-FACTOR? SNARK:DEFAULT-VARIABLE-SORT-MARKER SNARK:PRINT-REWRITE-ORIENTATION? SNARK:RCC8-REGION-SORT-NAME SNARK:DEFAULT-USE-MAGIC-TRANSFORMATION SNARK:DEFAULT-USE-HYPERRESOLUTION? SNARK:REFUTE-FILE-ACTIONS SNARK:PRINT-ROWS-WHEN-DERIVED? SNARK:USE-SORT-RELATIVIZATION SNARK:DEFAULT-REFUTE-FILE-VERBOSE SNARK:DEFAULT-ASSERT-SUPPORTED SNARK:TEST-OPTION20 SNARK:PRINT-OPTIONS-WHEN-STARTING SNARK:PRINT-CLOCKS-WHEN-FINISHED? SNARK:USE-CLOSURE-WHEN-SATISFIABLE? SNARK:DEFAULT-REWRITE-CONSTRAINTS? SNARK:DEFAULT-USE-ANSWERS-DURING-SUBSUMPTION SNARK:PRINT-REWRITE-ORIENTATION SNARK:USE-ASSERTION-ANALYSIS SNARK:DEFAULT-REWRITE-CONSTRAINTS SNARK:DEFAULT-TEST-OPTION21 SNARK:USE-CLOSURE-WHEN-SATISFIABLE SNARK:AGENDA-LENGTH-LIMIT SNARK:TEST-OPTION54 SNARK:FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING? SNARK:DEFAULT-TEST-OPTION29? SNARK:DEFAULT-TEST-OPTION9? SNARK:ASSERTION-FILE-FORMAT? SNARK:DEFAULT-TEST-OPTION42? SNARK:DEFAULT-USE-ASSOCIATIVE-UNIFICATION SNARK:DEFAULT-TEST-OPTION38? SNARK:ASSERT-CONTEXT? SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT? SNARK:DEFAULT-USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION SNARK:DEFAULT-USE-RESOLUTION SNARK:VARIABLE-SORT-MARKER SNARK:DEFAULT-PRINT-IRRELEVANT-ROWS SNARK:USE-EQUALITY-FACTORING? SNARK:DEFAULT-REFUTE-FILE-IGNORE-ERRORS SNARK:DEFAULT-USE-TERM-MEMORY-DELETION? SNARK:USE-CLAUSIFICATION? SNARK:TEST-OPTION37 SNARK:DEFAULT-TEST-OPTION17? SNARK:USE-UNIT-RESTRICTION? SNARK:USE-QUANTIFIER-PRESERVATION? SNARK:PRINT-ROWS-WHEN-PROCESSED SNARK:USE-SINGLE-REPLACEMENT-PARAMODULATION SNARK:DEFAULT-PRINT-ROWS-WHEN-GIVEN? SNARK:DEFAULT-USE-ANSWERS-DURING-SUBSUMPTION? SNARK:PRINT-ROW-REASONS SNARK:USE-ASSOCIATIVE-UNIFICATION? SNARK:DEFAULT-ASSERT-CONTEXT SNARK:TIME-INTERVAL-SORT-NAME? SNARK:DEFAULT-PRINT-SYMBOL-TABLE-WARNINGS SNARK:USE-EXTENDED-QUANTIFIERS? SNARK:REWRITE-ANSWERS? SNARK:DEFAULT-TEST-OPTION14 SNARK:DECLARE-STRING-SORT? SNARK:TEST-OPTION3 SNARK:REFUTE-FILE-VERBOSE SNARK:DEFAULT-USE-RELEVANCE-TEST? SNARK:PROVE-SEQUENTIAL SNARK:USE-CONSTRUCTIVE-ANSWER-RESTRICTION SNARK:DEFAULT-USE-PARTITIONS? SNARK:DEFAULT-USE-NEGATIVE-HYPERRESOLUTION SNARK:DEFAULT-USE-WELL-SORTING? SNARK:DEFAULT-KBO-BUILTIN-CONSTANT-WEIGHT SNARK:DEFAULT-PROVE-CLOSURE SNARK:DEFAULT-USE-PURITY-TEST SNARK:REFUTE-FILE-OPTIONS SNARK:DEFAULT-KBO-BUILTIN-CONSTANT-WEIGHT? SNARK:TEST-OPTION18? SNARK:DEFAULT-USE-SINGLE-REPLACEMENT-PARAMODULATION SNARK:ASSERT-CONTEXT SNARK:DEFAULT-PRINT-PURE-ROWS? SNARK:USE-PARAMODULATION-ONLY-FROM-UNITS? SNARK:DEFAULT-USE-EMBEDDED-REWRITES SNARK:DEFAULT-ASSERTION-FILE-IF-DOES-NOT-EXIST SNARK:LEVEL-PREF-FOR-GIVING SNARK:DEFAULT-REFUTE-FILE-INITIALIZE SNARK:DEFAULT-TEST-OPTION57? SNARK:DEFAULT-USE-FACTORING? SNARK:BAG-WEIGHT-FACTORIAL SNARK:USE-SUBSUMPTION-BY-FALSE? SNARK:USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION? SNARK:NUMBER-OF-ROWS-LIMIT? SNARK:USE-FUNCTION-CREATION? SNARK:TRACE-UNIFY-BAG-BINDINGS SNARK:ASSERTION-FILE-KEYWORDS? SNARK:DEFAULT-TEST-OPTION43 SNARK:DEFAULT-TEST-OPTION42 SNARK:REFUTE-FILE-OUTPUT-FILE SNARK:USE-PARAMODULATION-ONLY-FROM-UNITS SNARK:PARTITION-COMMUNICATION-TABLE? SNARK:DEFAULT-PRUNING-TESTS-BEFORE-SIMPLIFICATION SNARK:DEFAULT-USE-ASSOCIATIVE-IDENTITY SNARK:DEFAULT-FLATTEN-CONNECTIVES SNARK:DEFAULT-USE-PARAMODULATION? SNARK:DEFAULT-ASSERT-CONTEXT? SNARK:DEFAULT-LISTEN-FOR-COMMANDS SNARK:REFUTE-FILE-VERBOSE? SNARK:ROW-ARGUMENT-COUNT-LIMIT SNARK:TEST-OPTION19 SNARK:USE-LITERAL-ORDERING-WITH-UR-RESOLUTION SNARK:DEFAULT-NUMBER-OF-ROWS-LIMIT? SNARK:DEFAULT-METER-UNIFY-BAG? SNARK:DEFAULT-BUILTIN-CONSTANT-WEIGHT? SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-RESOLUTION SNARK:CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT? SNARK:DEFAULT-USE-UR-PTTP SNARK:AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT? SNARK:USE-SINGLE-REPLACEMENT-PARAMODULATION? SNARK:DEFAULT-USE-RELEVANCE-TEST SNARK:DEFAULT-USE-CONSTRAINT-PURIFICATION SNARK:REFUTE-FILE-IF-EXISTS? SNARK:PRINT-ASSERTION-ANALYSIS-NOTES SNARK:LISTEN-FOR-COMMANDS? SNARK:DEFAULT-USE-CLAUSIFICATION? SNARK:DEFAULT-ROW-ARGUMENT-COUNT-LIMIT SNARK:FLATTEN-CONNECTIVES? SNARK:DEFAULT-PRINT-FINAL-ROWS SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION SNARK:PRINT-PURE-ROWS? SNARK:DEFAULT-TEST-OPTION57 SNARK:INPUT-FLOATS-AS-RATIOS? SNARK:USE-CONDENSING? SNARK:TEST-OPTION55 SNARK:DEFAULT-PRINT-GIVEN-ROW-LINES-PRINTING SNARK:USE-DP-SUBSUMPTION SNARK:METER-UNIFY-BAG? SNARK:TRACE-DP-REFUTE? SNARK:DEFAULT-PRINT-ROWS-TEST SNARK:USE-UR-PTTP SNARK:TEST-OPTION23 SNARK:USE-PURITY-TEST SNARK:PRINT-ROW-LENGTH-LIMIT? SNARK:REFUTE-FILE-OPTIONS? SNARK:DEFAULT-REFUTE-FILE-IGNORE-ERRORS? SNARK:USE-PARAMODULATION SNARK:USE-REPLACEMENT-RESOLUTION-WITH-X=X SNARK:DEFAULT-PRINT-ROW-CONSTRAINTS SNARK:DEFAULT-PRUNING-TESTS-BEFORE-SIMPLIFICATION? SNARK:DEFAULT-USE-NEGATIVE-HYPERRESOLUTION? SNARK:USE-PARTITIONS SNARK:REFUTE-FILE-CLOSURE SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-UR-RESOLUTION SNARK:DEFAULT-USE-SIMPLIFICATION-BY-UNITS? SNARK:TEST-OPTION2? SNARK:TEST-OPTION45 SNARK:USE-EMBEDDED-REWRITES SNARK:DEFAULT-ORDERING-FUNCTIONS>CONSTANTS SNARK:DEFAULT-TEST-OPTION18? SNARK:DEFAULT-ASSERTION-FILE-FORMAT? SNARK:ASSERTION-FILE-PACKAGE SNARK:DEFAULT-USE-EXTENDED-QUANTIFIERS SNARK:USE-NEGATIVE-HYPERRESOLUTION? SNARK:DEFAULT-USE-EQUALITY-ELIMINATION SNARK:DEFAULT-TEST-OPTION21? SNARK:DEFAULT-ASSUME-SUPPORTED? SNARK:DEFAULT-PRINT-CLOCKS-WHEN-FINISHED? SNARK:DEFAULT-TEST-OPTION37 SNARK:DEFAULT-REFUTE-FILE-IF-EXISTS? SNARK:USE-INDEFINITE-ANSWERS? SNARK:PRINT-PURE-ROWS SNARK:ROW-ARGUMENT-COUNT-LIMIT? SNARK:USE-RELEVANCE-TEST? SNARK:DEFAULT-TRACE-UNIFY-BAG-BINDINGS SNARK:ASSUME-SEQUENTIAL? SNARK:DEFAULT-USE-ASSERTION-ANALYSIS SNARK:USE-TERM-ORDERING-CACHE? SNARK:BUILTIN-CONSTANT-WEIGHT? SNARK:PRUNING-TESTS? SNARK:DEFAULT-USE-ASSOCIATIVE-UNIFICATION? SNARK:DEFAULT-ASSERT-SEQUENTIAL SNARK:DEFAULT-USE-PARAMODULATION-ONLY-INTO-UNITS SNARK:ASSERT-SEQUENTIAL? SNARK:PRINT-SYMBOL-TABLE-WARNINGS SNARK:DEFAULT-TEST-OPTION44? SNARK:USE-CONSTRUCTIVE-ANSWER-RESTRICTION? SNARK:DEFAULT-PARTITION-COMMUNICATION-TABLE? SNARK:CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT SNARK:USE-HYPERRESOLUTION SNARK:TEST-OPTION58? SNARK:TEST-OPTION9? SNARK:DEFAULT-LEVEL-PREF-FOR-GIVING SNARK:TEST-OPTION53? SNARK:PRINT-ROWS-WHEN-FINISHED SNARK:DEFAULT-PRINT-GIVEN-ROW-LINES-SIGNALLING? SNARK:REFUTE-FILE-IF-EXISTS SNARK:ASSERTION-FILE-VERBOSE SNARK:ASSERT-SUPPORTED SNARK:KBO-BUILTIN-CONSTANT-WEIGHT SNARK:TEST-OPTION30? SNARK:DEFAULT-TRACE-DP-REFUTE? SNARK:PRINT-TIME-USED SNARK:DEFAULT-CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT? SNARK:USE-INPUT-RESTRICTION? SNARK:USE-PARAMODULATION-ONLY-INTO-UNITS SNARK:TEST-OPTION21 SNARK:TEST-OPTION18 SNARK:PRINT-ROWS-WHEN-GIVEN? SNARK:DEFAULT-REFUTE-FILE-CLOSURE? SNARK:USE-TERM-ORDERING SNARK:DEFAULT-PRUNING-TESTS? SNARK:DEFAULT-DECLARE-STRING-SORT? SNARK:USE-RESOLUTION? SNARK:DEFAULT-TEST-OPTION51 SNARK:DEFAULT-TEST-OPTION40? SNARK:DEFAULT-DECLARE-ROOT-SORT SNARK:DEFAULT-TEST-OPTION41 SNARK:VARIABLE-TO-LISP-CODE? SNARK:DEFAULT-KBO-STATUS? SNARK:DEFAULT-USE-SUBSUME-BAG? SNARK:DEFAULT-TEST-OPTION36? SNARK:DEFAULT-PRINT-UNORIENTABLE-ROWS? SNARK:USE-VARIABLE-NAME-SORTS SNARK:DEFAULT-PRINT-AGENDA-WHEN-FINISHED SNARK:USE-NEGATIVE-HYPERRESOLUTION SNARK:DEFAULT-USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION? SNARK:DEFAULT-USE-CONDITIONAL-ANSWER-CREATION SNARK:DEFAULT-BAG-WEIGHT-FACTORIAL SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-UR-RESOLUTION? SNARK:DEFAULT-BAG-WEIGHT-FACTORIAL? SNARK:USE-SIMPLIFICATION-BY-EQUALITIES SNARK:TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION SNARK:PRINT-ROW-CONSTRAINTS SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT? SNARK:TEST-OPTION58 SNARK:KBO-VARIABLE-WEIGHT? SNARK:DEFAULT-PRINT-GIVEN-ROW-LINES-PRINTING? SNARK:ROW-WEIGHT-LIMIT? SNARK:TEST-OPTION17? SNARK:PARTITION-COMMUNICATION-TABLE SNARK:DEFAULT-USE-EXTENDED-IMPLICATIONS SNARK:ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS SNARK:PRINT-UNORIENTABLE-ROWS SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT SNARK:DEFAULT-ELIMINATE-NEGATIONS SNARK:PRINT-ROW-GOALS SNARK:PRINT-GIVEN-ROW-LINES-PRINTING? SNARK:PRINT-TIME-USED? SNARK:DEFAULT-USE-VARIABLE-NAME-SORTS? SNARK:ASSERT-SEQUENTIAL SNARK:ROW-PRIORITY-DEPTH-FACTOR? SNARK:DEFAULT-USE-SUBSUMPTION-BY-FALSE SNARK:DEFAULT-USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION? SNARK:DEFAULT-TEST-OPTION18 SNARK:DEFAULT-TEST-OPTION8 SNARK:DEFAULT-USE-UR-PTTP? SNARK:DEFAULT-PRINT-ROW-CONSTRAINTS? SNARK:ASSERTION-FILE-READTABLE SNARK:DEFAULT-USE-INDEFINITE-ANSWERS SNARK:TEST-OPTION38 SNARK:USE-FACTORING SNARK:ASSERTION-FILE-IF-DOES-NOT-EXIST? SNARK:ASSERTION-FILE-READTABLE? SNARK:DEFAULT-USE-EXTENDED-QUANTIFIERS? SNARK:DEFAULT-PRINT-SUMMARY-WHEN-FINISHED SNARK:TIME-POINT-SORT-NAME SNARK:DEFAULT-NUMBER-OF-ROWS-LIMIT SNARK:PRINT-SYMBOL-TABLE-WARNINGS? SNARK:DEFAULT-TEST-OPTION49 SNARK:DEFAULT-PRINT-ASSERTION-ANALYSIS-NOTES SNARK:USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION SNARK:DEFAULT-TEST-OPTION55? SNARK:DEFAULT-TRACE-UNIFY-BAG-BINDINGS? SNARK:DEFAULT-REFUTE-FILE-VERBOSE? SNARK:DEFAULT-TEST-OPTION8? SNARK:DEFAULT-ASSERTION-FILE-FORMAT SNARK:DEFAULT-PROVE-CLOSURE? SNARK:DEFAULT-ROW-WEIGHT-LIMIT? SNARK:DEFAULT-PRINT-SUMMARY-WHEN-FINISHED? SNARK:DEFAULT-USE-EMBEDDED-REWRITES? SNARK:TEST-OPTION9 SNARK:TEST-OPTION30 SNARK:DEFAULT-TRACE-REWRITE SNARK:TEST-OPTION23? SNARK:DEFAULT-VARIABLE-WEIGHT? SNARK:TEST-OPTION39 SNARK:DEFAULT-USE-CONDENSING SNARK:VARIABLE-WEIGHT? SNARK:KBO-VARIABLE-WEIGHT SNARK:DEFAULT-PRINT-ROW-ANSWERS? SNARK:REFUTE-FILE-CLOSURE? SNARK:DEFAULT-TEST-OPTION9 SNARK:DEFAULT-USE-SORT-RELATIVIZATION? SNARK:TEST-OPTION56 SNARK:DEFAULT-ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS?)
See also:
  The ANSI Standard, Macro DEFPACKAGE
  The SBCL Manual, Variable *ON-PACKAGE-VARIANCE*
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/useful.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO SETQ-ONCE ...)
; compiling (DEFINLINE ASSOC/EQ ...)
; compiling (DEFUN LIST-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/useful.lisp
; in: DEFUN LIST-P
;     (INCF SNARK::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFVAR *OUTPUTTING-COMMENT* ...)
; compiling (DEFINLINE COMMENT* ...)
; compiling (DEFINLINE NOCOMMENT* ...)
; compiling (DEFUN COMMENT ...)
; compiling (DEFUN NOCOMMENT ...)
; compiling (DEFUN TERPRI ...)
; compiling (DEFUN TERPRI-COMMENT ...)
; compiling (DEFVAR *TERPRI-INDENT* ...)
; compiling (DECLAIM (TYPE FIXNUM ...))
; compiling (DEFUN TERPRI-COMMENT-INDENT ...)
; compiling (DEFUN TERPRI-INDENT ...)
; compiling (DEFUN UNIMPLEMENTED ...)
; compiling (DEFVAR *HASH-DOLLAR-PACKAGE* ...)
; compiling (DEFVAR *HASH-DOLLAR-READTABLE* ...)
; compiling (DEFUN HASH-DOLLAR-READER ...)
; compiling (DEFUN INITIALIZE-HASH-DOLLAR-READER ...)
; compiling (INITIALIZE-HASH-DOLLAR-READER)
; compiling (DEFSTRUCT (HASH-DOLLAR # ...) ...)
; compiling (DEFUN PRINT-HASH-DOLLAR-SYMBOL3 ...)
; compiling (DEFUN HASH-DOLLAR-SYMBOLIZE ...)
; compiling (DEFUN HASH-DOLLAR-PRIN1 ...)
; compiling (DEFUN HASH-DOLLAR-PRINT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/useful.fasl written
; compilation finished in 0:00:00.072
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-POSET ...)
; compiling (DEFINLINE POSET-GREATERP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp
; in: DEFINLINE POSET-GREATERP
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFINLINE POSET-LESSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp
; in: DEFINLINE POSET-LESSP
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN POSET-EQUIVALENT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp
; in: DEFUN POSET-EQUIVALENT
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN DECLARE-POSET-GREATERP ...)
; compiling (DEFUN DECLARE-POSET-LESSP ...)
; compiling (DEFUN POSET-SUPERIORS ...)
; compiling (DEFUN POSET-INFERIORS ...)
; compiling (DEFUN ADD-EDGE-TRANSITIVELY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.lisp
; in: DEFUN ADD-EDGE-TRANSITIVELY
;     (EQL SNARK::V1 SNARK::V2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/posets.fasl written
; compilation finished in 0:00:00.018
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SOLVE-SUM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.lisp
; in: DEFUN SOLVE-SUM
;     (FUNCALL SNARK::CC (CONS SNARK::K1 SNARK::SOL))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS 0 SNARK::SOL))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (TRUNCATE SNARK::SUM SNARK::C)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (* SNARK::K1 SNARK::C)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (FUNCALL SNARK::CC (LIST SNARK::Q))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MIN SNARK::B (TRUNCATE SNARK::SUM SNARK::C))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK::B SNARK::Q)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::B (TRUNCATE SNARK::SUM SNARK::C))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (* SNARK::K1 SNARK::C)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DECF SNARK::SUM (* SNARK::K1 SNARK::C))
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DECF SNARK::K1)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::SUM SNARK::C)
; --> SETQ THE 
; ==>
;   (+ SNARK::C SNARK::SUM)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (SNARK-LISP:NEQL SNARK::K SNARK::K1)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       etc.

;     (>= SNARK::B SNARK::Q)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN SOLVE-SUM-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.lisp
; in: DEFUN SOLVE-SUM-P
;     (BLOCK SNARK:IT
;       (SNARK::SOLVE-SUM
;        (LAMBDA (SNARK::SOL)
;          (DECLARE (IGNORE SNARK::SOL))
;          (RETURN-FROM SNARK:IT T))
;        SNARK::SUM SNARK::COEFS SNARK::BOUNDS)
;       NIL)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM IT T). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN SOLVE-SUM-SOLUTIONS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/solve-sum.fasl written
; compilation finished in 0:00:00.028
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/globals.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SNARK-GLOBALS* ...)
; compiling (DEFVAR *SNARK-NONSAVE-GLOBALS* ...)
; compiling (DEFUN SUSPEND-SNARK* ...)
; compiling (DEFUN RESUME-SNARK ...)
; compiling (DEFUN SUSPEND-SNARK ...)
; compiling (DEFUN SUSPEND-AND-RESUME-SNARK ...)
; compiling (DEFUN AUDIT-SNARK-GLOBALS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/globals.fasl written
; compilation finished in 0:00:00.021
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SNARK-GLOBALS* ...))
; compiling (DEFVAR *SNARK-OPTIONS* ...)
; compiling (DEFMACRO DECLARE-SNARK-OPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp
; in: DEFMACRO DECLARE-SNARK-OPTION
;     (STRING SNARK::NAME)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DECLARE-SNARK-OPTION VARIABLE-SYMBOL-PREFIXES ...)
; compiling (DECLARE-SNARK-OPTION USE-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-NEGATIVE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-UR-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-UR-PTTP ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-FACTORING ...)
; compiling (DECLARE-SNARK-OPTION USE-EQUALITY-FACTORING ...)
; compiling (DECLARE-SNARK-OPTION USE-CONDENSING ...)
; compiling (DECLARE-SNARK-OPTION USE-RESOLVE-CODE ...)
; compiling (DECLARE-SNARK-OPTION USE-UNIT-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-INPUT-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-NEGATIVE-HYPERRESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-UR-RESOLUTION ...)
; compiling (DECLARE-SNARK-OPTION USE-LITERAL-ORDERING-WITH-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-SUBSUMPTION-BY-FALSE ...)
; compiling (DECLARE-SNARK-OPTION USE-LOOKAHEAD-IN-DPLL-FOR-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-SIMPLIFICATION-BY-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-SIMPLIFICATION-BY-EQUALITIES ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-ORDERING-CACHE ...)
; compiling (DECLARE-SNARK-OPTION USE-DEFAULT-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION 1-ARY-FUNCTIONS>2-ARY-FUNCTIONS-IN-DEFAULT-ORDERING ...)
; compiling (DECLARE-SNARK-OPTION ORDERING-FUNCTIONS>CONSTANTS ...)
; compiling (DECLARE-SNARK-OPTION RPO-STATUS ...)
; compiling (DECLARE-SNARK-OPTION KBO-STATUS ...)
; compiling (DECLARE-SNARK-OPTION KBO-VARIABLE-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION KBO-BUILTIN-CONSTANT-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION USE-INDEFINITE-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION USE-CONDITIONAL-ANSWER-CREATION ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRUCTIVE-ANSWER-RESTRICTION ...)
; compiling (DECLARE-SNARK-OPTION USE-ANSWERS-DURING-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRAINT-SOLVER-IN-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION ALLOW-SKOLEM-SYMBOLS-IN-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION REWRITE-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION REWRITE-CONSTRAINTS ...)
; compiling (DECLARE-SNARK-OPTION USE-CONSTRAINT-PURIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-EMBEDDED-REWRITES ...)
; compiling (DECLARE-SNARK-OPTION USE-FUNCTION-CREATION ...)
; compiling (DECLARE-SNARK-OPTION USE-REPLACEMENT-RESOLUTION-WITH-X=X ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION-ONLY-INTO-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-PARAMODULATION-ONLY-FROM-UNITS ...)
; compiling (DECLARE-SNARK-OPTION USE-SINGLE-REPLACEMENT-PARAMODULATION ...)
; compiling (DECLARE-SNARK-OPTION USE-PARTITIONS ...)
; compiling (DECLARE-SNARK-OPTION PARTITION-COMMUNICATION-TABLE ...)
; compiling (DECLARE-SNARK-OPTION DECLARE-ROOT-SORT ...)
; compiling (DECLARE-SNARK-OPTION DECLARE-STRING-SORT ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-CONTEXT ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION ASSUME-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION PROVE-SUPPORTED ...)
; compiling (DECLARE-SNARK-OPTION ASSERT-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION ASSUME-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION PROVE-SEQUENTIAL ...)
; compiling (DECLARE-SNARK-OPTION PROVE-CLOSURE ...)
; compiling (DECLARE-SNARK-OPTION NUMBER-OF-GIVEN-ROWS-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION NUMBER-OF-ROWS-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-LENGTH-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION RUN-TIME-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-ARGUMENT-COUNT-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-WEIGHT-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION LEVEL-PREF-FOR-GIVING ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION BUILTIN-CONSTANT-WEIGHT ...)
; compiling (DECLARE-SNARK-OPTION BAG-WEIGHT-FACTORIAL ...)
; compiling (DECLARE-SNARK-OPTION AGENDA-ORDERING-FUNCTION ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-SIZE-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-WEIGHT-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-DEPTH-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION ROW-PRIORITY-LEVEL-FACTOR ...)
; compiling (DECLARE-SNARK-OPTION PRUNING-TESTS ...)
; compiling (DECLARE-SNARK-OPTION PRUNING-TESTS-BEFORE-SIMPLIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-CLAUSIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-EQUALITY-ELIMINATION ...)
; compiling (DECLARE-SNARK-OPTION USE-MAGIC-TRANSFORMATION ...)
; compiling (DECLARE-SNARK-OPTION USE-AC-CONNECTIVES ...)
; compiling (DECLARE-SNARK-OPTION USE-PURITY-TEST ...)
; compiling (DECLARE-SNARK-OPTION USE-RELEVANCE-TEST ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSERTION-ANALYSIS ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSOCIATIVE-UNIFICATION ...)
; compiling (DECLARE-SNARK-OPTION USE-ASSOCIATIVE-IDENTITY ...)
; compiling (DECLARE-SNARK-OPTION USE-DP-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION UNIFY-BAG-BASIS-SIZE-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION USE-TERM-MEMORY-DELETION ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-SORT-MARKER ...)
; compiling (DECLARE-SNARK-OPTION USE-VARIABLE-NAME-SORTS ...)
; compiling (DECLARE-SNARK-OPTION USE-WELL-SORTING ...)
; compiling (DECLARE-SNARK-OPTION USE-EXTENDED-IMPLICATIONS ...)
; compiling (DECLARE-SNARK-OPTION USE-EXTENDED-QUANTIFIERS ...)
; compiling (DECLARE-SNARK-OPTION USE-SORT-RELATIVIZATION ...)
; compiling (DECLARE-SNARK-OPTION USE-QUANTIFIER-PRESERVATION ...)
; compiling (DECLARE-SNARK-OPTION INPUT-FLOATS-AS-RATIOS ...)
; compiling (DECLARE-SNARK-OPTION USE-CLOSURE-WHEN-SATISFIABLE ...)
; compiling (DECLARE-SNARK-OPTION LISTEN-FOR-COMMANDS ...)
; compiling (DECLARE-SNARK-OPTION USE-TO-LISP-CODE ...)
; compiling (DECLARE-SNARK-OPTION VARIABLE-TO-LISP-CODE ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-GIVEN ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-DERIVED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-PROCESSED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-FINAL-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-UNORIENTABLE-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-PURE-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-IRRELEVANT-ROWS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-REWRITE-ORIENTATION ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-TEST ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-SHORTENED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-PRETTILY ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-WFFS-PRETTILY ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-ANSWERS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-CONSTRAINTS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-REASONS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-GOALS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-PARTITIONS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROW-LENGTH-LIMIT ...)
; compiling (DECLARE-SNARK-OPTION PRINT-GIVEN-ROW-LINES-PRINTING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-GIVEN-ROW-LINES-SIGNALLING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-SUMMARY-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-CLOCKS-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-TERM-MEMORY-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-AGENDA-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ROWS-WHEN-FINISHED ...)
; compiling (DECLARE-SNARK-OPTION PRINT-OPTIONS-WHEN-STARTING ...)
; compiling (DECLARE-SNARK-OPTION PRINT-ASSERTION-ANALYSIS-NOTES ...)
; compiling (DECLARE-SNARK-OPTION PRINT-SYMBOL-TABLE-WARNINGS ...)
; compiling (DECLARE-SNARK-OPTION PRINT-TIME-USED ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY ...)
; compiling (DECLARE-SNARK-OPTION METER-UNIFY-BAG ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY-BAG-BASIS ...)
; compiling (DECLARE-SNARK-OPTION TRACE-UNIFY-BAG-BINDINGS ...)
; compiling (DECLARE-SNARK-OPTION TRACE-DP-REFUTE ...)
; compiling (DECLARE-SNARK-OPTION TRACE-REWRITE ...)
; compiling (DECLARE-SNARK-OPTION TRACE-OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DECLARE-SNARK-OPTION TRACE-DPLL-SUBSUMPTION ...)
; compiling (DECLARE-SNARK-OPTION CHANGEABLE-PROPERTIES-OF-LOCKED-CONSTANT ...)
; compiling (DECLARE-SNARK-OPTION CHANGEABLE-PROPERTIES-OF-LOCKED-FUNCTION ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION2 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION3 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION6 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION8 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION9 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION14 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION17 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION18 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION19 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION20 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION21 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION23 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION29 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION30 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION36 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION37 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION38 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION39 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION40 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION41 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION42 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION43 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION44 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION45 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION49 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION50 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION51 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION52 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION53 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION54 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION55 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION56 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION57 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION58 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION59 ...)
; compiling (DECLARE-SNARK-OPTION TEST-OPTION60 ...)
; compiling (DEFVAR OPTIONS-HAVE-BEEN-CRITIQUED)
; compiling (DEFUN INITIALIZE-OPTIONS ...)
; compiling (DEFUN FINALIZE-OPTIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp
; in: DEFUN FINALIZE-OPTIONS
;     (FUNCALL SNARK::NAME
;              (SYMBOL-VALUE
;               (INTERN (SNARK-LISP:TO-STRING "*%" SNARK::NAME "%*") :SNARK)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::NAME)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SNARK-OPTION-SPEC-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp
; in: DEFUN SNARK-OPTION-SPEC-P
;     (STRING= SNARK::X SNARK::Y :START1 8)
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFUN SET-OPTIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp
; in: DEFUN SET-OPTIONS
;     (FUNCALL SNARK::X T)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::X)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL (FIRST SNARK::X) (SECOND SNARK::X))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (FIRST SNARK::X))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMACRO LET-OPTIONS ...)
; compiling (DEFUN PRINT-OPTIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.lisp
; in: DEFUN PRINT-OPTIONS
;     (SNARK-LISP:NEQL SNARK::VALUE SNARK::DEFAULT-VALUE)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMETHOD AGENDA-LENGTH-LIMIT ...)
; compiling (DEFMETHOD AGENDA-LENGTH-BEFORE-SIMPLIFICATION-LIMIT ...)
; compiling (DEFMETHOD USE-RESOLVE-CODE ...)
; compiling (DEFMETHOD USE-TERM-ORDERING ...)
; compiling (DEFMETHOD USE-CONSTRAINT-PURIFICATION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/options.fasl written
; compilation finished in 0:00:00.862
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *CONS*)
; compiling (DEFVAR *=*)
; compiling (DEFVAR *NOT*)
; compiling (DEFVAR *AND*)
; compiling (DEFVAR *OR*)
; compiling (DEFVAR *IMPLIES*)
; compiling (DEFVAR *IMPLIED-BY*)
; compiling (DEFVAR *IFF*)
; compiling (DEFVAR *XOR*)
; compiling (DEFVAR *IF*)
; compiling (DEFVAR *FORALL*)
; compiling (DEFVAR *EXISTS*)
; compiling (DEFVAR *ANSWER-IF*)
; compiling (DEFVAR *A-FUNCTION-WITH-LEFT-TO-RIGHT-ORDERING-STATUS*)
; compiling (DEFVAR *A-FUNCTION-WITH-MULTISET-ORDERING-STATUS*)
; compiling (DEFINLINE COMPOUND-APPL-P ...)
; compiling (DEFINLINE HEADA ...)
; compiling (DEFINLINE ARGSA ...)
; compiling (DEFINLINE CONSTANT-P ...)
; compiling (DEFINLINE COMPOUND-P ...)
; compiling (DEFUN MAKE-COMPOUND%2 ...)
; compiling (DEFUN MAKE-COMPOUND%* ...)
; compiling (DEFMACRO MAKE-COMPOUND ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.lisp
; in: DEFMACRO MAKE-COMPOUND
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMACRO MAKE-COMPOUND* ...)
; compiling (DEFINLINE ARG1A ...)
; compiling (DEFINLINE ARG2A ...)
; compiling (DEFINLINE ARG1 ...)
; compiling (DEFINLINE ARG2 ...)
; compiling (DEFINLINE ARGS ...)
; compiling (DEFINLINE HEAD ...)
; compiling (DEFINLINE HEAD-OR-TERM ...)
; compiling (DEFMACRO FANCY-MAKE-COMPOUND* ...)
; compiling (DEFUN MAKE-COMPOUND2 ...)
; compiling (DEFMACRO MAKE-A1-COMPOUND* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.lisp
; in: DEFMACRO MAKE-A1-COMPOUND*
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFMACRO DEREFERENCE ...)
; compiling (DEFMACRO DEREFERENCE2 ...)
; compiling (DEFMACRO PREFER-TO-BIND-P ...)
; compiling (DEFVAR *FROZEN-VARIABLES* ...)
; compiling (DEFINLINE VARIABLE-FROZEN-P ...)
; compiling (DEFINLINE UNFROZEN-VARIABLE-P ...)
; compiling (DEFINLINE MAKE-TC ...)
; compiling (DEFINLINE TC-TERM ...)
; compiling (DEFMACRO TC-COUNT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/terms2.fasl written
; compilation finished in 0:00:00.108
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ROWSETS*)
; compiling (DEFVAR *ROWS*)
; compiling (DEFVAR *ROW-COUNT* ...)
; compiling (DEFVAR *NUMBER-OF-ROWS* ...)
; compiling (DEFVAR *ROW-NAMES*)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFUN UNINITIALIZED ...)
; compiling (DEFSTRUCT (ROW # ...) ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFUN ROW-WFF-SYMBOL-COUNTS ...)
; compiling (DEFUN ROW-NAME-OR-NUMBER ...)
; compiling (DEFMACRO MAKE-ROW ...)
; compiling (DEFUN INITIALIZE-ROWS ...)
; compiling (DEFUN ROW-GIVEN-P ...)
; compiling (DEFUN ROW-DELETED-P ...)
; compiling (DEFUN ROW-HINT-P ...)
; compiling (DEFUN ROW-INPUT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN ROW-INPUT-P
;     (= 0 (SNARK:ROW-LEVEL SNARK:ROW))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; compiling (DEFUN ROW-NONASSERTION-P ...)
; compiling (DEFUN ROW-FROM-CONJECTURE-P ...)
; compiling (DEFUN ROW-PARENTS ...)
; compiling (DEFUN ROW-PARENT ...)
; compiling (DEFUN ROW-EMBEDDING-P ...)
; compiling (DEFUN ROW-REWRITES-USED ...)
; compiling (DEFUN (SETF ROW-REWRITES-USED) ...)
; compiling (DEFUN ROW-LEVEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN ROW-LEVEL
;     (+ 1
;        (LOOP SNARK::FOR SNARK::PARENT SNARK::IN (REST SNARK::REASON)
;              WHEN (SNARK::ROW-P SNARK::PARENT)
;              SNARK::MAXIMIZE (SNARK:ROW-LEVEL SNARK::PARENT)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::PARENT SNARK::IN (REST SNARK::REASON)
;           WHEN (SNARK::ROW-P SNARK::PARENT)
;           SNARK::MAXIMIZE (SNARK:ROW-LEVEL SNARK::PARENT))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY IF 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-652 #:LOOP-MAXMIN-651)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::REASON SNARK::IN (REST SNARK::REASON)
;           SNARK::MINIMIZE (SNARK::ROW-LEVEL* SNARK::REASON))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-665 #:LOOP-MAXMIN-664)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (LOOP SNARK::FOR SNARK::PARENT SNARK::IN (REST SNARK::REASON)
;           WHEN (SNARK::ROW-P SNARK::PARENT)
;           SNARK::MAXIMIZE (SNARK:ROW-LEVEL SNARK::PARENT))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY IF 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-652 #:LOOP-MAXMIN-651)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::PARENT SNARK::IN (REST SNARK::REASON)
;              WHEN (SNARK::ROW-P SNARK::PARENT)
;              SNARK::MAXIMIZE (SNARK:ROW-LEVEL SNARK::PARENT)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ROW-CLAUSE-P ...)
; compiling (DEFUN ROW-UNIT-P ...)
; compiling (DEFUN ROW-BARE-P ...)
; compiling (DEFUN ROW-BARE-UNIT-P ...)
; compiling (DEFUN ROW-POSITIVE-P ...)
; compiling (DEFUN ROW-NEGATIVE-P ...)
; compiling (DEFUN ROW-VARIABLES ...)
; compiling (DEFUN ROW-SUPPORTED-INHERITABLY ...)
; compiling (DEFUN ROW-SEQUENTIAL-INHERITABLY ...)
; compiling (DEFUN MAKE-ROWSET ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN MAKE-ROWSET
;     (SNARK-NUMBERING:NONCE)
; --> (LAMBDA NIL (INCF SNARK-NUMBERING::*NONCE*)) SB-C::%FUNCALL INCF SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ROWSET-SIZE ...)
; compiling (DEFUN ROWSET-INSERT ...)
; compiling (DEFUN ROWSET-DELETE ...)
; compiling (DEFUN ROWSETS-DELETE ...)
; compiling (DEFUN ROWSETS-DELETE-COLUMN ...)
; compiling (DEFUN ROWSET-EMPTY? ...)
; compiling (DEFUN MAP-ROWS-IN-REASON ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN MAP-ROWS-IN-REASON
;     (FUNCALL SNARK::FN SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ROWS-IN-REASON ...)
; compiling (DEFUN ROW-ANCESTRY-ROWSET ...)
; compiling (DEFUN ROW-ANCESTRY ...)
; compiling (DEFUN ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN ROW
;     (MINUSP SNARK::NAME-OR-NUMBER)
; ==>
;   (< SNARK::NAME-OR-NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ SNARK::*NUMBER-OF-ROWS* SNARK::NAME-OR-NUMBER 1)
; ==>
;   (+ (+ SNARK::*NUMBER-OF-ROWS* SNARK::NAME-OR-NUMBER) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (FUNCALL SNARK::NOT-FOUND-ACTION "There is no row numbered ~D."
;              SNARK::NAME-OR-NUMBER)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::NOT-FOUND-ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::NOT-FOUND-ACTION "There is no row named ~S."
;              SNARK::NAME-OR-NUMBER)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::NOT-FOUND-ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MINUSP SNARK::NAME-OR-NUMBER)
; ==>
;   (< SNARK::NAME-OR-NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (+ SNARK::*NUMBER-OF-ROWS* SNARK::NAME-OR-NUMBER 1)
; --> + 
; ==>
;   (+ SNARK::*NUMBER-OF-ROWS* SNARK::NAME-OR-NUMBER)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; ==>
;   (+ (+ SNARK::*NUMBER-OF-ROWS* SNARK::NAME-OR-NUMBER) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAPNCONC-ROWS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN MAPNCONC-ROWS
;     (FUNCALL SNARK::TEST SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-ROWS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN MAP-ROWS
;     (FUNCALL SNARK::TEST SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ROWS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN ROWS
;     (FUNCALL SNARK::TEST SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-LISP:COLLECT SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-LISP:COLLECT)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN LAST-ROW ...)
; compiling (DEFUN SET-ROW-NUMBER ...)
; compiling (DEFUN NAME-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN NAME-ROW
;     (SNARK-LISP:NEQL NUMBER SNARK::NUMBER2)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (SNARK-LISP:NEQL SNARK::NAME SNARK::NAME2)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PRINT-ANCESTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.lisp
; in: DEFUN PRINT-ANCESTRY
;     (MEMBER SNARK:ROW SNARK::MORE-ROWS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN PRINT-ROWS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rows.fasl written
; compilation finished in 0:00:00.173
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ROOT-ROW-CONTEXT*)
; compiling (DEFVAR *CURRENT-ROW-CONTEXT*)
; compiling (DEFMACRO ROOT-ROW-CONTEXT ...)
; compiling (DEFMACRO CURRENT-ROW-CONTEXT ...)
; compiling (DEFUN INITIALIZE-ROW-CONTEXTS ...)
; compiling (DEFINLINE CONTEXT-PARENT ...)
; compiling (DEFINLINE CONTEXT-LIVE? ...)
; compiling (DEFUN PRINT-ROW-CONTEXT-TREE ...)
; compiling (DEFUN THE-ROW-CONTEXT ...)
; compiling (DEFUN MAKE-ROW-CONTEXT ...)
; compiling (DEFUN DELETE-ROW-CONTEXT ...)
; compiling (DEFUN IN-ROW-CONTEXT ...)
; compiling (DEFUN PUSH-ROW-CONTEXT ...)
; compiling (DEFUN POP-ROW-CONTEXT ...)
; compiling (DEFUN NEW-ROW-CONTEXT ...)
; compiling (DEFUN THE-ROW-CONTEXT2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.lisp
; in: DEFUN THE-ROW-CONTEXT2
;     (MEMBER SNARK::PART SNARK::ALL-PARTITIONS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN ROW-CONTEXT-LIVE? ...)
; compiling (DEFUN CONTEXT-INTERSECTION-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.lisp
; in: DEFUN CONTEXT-INTERSECTION-P
;     (ASSOC SNARK::PART SNARK::X)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN CONTEXT-SUBSUMES? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.lisp
; in: DEFUN CONTEXT-SUBSUMES?
;     (ASSOC SNARK::PART SNARK::X)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFVAR *REWRITING-ROW-CONTEXT* ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/row-contexts.fasl written
; compilation finished in 0:00:00.387
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFSTRUCT CONSTANT-INFO ...)
; compiling (DEFINLINE CONSTANT-NUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFINLINE CONSTANT-NUMBER
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFVAR *CONSTANT-INFO-TABLE*)
; compiling (DEFMACRO CONSTANT-INFO0 ...)
; compiling (DEFINLINE CONSTANT-INFO ...)
; compiling (DEFUN INIT-CONSTANT-INFO ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN INIT-CONSTANT-INFO
;     (SNARK::CONSTANT-NUMBER SNARK::CONST)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMACRO DEFINE-CONSTANT-SLOT-ACCESSOR ...)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR HASH-CODE0 ...)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR BOOLEAN-VALUED-P0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR CONSTRUCTOR0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR MAGIC)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR ALLOWED-IN-ANSWER0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR KBO-WEIGHT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR WEIGHT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR SORT0)
; compiling (DEFINE-CONSTANT-SLOT-ACCESSOR PLIST)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR CONSTANT ...)
; compiling (DEFVAR *NUMBER-INFO-TABLE*)
; compiling (DEFVAR *STRING-INFO-TABLE*)
; compiling (DEFSTRUCT (NUMBER-INFO # ...) ...)
; compiling (DEFSTRUCT (STRING-INFO # ...) ...)
; compiling (DEFMACRO NUMBER-INFO ...)
; compiling (DEFMACRO STRING-INFO ...)
; compiling (DEFUN NUMBER-CANONICAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN NUMBER-CANONICAL
;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (IMAGPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (FLOAT (REALPART SNARK::X))
; --> IF 
; ==>
;   (SB-KERNEL:%SINGLE-FLOAT SB-C::N)
; 
; note: forced to do full call
;       unable to do inline float coercion (cost 5) because:
;       The first argument is a RATIONAL, not a (SIGNED-BYTE 64).

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (IMAGPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

; compiling (DEFUN DECLARE-NUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN DECLARE-NUMBER
;     (SNARK::CONSTANT-NUMBER SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DECLARE-STRING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN DECLARE-STRING
;     (SNARK::CONSTANT-NUMBER SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE BUILTIN-CONSTANT-P ...)
; compiling (DEFINLINE CONSTANT-BUILTIN-P ...)
; compiling (DEFUN CONSTANT-HASH-CODE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN CONSTANT-HASH-CODE
;     (SNARK::CONSTANT-NUMBER SNARK::CONST)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MOD (SNARK::CONSTANT-NUMBER SNARK::CONST) 1022)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1022) (1022)) (DOUBLE-FLOAT -1022.0d0 1022.0d0) (SINGLE-FLOAT -1022.0 1022.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1022) (1022)) (DOUBLE-FLOAT -1022.0d0 1022.0d0) (SINGLE-FLOAT -1022.0 1022.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1022) (1022)) (DOUBLE-FLOAT -1022.0d0 1022.0d0) (SINGLE-FLOAT -1022.0 1022.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ 2 (MOD (SNARK::CONSTANT-NUMBER SNARK::CONST) 1022))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1022.0d0 2044.0d0) (SINGLE-FLOAT -1022.0 2044.0) (RATIONAL (-1022) (2044))), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1022.0d0 2044.0d0) (SINGLE-FLOAT -1022.0 2044.0) (RATIONAL (-1022) (2044))), not a RATIONAL.

;     (MOD (SNARK::CONSTANT-NUMBER SNARK::CONST) 1022)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-1022) (1022)) (DOUBLE-FLOAT -1022.0d0 1022.0d0) (SINGLE-FLOAT -1022.0 1022.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2044.0d0) (SINGLE-FLOAT (0.0) 2044.0) (RATIONAL (0) (2044))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-1022) (1022)) (DOUBLE-FLOAT -1022.0d0 1022.0d0) (SINGLE-FLOAT -1022.0 1022.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2044.0d0) (SINGLE-FLOAT (0.0) 2044.0) (RATIONAL (0) (2044))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ 2 (MOD (SNARK::CONSTANT-NUMBER SNARK::CONST) 1022))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1022.0d0 2044.0d0) (SINGLE-FLOAT -1022.0 2044.0) (RATIONAL (-1022) (2044))), not a FIXNUM.
;       The result is a (VALUES (OR (RATIONAL (-1020) (2046)) (DOUBLE-FLOAT -1020.0d0 2046.0d0) (SINGLE-FLOAT -1020.0 2046.0)) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1022.0d0 2044.0d0) (SINGLE-FLOAT -1022.0 2044.0) (RATIONAL (-1022) (2044))), not a FIXNUM.
;       The result is a (VALUES (OR (RATIONAL (-1020) (2046)) (DOUBLE-FLOAT -1020.0d0 2046.0d0) (SINGLE-FLOAT -1020.0 2046.0)) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE CONSTANT-BOOLEAN-VALUED-P ...)
; compiling (DEFINLINE CONSTANT-CONSTRUCTOR ...)
; compiling (DEFINLINE CONSTANT-ALLOWED-IN-ANSWER ...)
; compiling (DEFINLINE CONSTANT-KBO-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFINLINE CONSTANT-KBO-WEIGHT
;     (FUNCALL SNARK::V SNARK::CONST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE CONSTANT-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFINLINE CONSTANT-WEIGHT
;     (FUNCALL SNARK::V SNARK::CONST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CONSTANT-SORT ...)
; compiling (DEFUN (SETF CONSTANT-SORT) ...)
; compiling (DEFINLINE CONSTANT-LOCKED ...)
; compiling (DEFINLINE CONSTANT-NAME ...)
; compiling (DEFUN CONSTANT-NAME-LESSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN CONSTANT-NAME-LESSP
;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (< (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (= (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (IMAGPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (IMAGPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (< (IMAGPART SNARK::X) (IMAGPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK::X SNARK::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (STRING< SNARK::X SNARK::Y)
; ==>
;   (SB-KERNEL:STRING<* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-BASE-STRING.The second argument is a STRING, not a SIMPLE-BASE-STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (REALPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (< (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (REALPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (= (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (IMAGPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (IMAGPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (< (IMAGPART SNARK::X) (IMAGPART SNARK::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN INITIALIZE-CONSTANTS ...)
; compiling (DEFMACRO SET-SLOT-IF-SUPPLIED ...)
; compiling (DEFUN DECLARE-CONSTANT-SYMBOL0 ...)
; compiling (DEFUN CHANGEABLE-KEYS-AND-VALUES0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.lisp
; in: DEFUN CHANGEABLE-KEYS-AND-VALUES0
;     (MEMBER (FIRST SNARK::KEYS-AND-VALUES) SNARK::CHANGEABLE)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN CHANGEABLE-KEYS-AND-VALUES ...)
; compiling (DEFUN DECLARE-CONSTANT-SYMBOL1 ...)
; compiling (DEFUN DECLARE-CONSTANT ...)
; compiling (DEFUN DECLARE-PROPOSITION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constants.fasl written
; compilation finished in 0:00:00.196
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING*))
; compiling (DEFVAR *NAME*)
; compiling (DEFSTRUCT (FUNCTION-SYMBOL # ...) ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINLINE FUNCTION-RPO-STATUS ...)
; compiling (DEFINLINE FUNCTION-KBO-STATUS ...)
; compiling (DEFUN MAKE-FUNCTION-SYMBOL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN MAKE-FUNCTION-SYMBOL
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::FN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN FUNCTION-KIND ...)
; compiling (DEFUN FUNCTION-HAS-ARITY-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN FUNCTION-HAS-ARITY-P
;     (EQL SNARK::ARITY SNARK::A)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN FUNCTION-IDENTITY2 ...)
; compiling (DEFUN FUNCTION-NAME-LESSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN FUNCTION-NAME-LESSP
;     (STRING< SNARK::X SNARK::Y)
; ==>
;   (SB-KERNEL:STRING<* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

; compiling (DEFUN FUNCTION-NAME-ARITY-LESSP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN FUNCTION-NAME-ARITY-LESSP
;     (STRING<= SNARK::NAME1 SNARK::NAME2)
; ==>
;   (SB-KERNEL:STRING<=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                        SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (STRING= SNARK::NAME1 SNARK::NAME2)
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (< SNARK::ARITY1 SNARK::ARITY2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFMACRO SET-FUNCTION-CODE ...)
; compiling (DEFUN DECLARE-FUNCTION-SYMBOL0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.lisp
; in: DEFUN DECLARE-FUNCTION-SYMBOL0
;     (SNARK::SET-FUNCTION-CODE SNARK::REWRITE-CODE)
; --> WHEN IF SETF SB-KERNEL:%INSTANCE-SET IF REMOVE-DUPLICATES 
; ==>
;   SNARK::REWRITE-CODE
; 
; note: deleting unreachable code

;     (SNARK::SET-FUNCTION-CODE SNARK::PARAMODULATE-CODE)
; --> WHEN IF SETF SB-KERNEL:%INSTANCE-SET IF REMOVE-DUPLICATES 
; ==>
;   SNARK::PARAMODULATE-CODE
; 
; note: deleting unreachable code

;     (LENGTH (REST SNARK::KBO-WEIGHT))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (STRING (SNARK:FUNCTION-NAME SYMBOL))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DEFUN DECLARE-FUNCTION-SYMBOL1 ...)
; compiling (DEFUN DECLARE-FUNCTION ...)
; compiling (DEFUN DECLARE-RELATION ...)
; compiling (DEFUN DECLARE-LOGICAL-SYMBOL ...)
; compiling (DEFUN DECLARE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN DECLARE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN FUNCTION-CODE-NAME ...)
; compiling (DEFUN FUNCTION-RESOLVE-CODE ...)
; compiling (DEFUN DECLARE-FUNCTION1 ...)
; compiling (DEFUN DECLARE-FUNCTION2 ...)
; compiling (DEFUN DECLARE-RELATION1 ...)
; compiling (DEFUN DECLARE-RELATION2 ...)
; compiling (DEFUN DECLARE-CHARACTERISTIC-RELATION ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/functions.fasl written
; compilation finished in 0:00:00.256
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLE-BLOCKS ...)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLES-PER-BLOCK ...)
; compiling (DEFCONSTANT $NUMBER-OF-VARIABLES-IN-BLOCKS ...)
; compiling (DEFVAR *VARIABLES*)
; compiling (DEFVAR *NEXT-VARIABLE-NUMBER* ...)
; compiling (DECLAIM (TYPE INTEGER ...))
; compiling (DEFSTRUCT (VARIABLE # ...) ...)
; compiling (DEFUN INITIALIZE-VARIABLES ...)
; compiling (DEFUN MAKE-VARIABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.lisp
; in: DEFUN MAKE-VARIABLE
;     (MOD (+ NUMBER 1) SNARK::$NUMBER-OF-VARIABLES-PER-BLOCK)
; --> LET IF AND IF AND THE IF PLUSP > 
; ==>
;   NUMBER
; 
; note: deleting unreachable code

;     (ASSERT (< NUMBER SNARK::$NUMBER-OF-VARIABLES-IN-BLOCKS))
; --> TAGBODY LET WHEN IF 
; ==>
;   (< #:TEMP50 SNARK::$NUMBER-OF-VARIABLES-IN-BLOCKS)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ NUMBER 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (MOD (+ NUMBER 1) SNARK::$NUMBER-OF-VARIABLES-PER-BLOCK)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-6000) (6000)) (DOUBLE-FLOAT -6000.0d0 6000.0d0) (SINGLE-FLOAT -6000.0 6000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6000) (6000)) (DOUBLE-FLOAT -6000.0d0 6000.0d0) (SINGLE-FLOAT -6000.0 6000.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6000) (6000)) (DOUBLE-FLOAT -6000.0d0 6000.0d0) (SINGLE-FLOAT -6000.0 6000.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (ASSERT (/= 0 (MOD (+ NUMBER 1) SNARK::$NUMBER-OF-VARIABLES-PER-BLOCK)))
; --> TAGBODY LET WHEN IF /= IF 
; ==>
;   (= 0 #:TEMP51)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -6000.0d0 12000.0d0) (SINGLE-FLOAT -6000.0 12000.0) (RATIONAL (-6000) (12000))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (ASSERT (<= 0 NUMBER))
; --> TAGBODY LET WHEN IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> TAGBODY LET WHEN IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> TAGBODY LET WHEN IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (ASSERT (< NUMBER SNARK::$NUMBER-OF-VARIABLES-IN-BLOCKS))
; --> TAGBODY LET WHEN IF 
; ==>
;   (< #:TEMP50 SNARK::$NUMBER-OF-VARIABLES-IN-BLOCKS)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (+ NUMBER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MOD (+ NUMBER 1) SNARK::$NUMBER-OF-VARIABLES-PER-BLOCK)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-6000) (6000)) (DOUBLE-FLOAT -6000.0d0 6000.0d0) (SINGLE-FLOAT -6000.0 6000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12000.0d0) (SINGLE-FLOAT (0.0) 12000.0) (RATIONAL (0) (12000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-6000) (6000)) (DOUBLE-FLOAT -6000.0d0 6000.0d0) (SINGLE-FLOAT -6000.0 6000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12000.0d0) (SINGLE-FLOAT (0.0) 12000.0) (RATIONAL (0) (12000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (SETF NUMBER SNARK::*NEXT-VARIABLE-NUMBER*) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN VARIABLE-BLOCK ...)
; compiling (DEFUN VARIABLE-BLOCK-0-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variables.fasl written
; compilation finished in 0:00:00.025
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO MAKE-BINDING ...)
; compiling (DEFMACRO BINDING-VAR ...)
; compiling (DEFMACRO BINDING-VALUE ...)
; compiling (DEFMACRO ADD-BINDING-TO-SUBSTITUTION ...)
; compiling (DEFMACRO DOBINDINGS ...)
; compiling (DEFINLINE BIND-VARIABLE-TO-TERM ...)
; compiling (DEFUN LOOKUP-VARIABLE-IN-SUBSTITUTION ...)
; compiling (DEFUN LOOKUP-VALUE-IN-SUBSTITUTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN LOOKUP-VALUE-IN-SUBSTITUTION
;     (RASSOC SNARK::VALUE SUBST)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN LOOKUP-VALUE-IN-SUBSTITUTION2 ...)
; compiling (DEFUN SUBSTITUTION-EQUAL-P ...)
; compiling (DEFUN SUBSTITUTION-SUBSET-P ...)
; compiling (DEFUN SUBSTITUTION-DIFF ...)
; compiling (DEFUN SUBSTITUTION-DIFF2 ...)
; compiling (DEFUN SUBSTITUTION-SUBSET-P1 ...)
; compiling (DEFUN REMOVE-IRRELEVANT-BINDINGS ...)
; compiling (DEFUN PRINT-SUBSTITUTION ...)
; compiling (DEFUN MAKE-IDEMPOTENT-SUBSTITUTION ...)
; compiling (DEFUN VARIABLES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN VARIABLES
;     (ADJOIN SNARK::X SNARK::VARS)
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NONTHEORY-VARIABLES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN NONTHEORY-VARIABLES
;     (ADJOIN SNARK::X SNARK::VARS)
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN VARIABLESL ...)
; compiling (DEFUN FIRST-NONVARIABLE-TERM ...)
; compiling (DEFUN FIRST-NONVARIABLE-SUBTERM ...)
; compiling (DEFUN VARIABLE-COUNTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN VARIABLE-COUNTS
;     (INCF (SNARK-LISP:CDRC SNARK::V))
; --> LET* 
; ==>
;   (+ 1 (CDR #:G425))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN VARIABLE-DISJOINT-PARTITION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN VARIABLE-DISJOINT-PARTITION
;     (ASSOC SNARK::P SNARK::PARTITION)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NEW-VARIABLES ...)
; compiling (DEFUN INSTANTIATE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN INSTANTIATE
;     (ZEROP SNARK::N)
; --> = IF 
; ==>
;   (= SNARK::N 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-LISP:LCONS (SNARK::INSTANTIATE* (FIRST SNARK::L))
;                       (SNARK::INSTANTIATEL (REST SNARK::L)) SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G571 #:G573)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G571 #:G573)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G590 #:G592)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G590 #:G592)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G579 #:G581)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G579 #:G581)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS (SNARK::INSTANTIATE* (CAR SNARK::X))
;                       (SNARK::INSTANTIATE* (CDR SNARK::X)) SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G576 #:G578)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G575 #:G577)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G575 #:G577)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (+ SNARK::N SNARK::INCR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (SNARK-LISP:LCONS (SNARK::INSTANTIATE* (CAR SNARK::X))
;                       (SNARK::INSTANTIATE* (CDR SNARK::X)) SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G587 #:G589)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G586 #:G588)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G586 #:G588)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G568 #:G570)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G567 #:G569)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G567 #:G569)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN RENUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN RENUMBER
;     (SNARK-LISP:LCONS SNARK::U SNARK::V SNARK::X)
; --> IF LET* IF IF 
; ==>
;   (EQL #:G656 #:G658)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G657 #:G659)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G656 #:G658)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN RENUMBERL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN RENUMBERL
;     (SNARK-LISP:LCONS
;      (SETF (VALUES SNARK::DUMMY SNARK::RSUBST)
;              (SNARK::RENUMBER (FIRST SNARK::L) SUBST SNARK::RSUBST))
;      (SETF (VALUES SNARK::DUMMY SNARK::RSUBST)
;              (SNARK::RENUMBERL (REST SNARK::L) SUBST SNARK::RSUBST))
;      SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G683 #:G685)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G683 #:G685)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFVAR *RENUMBER-FIRST-NUMBER* ...)
; compiling (DEFVAR *RENUMBER-BY-SORT* ...)
; compiling (DEFVAR *RENUMBER-IGNORE-SORT* ...)
; compiling (DEFUN RENUMBERV ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN RENUMBERV
;     (+ (SNARK::VARIABLE-NUMBER (SNARK::BINDING-VALUE SNARK::BINDING)) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RENUMBER-NEW ...)
; compiling (DEFUN RENUMBERER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN RENUMBERER
;     (SNARK-LISP:LCONS (SNARK::RENUMBER (SNARK-LISP:CARC SNARK::L))
;                       (SNARK::RENUMBERL (SNARK-LISP:CDRC SNARK::L)) SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G741 #:G743)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G741 #:G743)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS (SNARK::RENUMBER (SNARK-LISP:CARC SNARK::X))
;                       (SNARK::RENUMBER (SNARK-LISP:CDRC SNARK::X)) SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G738 #:G740)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G737 #:G739)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G737 #:G739)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN GROUND-P ...)
; compiling (DEFUN FROZEN-P ...)
; compiling (DEFUN CONSTRUCTOR-TERM-P ...)
; compiling (DEFUN UNSORTED-P ...)
; compiling (DEFUN ALL-VARIABLES-P ...)
; compiling (DEFUN OCCURS-P ...)
; compiling (DEFUN FUNCTION-OCCURS-P ...)
; compiling (DEFUN CONSTANT-OCCURS-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN CONSTANT-OCCURS-P
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN COMPOUND-OCCURS-P ...)
; compiling (DEFUN NO-NEW-VARIABLE-OCCURS-P ...)
; compiling (DEFUN CONSTANT-OCCURS-BELOW-CONSTRUCTOR-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN CONSTANT-OCCURS-BELOW-CONSTRUCTOR-P
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN VARIABLE-OCCURS-BELOW-CONSTRUCTOR-P ...)
; compiling (DEFUN COMPOUND-OCCURS-BELOW-CONSTRUCTOR-P ...)
; compiling (DEFMACRO VARIABLE-OCCURS-P1-MACRO ...)
; compiling (DEFMACRO VARIABLE-OCCURS-P2-MACRO ...)
; compiling (DEFUN VARIABLE-OCCURS-P1L ...)
; compiling (DEFUN VARIABLE-OCCURS-P2L ...)
; compiling (DEFUN VARIABLE-OCCURS-P1 ...)
; compiling (DEFUN VARIABLE-OCCURS-P2 ...)
; compiling (DEFUN VARIABLE-OCCURS-P ...)
; compiling (DEFUN SPECIAL-UNIFY-P ...)
; compiling (DEFUN SKOLEM-OCCURS-P ...)
; compiling (DEFUN DISALLOWED-SYMBOL-OCCURS-IN-ANSWER-P ...)
; compiling (DEFUN EMBEDDING-VARIABLE-OCCURS-P ...)
; compiling (DEFUN SPLIT-IF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.lisp
; in: DEFUN SPLIT-IF
;     (FUNCALL SNARK::TEST SNARK::X*)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subst.fasl written
; compilation finished in 0:00:00.301
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBSTITUTE ...)
; compiling (DEFUN SUBSTITUTEL ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-CONSTANT
;     (EQL SNARK::U SNARK::U*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::OLD SNARK::X)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-COMPOUND
;     (SNARK-LISP:LCONS
;      (SNARK::SUBSTITUTE-FOR-COMPOUND SNARK::NEW SNARK::OLD (CAR SNARK::X) SUBST)
;      (SNARK::SUBSTITUTE-FOR-COMPOUND SNARK::NEW SNARK::OLD (CDR SNARK::X) SUBST)
;      SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G64 #:G66)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G63 #:G65)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G63 #:G65)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-VARIABLE
;     (SNARK-LISP:LCONS
;      (SNARK::SUBSTITUTE-FOR-VARIABLE SNARK::NEW SNARK::OLD
;                                      (SNARK-LISP:CARC SNARK::X) SUBST)
;      (SNARK::SUBSTITUTE-FOR-VARIABLE SNARK::NEW SNARK::OLD
;                                      (SNARK-LISP:CDRC SNARK::X) SUBST)
;      SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G88 #:G90)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G87 #:G89)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G87 #:G89)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-ONCE ...)
; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT-ONCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-CONSTANT-ONCE
;     (FUNCALL SNARK::CC (CONS SNARK::U SNARK::V*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::U* SNARK::V))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NEW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK:MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::OLD SNARK::X)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND-ONCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-COMPOUND-ONCE
;     (FUNCALL SNARK::CC (CONS SNARK::U SNARK::V*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::U* SNARK::V))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NEW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK:MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE-ONCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-VARIABLE-ONCE
;     (FUNCALL SNARK::CC (CONS SNARK::U SNARK::V*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::U* SNARK::V))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NEW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK:MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SUBSTITUTE-FOR-CONSTANTL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-CONSTANTL
;     (SNARK-LISP:LCONS
;      (SNARK::SUBSTITUTE-FOR-CONSTANT SNARK::NEW SNARK::OLD (FIRST SNARK::L)
;                                      SUBST)
;      (SNARK::SUBSTITUTE-FOR-CONSTANTL SNARK::NEW SNARK::OLD (REST SNARK::L)
;                                       SUBST)
;      SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G219 #:G221)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G219 #:G221)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-COMPOUNDL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-COMPOUNDL
;     (SNARK-LISP:LCONS
;      (SNARK::SUBSTITUTE-FOR-COMPOUND SNARK::NEW SNARK::OLD (FIRST SNARK::L)
;                                      SUBST)
;      (SNARK::SUBSTITUTE-FOR-COMPOUNDL SNARK::NEW SNARK::OLD (REST SNARK::L)
;                                       SUBST)
;      SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G231 #:G233)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G231 #:G233)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-VARIABLEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-VARIABLEL
;     (SNARK-LISP:LCONS
;      (SNARK::SUBSTITUTE-FOR-VARIABLE SNARK::NEW SNARK::OLD (FIRST SNARK::L)
;                                      SUBST)
;      (SNARK::SUBSTITUTE-FOR-VARIABLEL SNARK::NEW SNARK::OLD (REST SNARK::L)
;                                       SUBST)
;      SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G243 #:G245)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G243 #:G245)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSTITUTE-FOR-CONSTANT-ONCEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-CONSTANT-ONCEL
;     (FUNCALL SNARK::CC (CONS SNARK::A SNARK::D*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::A* SNARK::D))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SUBSTITUTE-FOR-COMPOUND-ONCEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-COMPOUND-ONCEL
;     (FUNCALL SNARK::CC (CONS SNARK::A SNARK::D*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::A* SNARK::D))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SUBSTITUTE-FOR-VARIABLE-ONCEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.lisp
; in: DEFUN SUBSTITUTE-FOR-VARIABLE-ONCEL
;     (FUNCALL SNARK::CC (CONS SNARK::A SNARK::D*))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::A* SNARK::D))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/substitute.fasl written
; compilation finished in 0:00:00.090
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SYMBOL-TABLE*)
; compiling (DECLAIM (SPECIAL *INPUT-WFF*))
; compiling (DEFUN MAKE-SYMBOL-TABLE ...)
; compiling (DEFMACRO SYMBOL-TABLE-ENTRIES ...)
; compiling (DEFUN CREATE-SYMBOL-TABLE-ENTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN CREATE-SYMBOL-TABLE-ENTRY
;     (PUSHNEW SYMBOL (SNARK:SYMBOL-TABLE-ENTRIES SNARK::NAME))
; --> LET* SB-KERNEL:%PUTHASH ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN FIND-SYMBOL-TABLE-ENTRY ...)
; compiling (DEFUN FIND-OR-CREATE-SYMBOL-TABLE-ENTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN FIND-OR-CREATE-SYMBOL-TABLE-ENTRY
;     (SNARK-LISP:NEQL SNARK::SYM SYMBOL)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN CREATE-ALIASES-FOR-SYMBOL ...)
; compiling (DEFUN RENAME-FUNCTION-SYMBOL ...)
; compiling (DEFUN SYMBOL-KIND ...)
; compiling (DEFUN SYMBOL-TABLE-KIND-MATCH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN SYMBOL-TABLE-KIND-MATCH
;     (EQL SNARK::ARITY SNARK::ARITY2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SYMBOL-TABLE-CONSTANT? ...)
; compiling (DEFUN SYMBOL-TABLE-FUNCTION? ...)
; compiling (DEFUN SYMBOL-TABLE-RELATION? ...)
; compiling (DEFUN MAP-SYMBOL-TABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN MAP-SYMBOL-TABLE
;     (FUNCALL SNARK::CC SNARK::NAME SNARK::KIND SYMBOL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SYMBOL-ALIASES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN SYMBOL-ALIASES
;     (EQL SYMBOL SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::NAME SNARK::NAME2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PRINT-SYMBOL-TABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN PRINT-SYMBOL-TABLE
;     (STRING< (SNARK:SORT-NAME SNARK::X) (SNARK:SORT-NAME SNARK::Y))
; ==>
;   (SB-KERNEL:STRING<* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SIMPLE-BASE-STRING.

;     (SNARK-LISP:NEQL SNARK::PREVIOUS-NAME SNARK::NAME)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:NEQL SNARK::NAME (FIRST SNARK::AMBIGUOUS))
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::NAME (SNARK:CONSTANT-NAME SYMBOL))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SYMBOL-TO-NAME ...)
; compiling (DEFUN SYMBOL-BOOLEAN-VALUED-P ...)
; compiling (DEFUN SYMBOL-NUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFUN SYMBOL-NUMBER
;     (SNARK::CONSTANT-NUMBER SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE SYMBOL-NUMBERED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.lisp
; in: DEFINLINE SYMBOL-NUMBERED
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN THE-FUNCTION-SYMBOL ...)
; compiling (DEFUN CURRENT-FUNCTION-NAME ...)
; compiling (DEFUN INPUT-SYMBOL ...)
; compiling (DEFUN INPUT-CONSTANT-SYMBOL ...)
; compiling (DEFUN INPUT-PROPOSITION-SYMBOL ...)
; compiling (DEFUN INPUT-FUNCTION-SYMBOL ...)
; compiling (DEFUN INPUT-RELATION-SYMBOL ...)
; compiling (DEFUN INPUT-LOGICAL-SYMBOL ...)
; compiling (DEFUN EXPR-ARITY ...)
; compiling (DEFUN INPUT-HEAD-FUNCTION-SYMBOL ...)
; compiling (DEFUN INPUT-HEAD-RELATION-SYMBOL ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-table2.fasl written
; compilation finished in 0:00:00.147
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-definitions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SKOLEM-FUNCTION-ALIST*))
; compiling (DEFVAR *ALL-BOTH-POLARITY*)
; compiling (SETF *ALL-BOTH-POLARITY* ...)
; compiling (RPLACD *ALL-BOTH-POLARITY* ...)
; compiling NIL
; compiling NIL
; compiling (DEFUN INITIALIZE-SYMBOL-TABLE ...)
; compiling (DEFUN INITIALIZE-SYMBOL-TABLE2 ...)
; compiling (DEFUN INITIALIZE-SORT-THEORY2 ...)
; compiling (DEFUN NUMBER-SORT-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-definitions.lisp
; in: DEFUN NUMBER-SORT-NAME
;     (< 0 SNARK::X)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (> 0 SNARK::X)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (INTEGER * 0), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER * 0), not a FIXNUM.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-definitions.fasl written
; compilation finished in 0:00:00.034
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *WFF*)
; compiling (DECLAIM (SPECIAL *EXTENDED-VARIANT*))
; compiling (DEFVAR *ASSERTION-ANALYSIS-PATTERNS*)
; compiling (DEFVAR *ASSERTION-ANALYSIS-FUNCTION-INFO*)
; compiling (DEFVAR *ASSERTION-ANALYSIS-RELATION-INFO*)
; compiling (DEFSTRUCT AA-FUNCTION ...)
; compiling (DEFSTRUCT AA-RELATION ...)
; compiling (DEFUN AA-FUNCTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN AA-FUNCTION
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::F)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN AA-RELATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN AA-RELATION
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::P)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PRINT-ASSERTION-ANALYSIS-NOTE ...)
; compiling (DEFUN NOTE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN NOTE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN NOTE-FUNCTION-LEFT-IDENTITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN NOTE-FUNCTION-LEFT-IDENTITY
;     (PUSHNEW SNARK::E
;              (SNARK::AA-FUNCTION-LEFT-IDENTITIES (SNARK::AA-FUNCTION SNARK::F)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NOTE-FUNCTION-RIGHT-IDENTITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN NOTE-FUNCTION-RIGHT-IDENTITY
;     (PUSHNEW SNARK::E
;              (SNARK::AA-FUNCTION-RIGHT-IDENTITIES (SNARK::AA-FUNCTION SNARK::F)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NOTE-FUNCTION-LEFT-INVERSE ...)
; compiling (DEFUN NOTE-FUNCTION-RIGHT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-ASSOC1 ...)
; compiling (DEFUN NOTE-RELATION-ASSOC2 ...)
; compiling (DEFUN NOTE-RELATION-COMMUTATIVE ...)
; compiling (DEFUN NOTE-RELATION-LEFT-IDENTITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN NOTE-RELATION-LEFT-IDENTITY
;     (PUSHNEW SNARK::E
;              (SNARK::AA-RELATION-LEFT-IDENTITIES (SNARK::AA-RELATION SNARK::P)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NOTE-RELATION-RIGHT-IDENTITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN NOTE-RELATION-RIGHT-IDENTITY
;     (PUSHNEW SNARK::E
;              (SNARK::AA-RELATION-RIGHT-IDENTITIES (SNARK::AA-RELATION SNARK::P)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN NOTE-RELATION-LEFT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-RIGHT-INVERSE ...)
; compiling (DEFUN NOTE-RELATION-FUNCTIONAL ...)
; compiling (DEFUN NOTE-RELATION-CLOSURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN NOTE-RELATION-CLOSURE
;     (PUSHNEW SNARK::F
;              (SNARK::AA-RELATION-CLOSURE-FUNCTIONS (SNARK::AA-RELATION SNARK::P)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (PUSHNEW SNARK::P
;              (SNARK::AA-FUNCTION-CLOSURE-RELATIONS (SNARK::AA-FUNCTION SNARK::F)))
; --> LET* ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN FUNCTION-ASSOCIATIVITY-TESTS ...)
; compiling (DEFUN FUNCTION-COMMUTATIVITY-TESTS ...)
; compiling (DEFUN FUNCTION-IDENTITY-TESTS ...)
; compiling (DEFUN FUNCTION-INVERSE-TESTS ...)
; compiling (DEFUN RELATION-ASSOCIATIVITY-TESTS ...)
; compiling (DEFUN RELATION-COMMUTATIVITY-TESTS ...)
; compiling (DEFUN RELATION-IDENTITY-TESTS ...)
; compiling (DEFUN RELATION-INVERSE-TESTS ...)
; compiling (DEFUN RELATION-FUNCTIONALITY-TESTS ...)
; compiling (DEFUN RELATION-CLOSURE-TESTS ...)
; compiling (DEFUN INITIALIZE-ASSERTION-ANALYSIS ...)
; compiling (DEFUN ASSERTION-ANALYSIS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN ASSERTION-ANALYSIS
;     (APPLY (FIRST SNARK::DECL) (REST SNARK::DECL))
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (FIRST SNARK::DECL))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DEFUN SNARK::ASSERTION-ANALYSIS (SNARK:ROW)
;       (SNARK-LISP:PROG->
;         (WHEN (SNARK::ROW-BARE-P SNARK:ROW)
;           (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;           (IDENTITY SNARK::WFF SNARK::-> SNARK::*WFF*)
;           (QUOTE T SNARK::-> SNARK::*EXTENDED-VARIANT*)
;           (DOLIST SNARK::*ASSERTION-ANALYSIS-PATTERNS* SNARK::->* SNARK::X)
;           (SNARK::VARIANT (FIRST SNARK::X) SNARK::WFF NIL NIL SNARK::->*
;                           SNARK::VARPAIRS)
;           (SUBLIS SNARK::VARPAIRS (SECOND SNARK::X) SNARK::-> SNARK::DECL)
;           (APPLY (FIRST SNARK::DECL) (REST SNARK::DECL))
;           (RETURN-FROM SNARK::ASSERTION-ANALYSIS))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::ASSERTION-ANALYSIS
;     (SNARK-LISP:PROG->
;       (WHEN (SNARK::ROW-BARE-P SNARK:ROW)
;         (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;         (IDENTITY SNARK::WFF SNARK::-> SNARK::*WFF*)
;         (QUOTE T SNARK::-> SNARK::*EXTENDED-VARIANT*)
;         (DOLIST SNARK::*ASSERTION-ANALYSIS-PATTERNS* SNARK::->* SNARK::X)
;         (SNARK::VARIANT (FIRST SNARK::X) SNARK::WFF NIL NIL SNARK::->*
;                         SNARK::VARPAIRS)
;         (SUBLIS SNARK::VARPAIRS (SECOND SNARK::X) SNARK::-> SNARK::DECL)
;         (APPLY (FIRST SNARK::DECL) (REST SNARK::DECL))
;         (RETURN-FROM SNARK::ASSERTION-ANALYSIS))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM ASSERTION-ANALYSIS). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN MAYBE-DECLARE-FUNCTION-ASSOCIATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-FUNCTION-COMMUTATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-RELATION-COMMUTATIVE ...)
; compiling (DEFUN MAYBE-DECLARE-FUNCTION-IDENTITY ...)
; compiling (DEFUN AA-RELATION-ASSOCIATIVE ...)
; compiling (DEFUN COMPLETE-ASSERTION-ANALYSIS ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR ROW ...)
; compiling (DEFUN |ATOM-REL#| ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN |ATOM-REL#|
;     (SNARK::CONSTANT-NUMBER ATOM)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PURITY-TEST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.lisp
; in: DEFUN PURITY-TEST
;     (MEMBER (SNARK::|ATOM-REL#| ATOM) SNARK::PURERELS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-INDEXES-ONLY
;        SNARK::RELATION-REFERENCE-COUNTS SNARK::->* SNARK::|SIGNEDREL#|)
;       (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;       (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;           (- SNARK::|REL#|)
;           SNARK::|REL#|
;           SNARK::->
;           SNARK::|OPPSIGNEDREL#|)
;       (WHEN
;           (= 0
;              (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                         SNARK::|OPPSIGNEDREL#|))
;         (SNARK::SYMBOL-NUMBERED SNARK::|REL#| SNARK::-> SYMBOL)
;         (IF (< 0 SNARK::|SIGNEDREL#|)
;             "positively"
;             "negatively"
;             SNARK::->
;             SNARK::SIGN)
;         (COND
;          ((NOT #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a proposition that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN))
;          ((OR # # #))
;          ((INTEGERP #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a ~D-ary relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL # SNARK::SIGN))
;          (T (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN)))))
; --> BLOCK FLET BLOCK LET 
; ==>
;   (ABS SNARK::|SIGNEDREL#|)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a (REAL 0), not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a (REAL 0), not a RATIONAL.

;     (= 0
;        (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                   SNARK::|OPPSIGNEDREL#|))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-INDEXES-ONLY
;        SNARK::RELATION-REFERENCE-COUNTS SNARK::->* SNARK::|SIGNEDREL#|)
;       (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;       (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;           (- SNARK::|REL#|)
;           SNARK::|REL#|
;           SNARK::->
;           SNARK::|OPPSIGNEDREL#|)
;       (WHEN
;           (= 0
;              (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                         SNARK::|OPPSIGNEDREL#|))
;         (SNARK::SYMBOL-NUMBERED SNARK::|REL#| SNARK::-> SYMBOL)
;         (IF (< 0 SNARK::|SIGNEDREL#|)
;             "positively"
;             "negatively"
;             SNARK::->
;             SNARK::SIGN)
;         (COND
;          ((NOT #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a proposition that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN))
;          ((OR # # #))
;          ((INTEGERP #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a ~D-ary relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL # SNARK::SIGN))
;          (T (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN)))))
; --> BLOCK FLET BLOCK LET LET WHEN IF LET SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;        SNARK::RELATION-REFERENCE-COUNTS SNARK::->* COUNT SNARK::|SIGNEDREL#|)
;       (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;       (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;           (- SNARK::|REL#|)
;           SNARK::|REL#|
;           SNARK::->
;           SNARK::|OPPSIGNEDREL#|)
;       (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                  SNARK::|OPPSIGNEDREL#| SNARK::-> SNARK::OPPCOUNT)
;       (UNLESS (AND (< 0 SNARK::|SIGNEDREL#|) (< 0 SNARK::OPPCOUNT))
;         (FORMAT T "~%; ~5D positive and ~5D negative occurrences of ~S."
;                 (IF (< 0 SNARK::|SIGNEDREL#|)
;                     COUNT
;                     SNARK::OPPCOUNT)
;                 (IF (> 0 SNARK::|SIGNEDREL#|)
;                     COUNT
;                     SNARK::OPPCOUNT)
;                 (SNARK::SYMBOL-NUMBERED SNARK::|REL#|))))
; --> BLOCK FLET BLOCK LET 
; ==>
;   (ABS SNARK::|SIGNEDREL#|)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a (REAL 0), not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a (REAL 0), not a RATIONAL.

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< 0 SNARK::OPPCOUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (> 0 SNARK::|SIGNEDREL#|)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::SYMBOL-NUMBERED SNARK::|REL#|)
; --> 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (FUNCALL SNARK::ROW-MAPPER SNARK::->* SNARK:ROW)
;       (UNLESS
;           (OR (SNARK::ROW-HINT-P SNARK:ROW)
;               (EQ :CHECKING (SNARK::ROW-PURE SNARK:ROW)))
;         (SETF (SNARK::ROW-PURE SNARK:ROW) :CHECKING)
;         (SNARK::ADJUST-REFERENCE-COUNTS SNARK:ROW 1)))
; --> BLOCK FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ROW-MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (FORMAT T "~2&; Purity test finds")
;       (SNARK-LISP:PROG->
;         (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;          SNARK::RELATION-REFERENCE-COUNTS SNARK::->* COUNT SNARK::|SIGNEDREL#|)
;         (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;         (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;             (- SNARK::|REL#|)
;             SNARK::|REL#|
;             SNARK::->
;             SNARK::|OPPSIGNEDREL#|)
;         (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                    SNARK::|OPPSIGNEDREL#| SNARK::->
;                                    SNARK::OPPCOUNT)
;         (UNLESS (AND (< 0 SNARK::|SIGNEDREL#|) (< 0 SNARK::OPPCOUNT))
;           (FORMAT T "~%; ~5D positive and ~5D negative occurrences of ~S."
;                   (IF #
;                       COUNT
;                       SNARK::OPPCOUNT)
;                   (IF #
;                       COUNT
;                       SNARK::OPPCOUNT)
;                   (SNARK::SYMBOL-NUMBERED SNARK::|REL#|)))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:PROG->
;       (FUNCALL SNARK::ROW-MAPPER SNARK::->* SNARK:ROW)
;       (WHEN (EQ :CHECKING (SNARK::ROW-PURE SNARK:ROW))
;         (SETF (SNARK::ROW-PURE SNARK:ROW) NIL)))
; --> BLOCK FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ROW-MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (FUNCALL SNARK::ROW-MAPPER SNARK::->* SNARK:ROW)
;       (WHEN (EQ :CHECKING (SNARK::ROW-PURE SNARK:ROW))
;         (WHEN
;             (SNARK-LISP:PROG->
;               (SNARK::MAP-ATOMS-IN-WFF # SNARK::->* ATOM SNARK::POLARITY)
;               (DECLARE #)
;               (WHEN # #))
;           (SETF # T)
;           (SNARK::ADJUST-REFERENCE-COUNTS SNARK:ROW -1)
;           (SNARK::PRINT-PURE-ROW SNARK:ROW))))
; --> BLOCK FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ROW-MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF
;      (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS SNARK::|REL#|)
;      SNARK::N)
; --> LET* 
; ==>
;   (+ SNARK::N
;      (SNARK-SPARSE-ARRAY::SPAREF1 #:RELATION-REFERENCE-COUNTS934 #:|REL#935|))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF
;      (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                 (- SNARK::|REL#|))
;      SNARK::N)
; --> LET* 
; ==>
;   (+ SNARK::N
;      (SNARK-SPARSE-ARRAY::SPAREF1 #:RELATION-REFERENCE-COUNTS937 #:G938))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF
;      (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                 (- SNARK::|REL#|))
;      SNARK::N)
; --> LET* 
; ==>
;   (+ SNARK::N
;      (SNARK-SPARSE-ARRAY::SPAREF1 #:RELATION-REFERENCE-COUNTS931 #:G932))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF
;      (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS SNARK::|REL#|)
;      SNARK::N)
; --> LET* 
; ==>
;   (+ SNARK::N
;      (SNARK-SPARSE-ARRAY::SPAREF1 #:RELATION-REFERENCE-COUNTS928 #:|REL#929|))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (FORMAT T "~2&; Purity test finds")
;       (SNARK-LISP:PROG->
;         (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;          SNARK::RELATION-REFERENCE-COUNTS SNARK::->* COUNT SNARK::|SIGNEDREL#|)
;         (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;         (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;             (- SNARK::|REL#|)
;             SNARK::|REL#|
;             SNARK::->
;             SNARK::|OPPSIGNEDREL#|)
;         (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                    SNARK::|OPPSIGNEDREL#| SNARK::->
;                                    SNARK::OPPCOUNT)
;         (UNLESS (AND (< 0 SNARK::|SIGNEDREL#|) (< 0 SNARK::OPPCOUNT))
;           (FORMAT T "~%; ~5D positive and ~5D negative occurrences of ~S."
;                   (IF #
;                       COUNT
;                       SNARK::OPPCOUNT)
;                   (IF #
;                       COUNT
;                       SNARK::OPPCOUNT)
;                   (SNARK::SYMBOL-NUMBERED SNARK::|REL#|)))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;        SNARK::RELATION-REFERENCE-COUNTS SNARK::->* COUNT SNARK::|SIGNEDREL#|)
;       (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;       (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;           (- SNARK::|REL#|)
;           SNARK::|REL#|
;           SNARK::->
;           SNARK::|OPPSIGNEDREL#|)
;       (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                  SNARK::|OPPSIGNEDREL#| SNARK::-> SNARK::OPPCOUNT)
;       (UNLESS (AND (< 0 SNARK::|SIGNEDREL#|) (< 0 SNARK::OPPCOUNT))
;         (FORMAT T "~%; ~5D positive and ~5D negative occurrences of ~S."
;                 (IF (< 0 SNARK::|SIGNEDREL#|)
;                     COUNT
;                     SNARK::OPPCOUNT)
;                 (IF (> 0 SNARK::|SIGNEDREL#|)
;                     COUNT
;                     SNARK::OPPCOUNT)
;                 (SNARK::SYMBOL-NUMBERED SNARK::|REL#|))))
; --> BLOCK FLET BLOCK LET 
; ==>
;   (ABS SNARK::|SIGNEDREL#|)
; 
; note: forced to do full call
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

;     (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a (REAL 0), not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (REAL 0), not a DOUBLE-FLOAT.
;       etc.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (REAL 0), not a FIXNUM.
;       The result is a (VALUES (REAL * 0) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a (REAL 0), not a SINGLE-FLOAT.
;       The result is a (VALUES (REAL * 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (< 0 SNARK::OPPCOUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (> 0 SNARK::|SIGNEDREL#|)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-INDEXES-ONLY
;        SNARK::RELATION-REFERENCE-COUNTS SNARK::->* SNARK::|SIGNEDREL#|)
;       (ABS SNARK::|SIGNEDREL#| SNARK::-> SNARK::|REL#|)
;       (IF (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
;           (- SNARK::|REL#|)
;           SNARK::|REL#|
;           SNARK::->
;           SNARK::|OPPSIGNEDREL#|)
;       (WHEN
;           (= 0
;              (SNARK-SPARSE-ARRAY:SPAREF SNARK::RELATION-REFERENCE-COUNTS
;                                         SNARK::|OPPSIGNEDREL#|))
;         (SNARK::SYMBOL-NUMBERED SNARK::|REL#| SNARK::-> SYMBOL)
;         (IF (< 0 SNARK::|SIGNEDREL#|)
;             "positively"
;             "negatively"
;             SNARK::->
;             SNARK::SIGN)
;         (COND
;          ((NOT #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a proposition that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN))
;          ((OR # # #))
;          ((INTEGERP #) (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a ~D-ary relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL # SNARK::SIGN))
;          (T (PUSH SNARK::|REL#| SNARK::PURERELS)
;           (WARN
;            "~S is a relation that occurs only ~A; disabling rows that contain it."
;            SYMBOL SNARK::SIGN)))))
; --> BLOCK FLET BLOCK LET 
; ==>
;   (ABS SNARK::|SIGNEDREL#|)
; 
; note: forced to do full call
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES (REAL 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).

;     (= SNARK::|SIGNEDREL#| SNARK::|REL#|)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a (REAL 0), not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (REAL 0), not a DOUBLE-FLOAT.
;       etc.

;     (- SNARK::|REL#|)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::|REL#|))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (REAL 0), not a FIXNUM.
;       The result is a (VALUES (REAL * 0) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a (REAL 0), not a SINGLE-FLOAT.
;       The result is a (VALUES (REAL * 0) &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< 0 SNARK::|SIGNEDREL#|)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-analysis.fasl written
; compilation finished in 0:00:00.184
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations-tables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFPARAMETER $RCC8-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-II-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-PP-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-PI-RELATION-CODE ...)
; compiling (DEFPARAMETER $TIME-IP-RELATION-CODE ...)
; compiling (DEFPARAMETER $RCC8-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-III-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PPP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PII-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PPI-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-PIP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IPI-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IIP-COMPOSITION-TABLE ...)
; compiling (DEFPARAMETER $TIME-IPP-COMPOSITION-TABLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations-tables.fasl written
; compilation finished in 0:00:00.007
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLARE-SNARK-OPTION RCC8-REGION-SORT-NAME ...)
; compiling (DECLARE-SNARK-OPTION TIME-INTERVAL-SORT-NAME ...)
; compiling (DECLARE-SNARK-OPTION TIME-POINT-SORT-NAME ...)
; compiling (DEFPARAMETER RCC8-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER RCC8-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-II-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-II-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PP-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PP-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PI-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-PI-MORE-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-IP-JEPD-RELATION-NAMES ...)
; compiling (DEFPARAMETER TIME-IP-MORE-RELATION-NAMES ...)
; compiling (DEFUN JEPD-RELATION-INPUT-FUNCTION ...)
; compiling (DEFUN 1-OR-?S ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN 1-OR-?S
;     (MEMBER SNARK::K SNARK::I)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: The first argument is a UNSIGNED-BYTE, not a (OR FIXNUM (NOT NUMBER)).

;     (DOTIMES (SNARK::K SNARK::N)
;       (SNARK-LISP:COLLECT
;        (IF (IF (CONSP SNARK::I)
;                (MEMBER SNARK::K SNARK::I)
;                (EQL SNARK::I SNARK::K))
;            (IF (EQ :POS SNARK::POLARITY)
;                1
;                (SNARK::MAKE-VARIABLE))
;            (IF (EQ :POS SNARK::POLARITY)
;                (SNARK::MAKE-VARIABLE)
;                1))
;        SNARK::L))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL SNARK::I SNARK::K)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

;     (DOTIMES (SNARK::K SNARK::N)
;       (SNARK-LISP:COLLECT
;        (IF (IF (CONSP SNARK::I)
;                (MEMBER SNARK::K SNARK::I)
;                (EQL SNARK::I SNARK::K))
;            (IF (EQ :POS SNARK::POLARITY)
;                1
;                (SNARK::MAKE-VARIABLE))
;            (IF (EQ :POS SNARK::POLARITY)
;                (SNARK::MAKE-VARIABLE)
;                1))
;        SNARK::L))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN 1S-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN 1S-COUNT
;     (+ (SNARK::1S-COUNT (SNARK-LISP:CDRC SNARK::X)) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN 1-INDEXES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN 1-INDEXES
;     (+ SNARK::N 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN JEPD-RELATION-COMPOSITION-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN JEPD-RELATION-COMPOSITION-REWRITER
;     (FUNCALL SNARK::FUN SNARK::L1 SNARK::L2 SNARK::X SNARK::Y SNARK::Z SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN JEPD-RELATION-COMPOSITION-REWRITER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN JEPD-RELATION-COMPOSITION-REWRITER1
;     (AREF SNARK::TABLE SNARK::I SNARK::J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (INCF SNARK::J)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::J)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::J)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::J)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN REVERSEM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN REVERSEM
;     (LENGTH SNARK::L)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (SUBSEQ SNARK::L (- SNARK::N SNARK::M) SNARK::N)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (SUBSEQ SNARK::L SNARK::M (- SNARK::N SNARK::M))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (SUBSEQ SNARK::L 0 SNARK::M)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (- SNARK::N SNARK::M)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN XX-INTERSECTION ...)
; compiling (DEFUN JEPD-RELATION-INTERSECTION-REWRITER1 ...)
; compiling (DEFUN JEPD-RELATION-ATOM-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN JEPD-RELATION-ATOM-WEIGHT
;     (+ (SNARK::WEIGHT (POP SNARK:ARGS) SUBST)
;        (SNARK::WEIGHT (POP SNARK:ARGS) SUBST)
;        (SNARK::1S-COUNT (FIRST SNARK:ARGS) SUBST)
;        (SNARK::FUNCTION-WEIGHT (SNARK:HEAD SNARK::X)))
; --> + + 
; ==>
;   (+ (SNARK::WEIGHT (POP SNARK:ARGS) SUBST)
;      (SNARK::WEIGHT (POP SNARK:ARGS) SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> + 
; ==>
;   (+
;    (+ (SNARK::WEIGHT (POP SNARK:ARGS) SUBST)
;       (SNARK::WEIGHT (POP SNARK:ARGS) SUBST))
;    (SNARK::1S-COUNT (FIRST SNARK:ARGS) SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+
;    (+
;     (+ (SNARK::WEIGHT (POP SNARK:ARGS) SUBST)
;        (SNARK::WEIGHT (POP SNARK:ARGS) SUBST))
;     (SNARK::1S-COUNT (FIRST SNARK:ARGS) SUBST))
;    (SNARK::FUNCTION-WEIGHT (SNARK:HEAD SNARK::X)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN DECLARE-JEPD-RELATION ...)
; compiling (DEFUN DECLARE-JEPD-RELATION-INPUT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN DECLARE-JEPD-RELATION-INPUT
;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN DECLARE-EQUALITY-JEPD-RELATION ...)
; compiling (DEFUN DECLARE-JEPD-RELATION-INTERSECTION ...)
; compiling (DEFUN DECLARE-JEPD-RELATIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN DECLARE-JEPD-RELATIONS
;     (LENGTH SNARK::NAMES)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN JEPD-RELATION-CODE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN JEPD-RELATION-CODE
;     (ASSOC SNARK::X SNARK::ALIST)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN MAKE-COMPOSITION-TABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN MAKE-COMPOSITION-TABLE
;     (LENGTH SNARK::ICODE1)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SNARK::ICODE2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFVAR *RCC8-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-III-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-IPI-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PII-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PIP-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PPI-COMPOSITION-TABLE* ...)
; compiling (DEFVAR *TIME-PPP-COMPOSITION-TABLE* ...)
; compiling (DEFUN FIRSTA ...)
; compiling (DEFUN RESTA ...)
; compiling (DEFUN DECLARE-RCC8-RELATIONS ...)
; compiling (DEFUN DECLARE-TIME-RELATIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.lisp
; in: DEFUN DECLARE-TIME-RELATIONS
;     (LENGTH SNARK::NAMES)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SNARK::$TIME-PI-RELATION-CODE)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SNARK::$TIME-PP-RELATION-CODE)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SNARK::$TIME-II-RELATION-CODE)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN JEPD-ATOM-TO-LISP ...)
; compiling (DEFUN EQUAL-JEPD-RELATION-ATOM-ARGS-P ...)
; compiling (DEFUN VARIANT-JEPD-RELATION-ATOM-ARGS ...)
; compiling (DEFUN UNIFY-JEPD-RELATION-ATOM-ARGS ...)
; compiling (DEFUN JEPD-RELATION-ATOM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/jepd-relations.fasl written
; compilation finished in 0:00:00.248
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *DATE-POINT*)
; compiling (DEFVAR *UTIME-POINT*)
; compiling (DEFVAR *DATE-INTERVAL*)
; compiling (DEFVAR *UTIME-INTERVAL*)
; compiling (DEFUN DECLARE-CODE-FOR-DATES ...)
; compiling (DEFUN CAN-BE-DATE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN CAN-BE-DATE-P
;     (FUNCALL SNARK::ACTION "~A cannot be a date." LIST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (<= 1 SNARK::DAY (SNARK-LISP:DAYS-PER-MONTH SNARK::MONTH SNARK::YEAR))
; --> 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE REAL #:G7 #:G6 #:G5)) (IF (<= #:G7 #:G6) (IF (<= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= 1900 SNARK::YEAR)
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (<= 1 SNARK::MONTH 12)
; --> 
; --> (LAMBDA (#:G4 #:G3 #:G2) (DECLARE (TYPE REAL #:G4 #:G3 #:G2)) (IF (<= #:G4 #:G3) (IF (<= #:G3 #:G2) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G4 #:G3 #:G2) (DECLARE (TYPE REAL #:G4 #:G3 #:G2)) (IF (<= #:G4 #:G3) (IF (<= #:G3 #:G2) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       etc.

;     (<= 1 SNARK::DAY (SNARK-LISP:DAYS-PER-MONTH SNARK::MONTH SNARK::YEAR))
; --> 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE REAL #:G7 #:G6 #:G5)) (IF (<= #:G7 #:G6) (IF (<= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G7 #:G6 #:G5) (DECLARE (TYPE REAL #:G7 #:G6 #:G5)) (IF (<= #:G7 #:G6) (IF (<= #:G6 #:G5) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (<= 0 SNARK::HOUR 23)
; --> 
; --> (LAMBDA (#:G10 #:G9 #:G8) (DECLARE (TYPE REAL #:G10 #:G9 #:G8)) (IF (<= #:G10 #:G9) (IF (<= #:G9 #:G8) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G10 #:G9 #:G8) (DECLARE (TYPE REAL #:G10 #:G9 #:G8)) (IF (<= #:G10 #:G9) (IF (<= #:G9 #:G8) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

;     (<= 0 SNARK::MINUTE 59)
; --> 
; --> (LAMBDA (#:G13 #:G12 #:G11) (DECLARE (TYPE REAL #:G13 #:G12 #:G11)) (IF (<= #:G13 #:G12) (IF (<= #:G12 #:G11) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G13 #:G12 #:G11) (DECLARE (TYPE REAL #:G13 #:G12 #:G11)) (IF (<= #:G13 #:G12) (IF (<= #:G12 #:G11) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

;     (<= 0 SECOND 59)
; --> 
; --> (LAMBDA (#:G16 #:G15 #:G14) (DECLARE (TYPE REAL #:G16 #:G15 #:G14)) (IF (<= #:G16 #:G15) (IF (<= #:G15 #:G14) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G16 #:G15 #:G14) (DECLARE (TYPE REAL #:G16 #:G15 #:G14)) (IF (<= #:G16 #:G15) (IF (<= #:G15 #:G14) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

; compiling (DEFUN ENCODE-UNIVERSAL-TIME-POINT ...)
; compiling (DEFUN DECODE-UNIVERSAL-TIME-POINT ...)
; compiling (DEFUN ENCODE-UNIVERSAL-TIME-INTERVAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN ENCODE-UNIVERSAL-TIME-INTERVAL
;     (* (SNARK-LISP:DAYS-PER-MONTH SNARK::MONTH SNARK::YEAR) 86400)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LET ((SNARK::V
;            (SNARK::ENCODE-UNIVERSAL-TIME-POINT SNARK::YEAR SNARK::MONTH
;                                                SNARK::DAY SNARK::HOUR
;                                                SNARK::MINUTE SECOND)))
;       (LIST SNARK::V
;             (+ SNARK::V
;                (OR (AND SECOND 1) (AND SNARK::MINUTE 60) (AND SNARK::HOUR 3600)
;                    (AND SNARK::DAY 86400) (AND SNARK::MONTH #) (* # 86400)))))
; --> MULTIPLE-VALUE-BIND LET UNLESS IF TYPEP LET SB-C::%TYPEP-WRAPPER LET AND 
; --> IF AND THE LOCALLY AND THE >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (* (SNARK-LISP:DAYS-PER-MONTH SNARK::MONTH SNARK::YEAR) 86400)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::V
;        (OR (AND SECOND 1) (AND SNARK::MINUTE 60) (AND SNARK::HOUR 3600)
;            (AND SNARK::DAY 86400)
;            (AND SNARK::MONTH
;                 (* (SNARK-LISP:DAYS-PER-MONTH SNARK::MONTH SNARK::YEAR) 86400))
;            (*
;             (IF (SNARK-LISP:LEAP-YEAR-P SNARK::YEAR)
;                 366
;                 365)
;             86400)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN DECODE-UNIVERSAL-TIME-INTERVAL ...)
; compiling (DEFUN PP-COMPARE-UNIVERSAL-TIMES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN PP-COMPARE-UNIVERSAL-TIMES
;     (< SNARK::POINT1 SNARK::POINT2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::POINT1 SNARK::POINT2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK::POINT1 SNARK::POINT2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::POINT1 SNARK::POINT2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN II-COMPARE-UNIVERSAL-TIMES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN II-COMPARE-UNIVERSAL-TIMES
;     (= SNARK::START1 SNARK::START2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< SNARK::FINISH1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::FINISH1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (= SNARK::FINISH1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (> SNARK::START1 SNARK::START2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (= SNARK::FINISH1 SNARK::START2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= SNARK::START1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< SNARK::START1 SNARK::START2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::FINISH1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK::FINISH1 SNARK::FINISH2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (<= SNARK::FINISH1 SNARK::START2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK::START1 SNARK::FINISH2)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= SNARK::START1 SNARK::START2)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (= SNARK::FINISH1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

;     (> SNARK::START1 SNARK::START2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (<= SNARK::FINISH1 SNARK::START2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (>= SNARK::START1 SNARK::FINISH2)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (< SNARK::START1 SNARK::START2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::FINISH1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK::FINISH1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (= SNARK::START1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (= SNARK::FINISH1 SNARK::START2)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (< SNARK::FINISH1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::FINISH1 SNARK::FINISH2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN PI-COMPARE-UNIVERSAL-TIMES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN PI-COMPARE-UNIVERSAL-TIMES
;     (= SNARK::POINT SNARK::START)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= SNARK::POINT SNARK::FINISH)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK::POINT SNARK::START)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK::POINT SNARK::FINISH)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK::POINT SNARK::START)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (>= SNARK::POINT SNARK::FINISH)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (= SNARK::POINT SNARK::FINISH)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (= SNARK::POINT SNARK::START)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN DECLARE-DATE-FUNCTIONS ...)
; compiling (DEFUN INPUT-DATE-POINT ...)
; compiling (DEFUN INPUT-DATE-INTERVAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN INPUT-DATE-INTERVAL
;     (ASSERT (< SNARK::START SNARK::FINISH))
; --> TAGBODY LET WHEN IF 
; ==>
;   (< #:TEMP184 #:TEMP185)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN UTIME-POINT-TERM-TO-LISP ...)
; compiling (DEFUN UTIME-INTERVAL-TERM-TO-LISP ...)
; compiling (DEFUN UTIME-POINT-TERM-P ...)
; compiling (DEFUN UTIME-INTERVAL-TERM-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN UTIME-INTERVAL-TERM-P
;     (EQL SNARK:ARG1 (FIRST SNARK:ARGS))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (EQL SNARK:ARG2 (SECOND SNARK:ARGS))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; compiling (DEFUN TIME-II-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN TIME-PP-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN TIME-PI-ATOM-REWRITER-FOR-DATES ...)
; compiling (DEFUN DECLARE-UTIME-PP-COMPOSITION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN DECLARE-UTIME-PP-COMPOSITION
;     (/= SNARK::M SNARK::N)
; --> IF = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (< SNARK::M SNARK::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; compiling (DEFUN DECLARE-UTIME-PI-COMPOSITION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.lisp
; in: DEFUN DECLARE-UTIME-PI-COMPOSITION
;     (/= SNARK::M SNARK::N)
; --> IF = EQL IF EQL SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (< SNARK::M SNARK::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/date-reasoning2.fasl written
; compilation finished in 0:00:00.157
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *PROCESSING-ROW*))
; compiling (DEFGENERIC CHECKPOINT-THEORY ...)
; compiling (DEFGENERIC UNCHECKPOINT-THEORY ...)
; compiling (DEFGENERIC RESTORE-THEORY ...)
; compiling (DEFGENERIC THEORY-CLOSURE ...)
; compiling (DEFGENERIC THEORY-ASSERT ...)
; compiling (DEFGENERIC THEORY-DENY ...)
; compiling (DEFGENERIC THEORY-SIMPLIFY ...)
; compiling (DEFGENERIC THEORY-REWRITE ...)
; compiling (DEFUN THEORY-ASSERT2 ...)
; compiling (DEFUN THEORY-DENY2 ...)
; compiling (DEFUN THEORY-TRUEP ...)
; compiling (DEFUN THEORY-FALSEP ...)
; compiling (DEFUN SIMPLIFY-CONSTRAINT-ALIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp
; in: DEFUN SIMPLIFY-CONSTRAINT-ALIST
;     (SNARK-LISP:LCONS (CAR SNARK::X)
;                       (SNARK::THEORY-SIMPLIFY (CDR SNARK::X) (CAR SNARK::X))
;                       SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G174 #:G176)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN REWRITE-CONSTRAINT-ALIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp
; in: DEFUN REWRITE-CONSTRAINT-ALIST
;     (SNARK-LISP:LCONS (CAR SNARK::X)
;                       (SNARK::THEORY-REWRITE (CDR SNARK::X) (CAR SNARK::X))
;                       SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G190 #:G192)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN ASSUMPTIVE-CONSTRAINT-THEORY-P ...)
; compiling (DEFUN ROW-CONSTRAINED-P ...)
; compiling (DEFUN ROW-CONSTRAINED-P2 ...)
; compiling (DEFUN ROW-UNIT-CONSTRAINT ...)
; compiling (DEFUN ROW-CONSTRAINT-COVERAGE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp
; in: DEFUN ROW-CONSTRAINT-COVERAGE
;     (MEMBER SNARK::THEORY SNARK::THEORIES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN ROW-CONSTRAINT-COVERAGE* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.lisp
; in: DEFUN ROW-CONSTRAINT-COVERAGE*
;     (MEMBER SNARK::THEORY SNARK::THEORIES)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (DEFUN SNARK::ROW-CONSTRAINT-COVERAGE* (SNARK:ROWS SNARK::THEORIES)
;       (AND SNARK:ROWS
;            (DOLIST (SNARK::X (SNARK:ROW-CONSTRAINTS #) T)
;              (SNARK-LISP:MVLET (#)
;                (UNLESS # #)))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::ROW-CONSTRAINT-COVERAGE*
;     (AND SNARK:ROWS
;          (DOLIST (SNARK::X (SNARK:ROW-CONSTRAINTS #) T)
;            (SNARK-LISP:MVLET (#)
;              (UNLESS # #)))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM ROW-CONSTRAINT-COVERAGE* NIL). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)
; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)
; compiling (DEFUN ASSUMPTION-TEST1 ...)
; compiling (DEFUN ASSUMPTION-TEST2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/constraints.fasl written
; compilation finished in 0:00:00.103
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN NOT-WFF-ERROR ...)
; compiling (DEFUN NOT-CLAUSE-ERROR ...)
; compiling (DEFUN HEAD-IS-LOGICAL-SYMBOL ...)
; compiling (DEFUN NEGATION-P ...)
; compiling (DEFUN CONJUNCTION-P ...)
; compiling (DEFUN DISJUNCTION-P ...)
; compiling (DEFUN IMPLICATION-P ...)
; compiling (DEFUN REVERSE-IMPLICATION-P ...)
; compiling (DEFUN EQUIVALENCE-P ...)
; compiling (DEFUN EXCLUSIVE-OR-P ...)
; compiling (DEFUN CONDITIONAL-P ...)
; compiling (DEFUN UNIVERSAL-QUANTIFICATION-P ...)
; compiling (DEFUN EXISTENTIAL-QUANTIFICATION-P ...)
; compiling (DEFUN ATOM-P ...)
; compiling (DEFUN LITERAL-P ...)
; compiling (DEFUN CLAUSE-P ...)
; compiling (DEFUN EQUALITY-RELATION-SYMBOL-P ...)
; compiling (DEFUN EQUALITY-P ...)
; compiling (DEFUN POSITIVE-EQUALITY-WFF-P ...)
; compiling (DECLARE-SNARK-OPTION ELIMINATE-NEGATIONS ...)
; compiling (DECLARE-SNARK-OPTION FLATTEN-CONNECTIVES ...)
; compiling (DECLARE-SNARK-OPTION EX-JOIN-NEGATION ...)
; compiling (DEFUN CONJOIN* ...)
; compiling (DEFUN DISJOIN* ...)
; compiling (DEFUN CONJOIN ...)
; compiling (DEFUN DISJOIN ...)
; compiling (DEFUN AO-JOIN* ...)
; compiling (DEFUN NOT-NOT-ELIMINATE ...)
; compiling (DEFUN MAKE-EQUIVALENCE* ...)
; compiling (DEFUN MAKE-EXCLUSIVE-OR* ...)
; compiling (DEFUN MAKE-EQUIVALENCE ...)
; compiling (DEFUN MAKE-EXCLUSIVE-OR ...)
; compiling (DEFUN EX-JOIN* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN EX-JOIN*
;     (LENGTH
;      (SETF SNARK::WFFS
;              (SNARK::ARGUMENT-LIST-A1 SNARK::CONNECTIVE SNARK::WFFS SUBST
;                                       IDENTITY)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH (SETF SNARK::WFFS (REMOVE SNARK::NOT-IDENTITY SNARK::WFFS)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (LENGTH (SETF SNARK::WFFS (REMOVE SNARK::WFF SNARK::WFFS :TEST (LAMBDA # #))))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; compiling (DEFUN NEGATE0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN NEGATE0
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN NEGATE* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN NEGATE*
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN MAKE-IMPLICATION* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN MAKE-IMPLICATION*
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN MAKE-REVERSE-IMPLICATION* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN MAKE-REVERSE-IMPLICATION*
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN MAKE-CONDITIONAL* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN MAKE-CONDITIONAL*
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN MAKE-CONDITIONAL-ANSWER* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN MAKE-CONDITIONAL-ANSWER*
;     (LENGTH SNARK::WFFS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN NEGATE ...)
; compiling (DEFUN RELATION-COMPLEMENTER ...)
; compiling (DEFUN PROPOSITION-COMPLEMENTER ...)
; compiling (DEFUN COMPLEMENT-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN COMPLEMENT-NAME
;     (MAKE-SYMBOL SNARK::~S)
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-STRING.

; compiling (DEFUN MAKE-IMPLICATION ...)
; compiling (DEFUN MAKE-REVERSE-IMPLICATION ...)
; compiling (DEFUN MAKE-CONDITIONAL ...)
; compiling (DEFUN MAKE-CONDITIONAL-ANSWER ...)
; compiling (DEFUN MAKE-EQUALITY0 ...)
; compiling (DEFUN MAKE-EQUALITY ...)
; compiling (DEFUN COMPLEMENT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN COMPLEMENT-P
;     (EQL SNARK::WFF1 SNARK::WFF2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN EQUAL-OR-COMPLEMENT-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.lisp
; in: DEFUN EQUAL-OR-COMPLEMENT-P
;     (EQL SNARK::WFF1 SNARK::WFF2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/connectives.fasl written
; compilation finished in 0:00:00.275
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAP-ATOMS-IN-CLAUSE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-ATOMS-IN-CLAUSE
;     (FUNCALL SNARK::CC SNARK::WFF SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-ATOMS-IN-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-ATOMS-IN-WFF
;     (FUNCALL SNARK::CC SNARK::WFF SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-ATOMS-IN-WFF-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-ATOMS-IN-WFF-AND-COMPOSE-RESULT
;     (SNARK::FANCY-MAKE-COMPOUND* SNARK:HEAD (LIST SNARK::ARG*))
; --> LET* IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:G45)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::FANCY-MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*)
; --> LET* IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:G47)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::WFF SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-TERMS-IN-WFF ...)
; compiling (DEFUN MAP-TERMS-IN-WFF-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-ATOM ...)
; compiling (DEFUN MAP-TERMS-IN-ATOM-AND-COMPOSE-RESULT ...)
; compiling (DEFUN MAP-TERMS-IN-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-TERMS-IN-TERM
;     (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT
;     (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC
;              (LET* ((SNARK:ARGS (SNARK::ARGSA SNARK::TERM))
;                     (SNARK::ARGS*
;                      (SNARK::MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT
;                       SNARK::CC SNARK::HEAD-IF-ASSOCIATIVE SNARK:ARGS SUBST
;                       SNARK::POLARITY)))
;                (IF (EQ SNARK:ARGS SNARK::ARGS*)
;                    SNARK::TERM
;                    (SNARK:MAKE-COMPOUND* (SNARK:HEAD SNARK::TERM) SNARK::ARGS*)))
;              SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:LCONS
;      (SNARK::MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT SNARK::CC (CAR SNARK::TERM)
;                                                   SUBST SNARK::POLARITY)
;      (SNARK::MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT SNARK::CC (CDR SNARK::TERM)
;                                                   SUBST SNARK::POLARITY)
;      SNARK::TERM)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G123 #:G125)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G122 #:G124)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G122 #:G124)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-TERMS-IN-LIST-OF-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-TERMS-IN-LIST-OF-TERMS
;     (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFVAR MAP-ATOMS-FIRST ...)
; compiling (DEFUN MAP-ATOMS-IN-LIST-OF-WFFS ...)
; compiling (DEFUN MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT
;     (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:LCONS (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
;                       (SNARK::MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT
;                        SNARK::CC SNARK::HEAD-IF-ASSOCIATIVE (REST SNARK::TERMS)
;                        SUBST SNARK::POLARITY)
;                       SNARK::TERMS)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G212 #:G214)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G211 #:G213)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G211 #:G213)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS
;      (SNARK::MAP-TERMS-IN-TERM-AND-COMPOSE-RESULT SNARK::CC SNARK::TERM SUBST
;                                                   SNARK::POLARITY)
;      (SNARK::MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT SNARK::CC
;                                                            SNARK::HEAD-IF-ASSOCIATIVE
;                                                            (REST SNARK::TERMS)
;                                                            SUBST SNARK::POLARITY)
;      SNARK::TERMS)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G216 #:G218)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G215 #:G217)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G215 #:G217)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS (FUNCALL SNARK::CC SNARK::TERM SNARK::POLARITY)
;                       (SNARK::MAP-TERMS-IN-LIST-OF-TERMS-AND-COMPOSE-RESULT
;                        SNARK::CC SNARK::HEAD-IF-ASSOCIATIVE (REST SNARK::TERMS)
;                        SUBST SNARK::POLARITY)
;                       SNARK::TERMS)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G220 #:G222)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G219 #:G221)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G219 #:G221)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-ATOMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-ATOMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT
;     (SNARK-LISP:LCONS SNARK::X*
;                       (SNARK::MAP-ATOMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT
;                        SNARK::CC (REST SNARK::WFFS) (REST SNARK::POLARITY-MAP)
;                        SNARK::POLARITY)
;                       SNARK::WFFS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G245 #:G247)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G245 #:G247)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-ATOMS-IN-ALIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-ATOMS-IN-ALIST-OF-WFFS-AND-COMPOSE-RESULT
;     (SNARK-LISP:LCONS (CAR SNARK::P)
;                       (SNARK::MAP-ATOMS-IN-WFF-AND-COMPOSE-RESULT SNARK::CC
;                                                                   (CDR SNARK::P)
;                                                                   SNARK::POLARITY)
;                       SNARK::P)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G271 #:G273)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-TERMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-TERMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT
;     (SNARK-LISP:LCONS
;      (SNARK::MAP-TERMS-IN-WFF-AND-COMPOSE-RESULT SNARK::CC (FIRST SNARK::WFFS)
;                                                  SUBST SNARK::POLARITY)
;      (SNARK::MAP-TERMS-IN-LIST-OF-WFFS-AND-COMPOSE-RESULT SNARK::CC
;                                                           (REST SNARK::WFFS)
;                                                           SUBST SNARK::POLARITY)
;      SNARK::WFFS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G284 #:G286)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G284 #:G286)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-CONJUNCTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAP-CONJUNCTS
;     (FUNCALL SNARK::CC SNARK::WFF)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN REPLACE-ATOM-IN-WFF ...)
; compiling (DEFUN ATOMS-IN-WFF ...)
; compiling (DEFUN ATOMS-IN-WFFS ...)
; compiling (DEFUN ATOMS-IN-WFF2 ...)
; compiling (DEFUN ATOMS-IN-CLAUSE2 ...)
; compiling (DEFUN ATOMS-TO-CLAUSE2 ...)
; compiling (DEFUN ATOMS-IN-CLAUSE3 ...)
; compiling (DEFUN ATOMS-TO-CLAUSE3 ...)
; compiling (DEFUN LITERALS-IN-CLAUSE ...)
; compiling (DEFUN LITERALS-TO-CLAUSE ...)
; compiling (DEFUN FIRST-NEGATIVE-LITERAL-IN-WFF ...)
; compiling (DEFUN FIRST-POSITIVE-LITERAL-IN-WFF ...)
; compiling (DEFUN DO-NOT-RESOLVE ...)
; compiling (DEFUN DO-NOT-FACTOR ...)
; compiling (DEFUN WFF-POSITIVE-OR-NEGATIVE ...)
; compiling (DEFUN ATOM-SATISFIES-SEQUENTIAL-RESTRICTION-P ...)
; compiling (DEFUN TERM-SATISFIES-SEQUENTIAL-RESTRICTION-P ...)
; compiling (DEFUN SALSIFY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN SALSIFY
;     (FUNCALL SNARK::CONTINUATION SNARK::INTERPRETATION)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CONTINUATION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CONTINUATION
;              (CONS
;               (CONS SNARK::WFF
;                     (IF SNARK::SAT
;                         SNARK-LISP:TRUE
;                         SNARK-LISP:FALSE))
;               SNARK::INTERPRETATION))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CONTINUATION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CONTINUATION SNARK::INTERPRETATION)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CONTINUATION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PROPOSITIONAL-CONTRADICTION-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN PROPOSITIONAL-CONTRADICTION-P
;     (DEFUN SNARK::PROPOSITIONAL-CONTRADICTION-P (SNARK::WFF)
;       (SNARK::SALSIFY T SNARK::WFF NIL
;                       (LAMBDA (SNARK::I)
;                         (DECLARE (IGNORE SNARK::I))
;                         (RETURN-FROM SNARK::PROPOSITIONAL-CONTRADICTION-P NIL)))
;       T)
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::PROPOSITIONAL-CONTRADICTION-P
;     (SNARK::SALSIFY T SNARK::WFF NIL
;                     (LAMBDA (SNARK::I)
;                       (DECLARE (IGNORE SNARK::I))
;                       (RETURN-FROM SNARK::PROPOSITIONAL-CONTRADICTION-P NIL)))
;     T)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM PROPOSITIONAL-CONTRADICTION-P NIL). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN PROPOSITIONAL-TAUTOLOGY-P ...)
; compiling (DEFUN FLATTEN-TERM ...)
; compiling (DEFUN FLATTEN-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN FLATTEN-LIST
;     (SNARK-LISP:LCONS (SNARK::FLATTEN-TERM SNARK::TERM SUBST)
;                       (SNARK::FLATTEN-LIST (REST SNARK::TERMS) SUBST
;                                            SNARK::HEAD-IF-ASSOCIATIVE)
;                       SNARK::TERMS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G862 #:G864)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G862 #:G864)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN UNFLATTEN-TERM1 ...)
; compiling (DEFUN UNFLATTEN-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN UNFLATTEN-TERM
;     (SNARK-LISP:LCONS (SNARK::UNFLATTEN-TERM (FIRST SNARK::TERMS) SUBST)
;                       (SNARK::UNFLATTEN-LIST (REST SNARK::TERMS)) SNARK::TERMS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G922 #:G924)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G922 #:G924)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN FLATTEN-ARGS ...)
; compiling (DEFUN FN-CHAIN-TAIL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN FN-CHAIN-TAIL
;     (+ 1 SNARK::LEN)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN FN-CHAIN-ITEMS ...)
; compiling (DEFUN MAKE-FN-CHAIN ...)
; compiling (DEFUN MAKE-COMPOUND1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.lisp
; in: DEFUN MAKE-COMPOUND1
;     (EQL IDENTITY SNARK:ARG1)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL IDENTITY SNARK:ARG2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/wffs.fasl written
; compilation finished in 0:00:00.361
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/nonhorn-magic-set.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-MAGIC-GOAL-ATOM ...)
; compiling (DEFUN MAGIC-TRANSFORM-CLAUSE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/nonhorn-magic-set.lisp
; in: DEFUN MAGIC-TRANSFORM-CLAUSE
;     (FUNCALL SNARK::CC (FIRST SNARK::POSATOMS))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK::DISJOIN* (APPEND SNARK::L SNARK::POSATOMS)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC
;              (SNARK::DISJOIN*
;               (APPEND SNARK::L (LIST (SNARK::MAKE-MAGIC-GOAL-ATOM ATOM)))))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAGIC-TRANSFORM-WFF ...)
; compiling (DEFUN PROPOSITION-MAGIC-GOAL-P ...)
; compiling (DEFUN RELATION-MAGIC-GOAL-P ...)
; compiling (DEFUN MAGIC-GOAL-ATOM-P ...)
; compiling (DEFUN MAGIC-GOAL-OCCURS-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/nonhorn-magic-set.fasl written
; compilation finished in 0:00:00.025
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL MAP-ATOMS-FIRST ...))
; compiling (DEFSTRUCT (CONTEXT # ...) ...)
; compiling (DEFUN MAKE-CONTEXT2 ...)
; compiling (DEFUN DP-REFUTE-P ...)
; compiling (DEFUN DP-REFUTE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN DP-REFUTE
;     (FUNCALL SNARK::CC (SNARK::CONTEXT-SUBSTITUTION SNARK::CONTEXT))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DP-REFUTE-TRACE ...)
; compiling (DEFUN CHOOSE-ATOM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN CHOOSE-ATOM
;     (FUNCALL SNARK::CC ATOM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN REFUTE-METHODS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN REFUTE-METHODS
;     (FUNCALL SNARK::CC `(SNARK::SPLIT ,ATOM ,SNARK-LISP:TRUE))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC
;              `(SNARK::CLOSE-BRANCH-AND-REFUTE-OTHER-BRANCH ,ATOM ,SNARK::VALUE
;                ,SNARK::SUBSTITUTION2))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SIMPLIFY-FORMULA ...)
; compiling (DEFUN PRINT-CONTEXT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN PRINT-CONTEXT
;     (FORMAT STREAM "#<context formula: ")
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (WRITE-STRING "#<context formula: " STREAM))
;             NIL))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (MEMBER T NIL) STREAM (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING), not a NULL.

;     (FORMAT STREAM "; assignment: ")
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (WRITE-STRING "; assignment: " STREAM))
;             NIL))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a NULL.

;     (FORMAT STREAM "; substitution: ")
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (WRITE-STRING "; substitution: " STREAM))
;             NIL))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a NULL.

;     (FORMAT STREAM ">")
; ==>
;   (FORMAT SB-C::DEST
;           (LAMBDA (STREAM &REST SB-FORMAT::ARGS)
;             (DECLARE (IGNORABLE STREAM SB-FORMAT::ARGS))
;             (BLOCK NIL (WRITE-STRING ">" STREAM))
;             NIL))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a STREAM.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a (MEMBER T).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR STREAM (MEMBER T NIL)), not a NULL.

; compiling (DEFUN DP-SUBSUME* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN DP-SUBSUME*
;     (> SNARK::MAX1 SNARK::MIN2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (> SNARK::MAX1 SNARK::MIN2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN DP-SUBSUME-CONSTRAINT-ALISTS* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN DP-SUBSUME-CONSTRAINT-ALISTS*
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSOC (CAR SNARK::X) SNARK::CONSTRAINT-ALIST2)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN DP-SUBSUME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.lisp
; in: DEFUN DP-SUBSUME
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DP-SUBSUME+ ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/dp-refute.fasl written
; compilation finished in 0:00:00.057
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN ASA-ARG-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.lisp
; in: DEFUN ASA-ARG-SORT
;     (EQL SNARK::ARGID SNARK::KEY)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN INPUT-ARGUMENT-SORT-ALIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.lisp
; in: DEFUN INPUT-ARGUMENT-SORT-ALIST
;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN CAN-BE-ARGUMENT-SORT-ALIST-P1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.lisp
; in: DEFUN CAN-BE-ARGUMENT-SORT-ALIST-P1
;     (<= 1 SNARK::X SNARK::ARITY)
; --> 
; --> (LAMBDA (#:G54 #:G53 #:G52) (DECLARE (TYPE REAL #:G54 #:G53 #:G52)) (IF (<= #:G54 #:G53) (IF (<= #:G53 #:G52) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (#:G54 #:G53 #:G52) (DECLARE (TYPE REAL #:G54 #:G53 #:G52)) (IF (<= #:G54 #:G53) (IF (<= #:G53 #:G52) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF <= >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (#:G54 #:G53 #:G52) (DECLARE (TYPE REAL #:G54 #:G53 #:G52)) (IF (<= #:G54 #:G53) (IF (<= #:G53 #:G52) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; compiling (DEFUN CAN-BE-ARGUMENT-SORT-ALIST-P2 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-functions.fasl written
; compilation finished in 0:00:00.020
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TOP-SORT*)
; compiling (DEFINLINE TOP-SORT-NAME ...)
; compiling (DEFUN TOP-SORT-NAME? ...)
; compiling (DEFUN INITIALIZE-SORT-THEORY ...)
; compiling (DEFUN PRINT-SORT-THEORY ...)
; compiling (DEFINLINE TOP-SORT ...)
; compiling (DEFINLINE SAME-SORT? ...)
; compiling (DEFINLINE TOP-SORT? ...)
; compiling (DEFUN SUBSORT0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN SUBSORT0
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:FEATURE-SUBSUMES? SNARK::Y SNARK::X))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFINLINE SUBSORT? ...)
; compiling (DEFINLINE SUBSORT1? ...)
; compiling (DEFUN SORT-INTERSECTION0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN SORT-INTERSECTION0
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:FEATURE-UNION SNARK::X SNARK::Y))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFINLINE SORT-INTERSECTION ...)
; compiling (DEFINLINE SORT-DISJOINT? ...)
; compiling (DEFUN SORT? ...)
; compiling (DEFUN SORT-NAME ...)
; compiling (DEFUN SORT-NAME? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN SORT-NAME?
;     (FUNCALL SNARK::ACTION "There is no sort named ~S." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SORT-NAME-EXPRESSION? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN SORT-NAME-EXPRESSION?
;     (FUNCALL SNARK::ACTION "~S is not a sort expression." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN FIX-SORT-NAME-EXPRESSION ...)
; compiling (DEFUN THE-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN THE-SORT
;     (FUNCALL SNARK::ACTION "~S has not been declared as a sort." SNARK::SORT-EXPR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN DECLARE-SORT1 ...)
; compiling (DEFUN DECLARE-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN DECLARE-SORT
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :IFF
;                                      (SNARK:THE-SORT SNARK-LISP:IFF)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :PARENT
;                                      (SNARK:THE-SORT (SNARK:DECLARE-ROOT-SORT?))
;                                      :CHILDREN-INCOMPATIBLE
;                                      SNARK::SUBSORTS-INCOMPATIBLE))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :IFF
;                                      (SNARK:THE-SORT SNARK-LISP:IFF)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :PARENT
;                                      (SNARK:THE-SORT (SNARK:DECLARE-ROOT-SORT?))
;                                      :CHILDREN-INCOMPATIBLE
;                                      SNARK::SUBSORTS-INCOMPATIBLE))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :IFF
;                                      (SNARK:THE-SORT SNARK-LISP:IFF)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :PARENT
;                                      (SNARK:THE-SORT (SNARK:DECLARE-ROOT-SORT?))
;                                      :CHILDREN-INCOMPATIBLE
;                                      SNARK::SUBSORTS-INCOMPATIBLE))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN DECLARE-SUBSORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN DECLARE-SUBSORT
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (SNARK-FEATURE:DECLARE-FEATURE SNARK:SORT-NAME :IMPLIES
;                                      (SNARK:THE-SORT SNARK::SUPERSORT-EXPR)
;                                      :CHILDREN-INCOMPATIBLE
;                                      SNARK::SUBSORTS-INCOMPATIBLE))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN DECLARE-SORTS-INCOMPATIBLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.lisp
; in: DEFUN DECLARE-SORTS-INCOMPATIBLE
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SORTAL-REASONING
;       (APPLY 'SNARK-FEATURE:DECLARE-FEATURES-INCOMPATIBLE SNARK::SORT-NAME1
;              SNARK::SORT-NAME2 SNARK::MORE-SORT-NAMES))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SORTAL-REASONING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts-interface.fasl written
; compilation finished in 0:00:00.095
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-THE-SORT-FUNCTION-SYMBOL ...)
; compiling (DEFUN DECLARE-CONSTANT-SORT ...)
; compiling (DEFUN DECLARE-FUNCTION-SORT ...)
; compiling (DEFVAR *%CHECK-FOR-WELL-SORTED-ATOM%* ...)
; compiling (DEFUN CHECK-FOR-WELL-SORTED-ATOM ...)
; compiling (DEFUN ASSERT-ATOM-IS-WELL-SORTED ...)
; compiling (DEFUN CHECK-WELL-SORTED ...)
; compiling (DEFVAR *%CHECKING-WELL-SORTED-P%* ...)
; compiling (DEFUN WELL-SORTED-P ...)
; compiling (DEFUN WELL-SORTED-ARGS-P ...)
; compiling (DEFUN TERM-SORT ...)
; compiling (DEFUN COMPOUND-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN COMPOUND-SORT
;     (FUNCALL SNARK::FUN SNARK::TERM SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN WELL-SORT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC
;              (SNARK::BIND-VARIABLE-TO-TERM SNARK::X (SNARK::MAKE-VARIABLE SORT)
;                                            SUBST))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN WELL-SORT-ARGS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-ARGS
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF SNARK::ARGCOUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::ARGCOUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF SNARK::ARGCOUNT)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::ARGCOUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN WELL-SORT-ATOMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-ATOMS
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN WELL-SORT-ATOMS1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-ATOMS1
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN WELL-SORT-WHICH-ATOMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-WHICH-ATOMS
;     (SNARK-LISP:PROG->
;       (DELETE-IF SNARK::ATOMS SNARK::->* ATOM)
;       (COND ((SNARK::WELL-SORTED-P ATOM SUBST) T)
;             ((EQ :TERMS (SNARK:USE-WELL-SORTING?)) (COND (# # T) (T # NIL)))
;             (T
;              (WARN "Atomic formula ~A is not well sorted."
;                    (SNARK:TERM-TO-LISP ATOM SUBST))
;              NIL)))
; --> BLOCK FLET 
; ==>
;   (DELETE-IF #'#:G214 SNARK::ATOMS)
; 
; note: unable to open code due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

; compiling (DEFUN WELL-SORT-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-WFF
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN WELL-SORT-WFFS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.lisp
; in: DEFUN WELL-SORT-WFFS
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN REPLACE-SKOLEM-TERMS-BY-VARIABLES-IN-ATOMS ...)
; compiling (DEFUN FIX-SKOLEM-TERM-SORTS ...)
; compiling (DEFINLINE CONSTANT-SORT-P ...)
; compiling (DEFINLINE VARIABLE-SORT-P ...)
; compiling (DEFUN TERM-SORT-P ...)
; compiling (DEFUN TERM-SUBSORT-P ...)
; compiling (DEFUN SORT-COMPATIBLE-P ...)
; compiling (DEFUN CHECK-ASSOCIATIVE-FUNCTION-SORT ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/sorts.fasl written
; compilation finished in 0:00:00.095
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO INC-ARGUMENT-COUNT ...)
; compiling (DEFMACRO COUNT-ARGUMENT ...)
; compiling (DEFUN COUNT-ARGUMENTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.lisp
; in: DEFUN COUNT-ARGUMENTS
;     (SNARK::COUNT-ARGUMENT SNARK::FN SNARK::ARG SNARK::COUNTS SNARK::INC
;                            SNARK::COUNT-ARGUMENTS
;                            (PUSH (SNARK::MAKE-TC SNARK::ARG SNARK::INC)
;                                  SNARK::COUNTS)
;                            SNARK::CANCEL)
; --> SNARK:DEREFERENCE COND IF PROGN SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK 
; --> LET TAGBODY UNLESS IF PROGN LET TAGBODY LET UNLESS IF WHEN IF PROGN 
; --> UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF PROGN SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK 
; --> LET TAGBODY UNLESS IF PROGN LET TAGBODY LET UNLESS IF WHEN IF PROGN 
; --> UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> SNARK:DEREFERENCE COND IF PROGN SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK 
; --> LET TAGBODY UNLESS IF PROGN LET TAGBODY LET UNLESS IF WHEN IF PROGN SETF 
; --> LET* 
; ==>
;   (+ #:G236 SNARK::INC)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF PROGN SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK 
; --> LET TAGBODY UNLESS IF PROGN LET TAGBODY LET UNLESS IF WHEN IF PROGN 
; --> UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; --> SNARK:DEREFERENCE COND IF PROGN SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK 
; --> LET TAGBODY UNLESS IF PROGN LET TAGBODY LET UNLESS IF WHEN IF PROGN 
; --> UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN SETF LET* 
; ==>
;   (+ #:G252 SNARK::INC)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF 
; ==>
;   (EQL SNARK::ARG (SNARK::TC-TERM #:G263))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN SETF LET* 
; ==>
;   (+ #:G262 SNARK::INC)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF MINUSP 
; ==>
;   (< SNARK::INC 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF PROGN UNLESS IF WHEN IF IF PLUSP 
; ==>
;   (> SNARK::INC 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; compiling (DEFUN RECOUNT-ARGUMENTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.lisp
; in: DEFUN RECOUNT-ARGUMENTS
;     (SNARK::COUNT-ARGUMENT SNARK::FN SNARK::TERM SNARK::NEW-TERMS-AND-COUNTS
;                            COUNT SNARK::COUNT-ARGUMENTS
;                            (PUSH (SNARK::MAKE-TC SNARK::TERM COUNT)
;                                  SNARK::NEW-TERMS-AND-COUNTS))
; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN 
; --> SNARK::INC-ARGUMENT-COUNT DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY LET UNLESS IF WHEN IF 
; ==>
;   (EQL SNARK::TERM (SNARK::TC-TERM #:G358))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN TERM-SIZE-DIFFERENCE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.lisp
; in: DEFUN TERM-SIZE-DIFFERENCE
;     (* COUNT (SNARK::SIZE SNARK::TERM SUBST))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK::N (* COUNT (SNARK::SIZE SNARK::TERM SUBST)))
; --> SETQ THE 
; ==>
;   (+ (* COUNT (SNARK::SIZE SNARK::TERM SUBST)) SNARK::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-bag-ac.fasl written
; compilation finished in 0:00:00.107
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN ARGUMENT-LIST-A1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.lisp
; in: DEFUN ARGUMENT-LIST-A1
;     (EQL IDENTITY SNARK::ARG*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN ARGUMENT-COUNT-A1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.lisp
; in: DEFUN ARGUMENT-COUNT-A1
;     (INCF SNARK::C)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::C)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::C
;           (SNARK::ARGUMENT-COUNT-A1 SNARK::FN (SNARK::ARGSA SNARK::ARG) SUBST
;                                     IDENTITY SNARK::DONT-COUNT-VARIABLES))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK::ARGUMENT-COUNT-A1 SNARK::FN (SNARK::ARGSA SNARK::ARG) SUBST IDENTITY
;                              SNARK::DONT-COUNT-VARIABLES)
;    SNARK::C)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK::C)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::C)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL IDENTITY SNARK::ARG)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (INCF SNARK::C)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::C)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN SIMILAR-ARGUMENT-LIST-AC1-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.lisp
; in: DEFUN SIMILAR-ARGUMENT-LIST-AC1-P
;     (INCF SNARK::NVARI)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NVARI)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NHEAD1)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NHEAD1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NAPPL)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NAPPL)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NCONST1)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NCONST1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NCONST)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NCONST)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NVARI)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NVARI)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::NHEAD1)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NHEAD1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::NAPPL)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NAPPL)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL IDENTITY SNARK::ARG)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::ARG SNARK::CONST1)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (INCF SNARK::NCONST1)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NCONST1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::NCONST)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NCONST)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DECF SNARK::NVARI)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DECF SNARK::NHEAD1)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DECF SNARK::NAPPL)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL IDENTITY SNARK::ARG)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::ARG SNARK::CONST1)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (DECF SNARK::NCONST1)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR NULL NUMBER), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DECF SNARK::NCONST)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN FLATARGS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/argument-list-a1.fasl written
; compilation finished in 0:00:00.059
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING*))
; compiling (DEFVAR *UNIFY-SPECIAL* ...)
; compiling (DEFSTRUCT SPECIAL-UNIFICATION-PROBLEM ...)
; compiling (DEFUN UNIFY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp
; in: DEFUN UNIFY
;     (PSETQ SNARK::TERM1 SNARK::TERM2
;            SNARK::TERM2 SNARK::TERM1)
; --> LET* 
; ==>
;   SNARK::TERM2
; 
; note: deleting unreachable code

; ==>
;   SNARK::TERM1
; 
; note: deleting unreachable code

;     (FUNCALL SNARK::FUN SNARK::CC SNARK::OTERM1 SNARK::OTERM2 SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC1 SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC1)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::TERM1 SNARK::TERM2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN UNIFY-P ...)
; compiling (DEFUN MIGHT-UNIFY-P ...)
; compiling (DEFUN UNIFIERS ...)
; compiling (DEFUN UNIFY-SPECIAL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp
; in: DEFUN UNIFY-SPECIAL
;     (SNARK-LISP:PROG->
;       (FIRST SNARK::SPECIAL-UNIFICATION-PROBLEMS SNARK::-> SNARK::X)
;       (REST SNARK::SPECIAL-UNIFICATION-PROBLEMS SNARK::-> SNARK::L)
;       (COND
;        ((NULL SNARK::L)
;         (DOLIST (SNARK::SPECIAL-UNIFICATION-PROBLEM-ALGORITHMS SNARK::X)
;          SNARK::->*
;          SNARK::FUN)
;         (FUNCALL SNARK::FUN (SNARK::SPECIAL-UNIFICATION-PROBLEM-TERM1 SNARK::X)
;                  (SNARK::SPECIAL-UNIFICATION-PROBLEM-TERM2 SNARK::X) SUBST
;                  SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        (T
;         (DOLIST (SNARK::SPECIAL-UNIFICATION-PROBLEM-ALGORITHMS SNARK::X)
;          SNARK::->*
;          SNARK::FUN)
;         (FUNCALL SNARK::FUN (SNARK::SPECIAL-UNIFICATION-PROBLEM-TERM1 SNARK::X)
;                  (SNARK::SPECIAL-UNIFICATION-PROBLEM-TERM2 SNARK::X) SUBST
;                  SNARK::->* SUBST)
;         (SNARK::UNIFY-SPECIAL SNARK::CC SNARK::L SUBST))))
; --> BLOCK LET LET COND IF PROGN DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY SNARK-LISP::UNNAMED-PROG-> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> BLOCK LET LET COND IF COND THE PROGN DOLIST BLOCK LET TAGBODY UNLESS IF 
; --> PROGN LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL 
; --> THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN COMMUTATIVE-UNIFY ...)
; compiling (DEFUN DONT-UNIFY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.lisp
; in: DEFUN DONT-UNIFY
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify.fasl written
; compilation finished in 0:00:00.100
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBMULTISETP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN SUBMULTISETP
;     (FUNCALL SNARK::TEST SNARK::X1 (CAR SNARK::Y))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::TEST (FUNCALL SNARK::KEY SNARK::X1)
;              (FUNCALL SNARK::KEY (CAR SNARK::L2)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::KEY SNARK::X1)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::KEY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::KEY (CAR SNARK::L2))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::KEY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::KEY SNARK::X1)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::KEY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::KEY (CAR SNARK::L2))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::KEY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::TEST SNARK::X1 (CAR SNARK::L2))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::X1 (CAR SNARK::Y))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL (FUNCALL SNARK::KEY SNARK::X1) (FUNCALL SNARK::KEY (CAR SNARK::L2)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::X1 (CAR SNARK::L2))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MULTISET-EQUAL ...)
; compiling (DEFVAR MAXX)
; compiling (DEFVAR MAXY)
; compiling (DEFMACRO CHECK-UNIFY-BAG-BASIS-SIZE ...)
; compiling (DEFMACRO A-COEF ...)
; compiling (DEFMACRO B-COEF ...)
; compiling (DEFMACRO X-TERM ...)
; compiling (DEFMACRO Y-TERM ...)
; compiling (DEFMACRO X-BIND ...)
; compiling (DEFMACRO Y-BIND ...)
; compiling (DEFMACRO XX-UNIFY-P ...)
; compiling (DEFMACRO YY-UNIFY-P ...)
; compiling (DEFMACRO XY-UNIFY-P ...)
; compiling (DEFMACRO X-TERM-GROUND-P ...)
; compiling (DEFMACRO Y-TERM-GROUND-P ...)
; compiling (DEFUN PRINT-UNIFY-BAG-BASIS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN PRINT-UNIFY-BAG-BASIS
;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS) (FORMAT T "~4d" (SNARK::A-COEF SNARK::I)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS) (FORMAT T "~4d" (SNARK::B-COEF SNARK::J)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (DOTIMES (SNARK::J SNARK::NYCOEFS)
;         (WHEN (CONSP (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J))
;           (INCF COUNT)
;           (SNARK::TERPRI-COMMENT)
;           (DOTIMES (SNARK::K SNARK::NXCOEFS) (FORMAT T "~4D" #))
;           (FORMAT T "   ")
;           (DOTIMES (SNARK::K SNARK::NYCOEFS) (FORMAT T "~4D" #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (WHEN (CONSP (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J))
;         (INCF COUNT)
;         (SNARK::TERPRI-COMMENT)
;         (DOTIMES (SNARK::K SNARK::NXCOEFS)
;           (FORMAT T "~4D"
;                   (IF #
;                       #
;                       0)))
;         (FORMAT T "   ")
;         (DOTIMES (SNARK::K SNARK::NYCOEFS)
;           (FORMAT T "~4D"
;                   (IF #
;                       #
;                       0)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::K SNARK::NXCOEFS)
;       (FORMAT T "~4D"
;               (IF (EQL SNARK::K SNARK::I)
;                   (CAR (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J))
;                   0)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a (INTEGER 1), not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::K SNARK::NYCOEFS)
;       (FORMAT T "~4D"
;               (IF (EQL SNARK::K SNARK::J)
;                   (CDR (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J))
;                   0)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a (INTEGER 1), not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (DOTIMES (SNARK::J SNARK::NYCOEFS)
;         (WHEN (CONSP (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J))
;           (INCF COUNT)
;           (SNARK::TERPRI-COMMENT)
;           (DOTIMES (SNARK::K SNARK::NXCOEFS) (FORMAT T "~4D" #))
;           (FORMAT T "   ")
;           (DOTIMES (SNARK::K SNARK::NYCOEFS) (FORMAT T "~4D" #)))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (FORMAT T "~4d" (SVREF (CAR SNARK::SOLN) SNARK::I)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (FORMAT T "~4d" (SVREF (CDR SNARK::SOLN) SNARK::J)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS) (FORMAT T "~4d" (SNARK::A-COEF SNARK::I)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::J SNARK::NYCOEFS) (FORMAT T "~4d" (SNARK::B-COEF SNARK::J)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (FORMAT T "~4d" (SVREF (CAR SNARK::SOLN) SNARK::I)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (FORMAT T "~4d" (SVREF (CDR SNARK::SOLN) SNARK::J)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

; compiling (DEFUN UNIFY-BAG-BASIS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-BAG-BASIS
;     (PLUSP (SVREF SNARK::XSOL SNARK::K))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::K) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (SVREF SNARK::YSOL SNARK::K))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::K) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (<= SNARK::VAL SNARK::MAXVAL)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (TRUNCATE SNARK::SUM SNARK::B-COEF.J)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (* SNARK::B-COEF.J SNARK::VAL)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

;     (COPY-SEQ SNARK::MAXY)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (MINUSP SNARK::SUM)
; ==>
;   (< SNARK::SUM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK::SUMA SNARK::SUMB)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK::MAXA SNARK::MAXB)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::SUMA SNARK::SUMB)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::MAXA SNARK::MAXB)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (*
;      (SETF (SVREF SNARK::MAXY SNARK::J)
;              (IF (SNARK::UNFROZEN-VARIABLE-P #)
;                  SNARK::MAXA
;                  1))
;      (SNARK::B-COEF SNARK::J))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (TRUNCATE SNARK::K (SNARK::A-COEF SNARK::I))
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The second argument is a REAL, not a INTEGER.

;     (TRUNCATE SNARK::K (SNARK::B-COEF SNARK::J))
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The second argument is a REAL, not a INTEGER.

;     (MOD (SNARK::B-COEF SNARK::J) (SNARK::A-COEF SNARK::I))
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (TRUNCATE (SNARK::B-COEF SNARK::J) (SNARK::A-COEF SNARK::I))
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (MOD (SNARK::A-COEF SNARK::I) (SNARK::B-COEF SNARK::J))
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (TRUNCATE (SNARK::A-COEF SNARK::I) (SNARK::B-COEF SNARK::J))
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::COEF SNARK::MAXB)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::COEF SNARK::MAXA)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ SNARK::I 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (< SNARK::I+1 SNARK::NXCOEFS)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (PLUSP SNARK::SUM)
; ==>
;   (> SNARK::SUM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::MAXVAL)
; ==>
;   (> SNARK::MAXVAL 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (>= SNARK::MAXY.J SNARK::N)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (PLUSP SNARK::MAXY.J)
; ==>
;   (> SNARK::MAXY.J 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (* (SNARK::B-COEF SNARK::J) SNARK::MAXY.J)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (COPY-SEQ SNARK::MAXY)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (COPY-SEQ SNARK::MAXX)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (< SNARK::I+1 SNARK::NXCOEFS)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (> SNARK::SUM SNARK::MAXSUM)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (* (SNARK::B-COEF SNARK::J) (- SNARK::MAXY.J SNARK::N-1))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (COPY-SEQ SNARK::MAXY)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;           WHEN (PLUSP (SVREF SNARK::XSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::I SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::XSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::XSOL SNARK::I)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;           WHEN (PLUSP (SVREF SNARK::YSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::J SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::YSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::YSOL SNARK::J)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::WITH SNARK::XSOL1 = (CAR SNARK::V)
;           SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::XSOL SNARK::I)
;                             (SVREF SNARK::XSOL1 SNARK::I)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= (SVREF SNARK::XSOL SNARK::I) (SVREF SNARK::XSOL1 SNARK::I))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::WITH SNARK::YSOL1 = (CDR SNARK::V)
;           SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::YSOL SNARK::J)
;                             (SVREF SNARK::YSOL1 SNARK::J)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= (SVREF SNARK::YSOL SNARK::J) (SVREF SNARK::YSOL1 SNARK::J))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK::SUM SNARK::MAXSUM)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK::MAXY.J SNARK::N)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::COEF = (SNARK::A-COEF
;                                                                                    SNARK::I)
;           DO (INCF SNARK::SUMA SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXA)
;                                               (SETF SNARK::MAXA SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::COEF = (SNARK::B-COEF
;                                                                                    SNARK::J)
;           DO (INCF SNARK::SUMB SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXB)
;                                               (SETF SNARK::MAXB SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK::MAXA 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK::MAXB 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (EQL SNARK::J+1 SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387893 4611686018427387904), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (<= SNARK::VAL SNARK::MAXVAL)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (* SNARK::B-COEF.J SNARK::VAL)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (EQL (* SNARK::B-COEF.J SNARK::VAL) SNARK::SUM)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       etc.

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;           WHEN (PLUSP (SVREF SNARK::XSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::XSOL SNARK::K))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::K) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::FOR SNARK::I SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::XSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::XSOL SNARK::I)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1 4611686018427387904), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;           WHEN (PLUSP (SVREF SNARK::YSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::YSOL SNARK::K))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::K) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::FOR SNARK::J SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::YSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::YSOL SNARK::J)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1 4611686018427387904), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::WITH SNARK::XSOL1 = (CAR SNARK::V)
;           SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::XSOL SNARK::I)
;                             (SVREF SNARK::XSOL1 SNARK::I)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (>= (SVREF SNARK::XSOL SNARK::I) (SVREF SNARK::XSOL1 SNARK::I))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (LOOP SNARK::WITH SNARK::YSOL1 = (CDR SNARK::V)
;           SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::YSOL SNARK::J)
;                             (SVREF SNARK::YSOL1 SNARK::J)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (>= (SVREF SNARK::YSOL SNARK::J) (SVREF SNARK::YSOL1 SNARK::J))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::VAL SNARK::MAXVAL)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (EQL SNARK::K SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387894), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (DECF SNARK::SUM SNARK::B-COEF.J)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MINUSP SNARK::SUM)
; ==>
;   (< SNARK::SUM 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (+ SNARK::VAL 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -4611686018427387894), not a FIXNUM.
;       The result is a (VALUES (INTEGER -4611686018427387893) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -4611686018427387894), not a FIXNUM.
;       The result is a (VALUES (INTEGER -4611686018427387893) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< SNARK::I+1 SNARK::NXCOEFS)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (PLUSP SNARK::SUM)
; ==>
;   (> SNARK::SUM 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (PLUSP SNARK::MAXVAL)
; ==>
;   (> SNARK::MAXVAL 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (INCF SNARK::SUM SNARK::A-COEF.I)
; --> SETQ THE 
; ==>
;   (+ SNARK::A-COEF.I SNARK::SUM)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (<= SNARK::SUM SNARK::MAXSUM)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (> SNARK::VAL SNARK::MAXVAL)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (EQL SNARK::K SNARK::NXCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387903), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::MAXY.J (SVREF SNARK::MAXY SNARK::J)))
;         (WHEN (AND (PLUSP SNARK::MAXY.J) (NOT #))
;           (DECF SNARK::MAXSUM (* # SNARK::MAXY.J))
;           (UNLESS SNARK::NEWMAXY (SETF #) (SETF #))
;           (SETF # 0))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (PLUSP SNARK::MAXY.J)
; ==>
;   (> SNARK::MAXY.J 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (* (SNARK::B-COEF SNARK::J) SNARK::MAXY.J)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DECF SNARK::MAXSUM (* (SNARK::B-COEF SNARK::J) SNARK::MAXY.J))
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::K 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -4611686018427387903), not a FIXNUM.
;       The result is a (VALUES (INTEGER -4611686018427387902) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -4611686018427387903), not a FIXNUM.
;       The result is a (VALUES (INTEGER -4611686018427387902) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::SIMPLE-SOLUTION.I.J
;              (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J)))
;         (WHEN (CONSP SNARK::SIMPLE-SOLUTION.I.J)
;           (WHEN (EQL SNARK::VAL #)
;             (LET #
;               #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL SNARK::VAL (CAR SNARK::SIMPLE-SOLUTION.I.J))
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (>= SNARK::MAXY.J SNARK::N)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (- SNARK::N 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK::MAXY.J SNARK::N-1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* (SNARK::B-COEF SNARK::J) (- SNARK::MAXY.J SNARK::N-1))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DECF SNARK::MAXSUM (* (SNARK::B-COEF SNARK::J) (- SNARK::MAXY.J SNARK::N-1)))
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< SNARK::I+1 SNARK::NXCOEFS)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (INCF SNARK::SUM SNARK::A-COEF.I)
; --> SETQ THE 
; ==>
;   (+ SNARK::A-COEF.I SNARK::SUM)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::SUM SNARK::MAXSUM)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (+ SNARK::VAL 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::COEF = (SNARK::A-COEF
;                                                                                    SNARK::I)
;           DO (INCF SNARK::SUMA SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXA)
;                                               (SETF SNARK::MAXA SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (INCF SNARK::SUMA SNARK::COEF)
; --> SETQ THE 
; ==>
;   (+ SNARK::COEF SNARK::SUMA)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::COEF SNARK::MAXA)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::COEF = (SNARK::B-COEF
;                                                                                    SNARK::J)
;           DO (INCF SNARK::SUMB SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXB)
;                                               (SETF SNARK::MAXB SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (INCF SNARK::SUMB SNARK::COEF)
; --> SETQ THE 
; ==>
;   (+ SNARK::COEF SNARK::SUMB)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::COEF SNARK::MAXB)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK::SUMA SNARK::SUMB)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK::MAXA SNARK::MAXB)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::SUMA SNARK::SUMB)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (> SNARK::MAXA SNARK::MAXB)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET* ((SNARK::X-TERM.I (SNARK::X-TERM SNARK::I))
;              (SNARK::X-TERM.I-GROUND (OR SNARK::ALL-X-TERM-GROUND #)))
;         (DOTIMES (SNARK::J SNARK::NYCOEFS)
;           (LET (#)
;             (SETF #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::Y-TERM.J (SNARK::Y-TERM SNARK::J)))
;         (SETF (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (COND # # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (UNLESS
;           (AND (SNARK-LISP:NEQ SNARK-LISP:NONE IDENTITY)
;                (NOT (OR SNARK::ALL-X-TERM-GROUND #))
;                (SNARK::UNIFY-P (SNARK::X-TERM SNARK::I) IDENTITY SUBST))
;         (DOTIMES
;             (SNARK::J SNARK::NYCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;           (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a (INTEGER * 4611686018427387904), not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;       (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (UNLESS
;           (AND (SNARK-LISP:NEQ SNARK-LISP:NONE IDENTITY)
;                (NOT (OR SNARK::ALL-X-TERM-GROUND #))
;                (SNARK::UNIFY-P (SNARK::X-TERM SNARK::I) IDENTITY SUBST))
;         (DOTIMES
;             (SNARK::J SNARK::NYCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;           (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (UNLESS
;           (AND (SNARK-LISP:NEQ SNARK-LISP:NONE IDENTITY)
;                (NOT (OR SNARK::ALL-Y-TERM-GROUND #))
;                (SNARK::UNIFY-P (SNARK::Y-TERM SNARK::J) IDENTITY SUBST))
;         (DOTIMES
;             (SNARK::I SNARK::NXCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;           (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;       (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (UNLESS
;           (AND (SNARK-LISP:NEQ SNARK-LISP:NONE IDENTITY)
;                (NOT (OR SNARK::ALL-Y-TERM-GROUND #))
;                (SNARK::UNIFY-P (SNARK::Y-TERM SNARK::J) IDENTITY SUBST))
;         (DOTIMES
;             (SNARK::I SNARK::NXCOEFS (THROW 'SNARK::UNIFY-BAG-BASIS-QUIT NIL))
;           (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J) (RETURN NIL)))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::J 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (>= SNARK::NXCOEFS SNARK::NYCOEFS)
; --> IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (- SNARK::NXCOEFS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::I (- SNARK::NXCOEFS 1))
;       (DO* ((SNARK::X-TERM.I (SNARK::X-TERM SNARK::I))
;             (SNARK::X-TERM.I-GROUND (SNARK::X-TERM-GROUND-P SNARK::I))
;             (SNARK::K (+ SNARK::I 1) (+ SNARK::K 1)))
;            ((EQL SNARK::K SNARK::NXCOEFS))
;         (LET ((SNARK::X-TERM.K #))
;           (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL SNARK::K SNARK::NXCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1 4611686018427387904), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (- SNARK::NYCOEFS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK::J (- SNARK::NYCOEFS 1))
;       (DO* ((SNARK::Y-TERM.J (SNARK::Y-TERM SNARK::J))
;             (SNARK::Y-TERM.J-GROUND (SNARK::Y-TERM-GROUND-P SNARK::J))
;             (SNARK::K (+ SNARK::J 1) (+ SNARK::K 1)))
;            ((EQL SNARK::K SNARK::NYCOEFS))
;         (LET ((SNARK::Y-TERM.K #))
;           (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (EQL SNARK::K SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER 1 4611686018427387904), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (COND
;        ((SNARK::UNFROZEN-VARIABLE-P (SNARK::X-TERM SNARK::I))
;         (DOTIMES (SNARK::J SNARK::NYCOEFS) (WHEN # #)))
;        (T (DOTIMES (SNARK::J SNARK::NYCOEFS) (WHEN # #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J)
;         (COND
;          ((SNARK::UNFROZEN-VARIABLE-P #) (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
;           (LET #
;             #))
;          ((EQL 0 #) (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE) (SETF #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (MOD (SNARK::B-COEF SNARK::J) (SNARK::A-COEF SNARK::I))
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (WHEN (SNARK::XY-UNIFY-P SNARK::I SNARK::J)
;         (COND ((SNARK::UNFROZEN-VARIABLE-P #) (COND #))
;               ((EQL # #) (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE) (SETF #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (MOD (SNARK::A-COEF SNARK::I) (SNARK::B-COEF SNARK::J))
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (EQL (SNARK::A-COEF SNARK::I) (SNARK::B-COEF SNARK::J))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::CHECK-UNIFY-BAG-BASIS-SIZE)
; --> WHEN IF < INCF SETQ THE 
; ==>
;   (+ 1 SNARK::UNIFY-BAG-BASIS-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> WHEN IF 
; ==>
;   (< (SNARK:UNIFY-BAG-BASIS-SIZE-LIMIT?) (INCF SNARK::UNIFY-BAG-BASIS-SIZE))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (<= SNARK::MAXA 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (<= SNARK::MAXB 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (*
;      (SETF (SVREF SNARK::MAXY SNARK::J)
;              (IF (SNARK::UNFROZEN-VARIABLE-P #)
;                  SNARK::MAXA
;                  1))
;      (SNARK::B-COEF SNARK::J))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       etc.

;     (INCF SNARK::INITIAL-MAXSUM
;           (*
;            (SETF (SVREF SNARK::MAXY SNARK::J)
;                    (IF #
;                        SNARK::MAXA
;                        1))
;            (SNARK::B-COEF SNARK::J)))
; --> SETQ THE 
; ==>
;   (+
;    (*
;     (SETF (SVREF SNARK::MAXY SNARK::J)
;             (IF #
;                 SNARK::MAXA
;                 1))
;     (SNARK::B-COEF SNARK::J))
;    SNARK::INITIAL-MAXSUM)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a (OR NULL NUMBER), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a (OR NULL NUMBER), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::COEF = (SNARK::A-COEF
;                                                                                    SNARK::I)
;           DO (INCF SNARK::SUMA SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXA)
;                                               (SETF SNARK::MAXA SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::COEF = (SNARK::B-COEF
;                                                                                    SNARK::J)
;           DO (INCF SNARK::SUMB SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXB)
;                                               (SETF SNARK::MAXB SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET* ((SNARK::X-TERM.I (SNARK::X-TERM SNARK::I))
;              (SNARK::X-TERM.I-GROUND (OR SNARK::ALL-X-TERM-GROUND #)))
;         (DOTIMES (SNARK::J SNARK::NYCOEFS)
;           (LET (#)
;             (SETF #)))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (COND
;        ((SNARK::UNFROZEN-VARIABLE-P (SNARK::X-TERM SNARK::I))
;         (DOTIMES (SNARK::J SNARK::NYCOEFS) (WHEN # #)))
;        (T (DOTIMES (SNARK::J SNARK::NYCOEFS) (WHEN # #)))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN 
; ==>
;   (SETQ SNARK::I (1+ SNARK::I))
; 
; note: doing signed word to integer coercion (cost 20) to I

;     (EQL SNARK::K SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of %EQL/INTEGER

;     (DOTIMES (SNARK::J (- SNARK::NYCOEFS 1))
;       (DO* ((SNARK::Y-TERM.J (SNARK::Y-TERM SNARK::J))
;             (SNARK::Y-TERM.J-GROUND (SNARK::Y-TERM-GROUND-P SNARK::J))
;             (SNARK::K (+ SNARK::J 1) (+ SNARK::K 1)))
;            ((EQL SNARK::K SNARK::NYCOEFS))
;         (LET ((SNARK::Y-TERM.K #))
;           (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (EQL SNARK::K SNARK::NXCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of %EQL/INTEGER

;     (DOTIMES (SNARK::I (- SNARK::NXCOEFS 1))
;       (DO* ((SNARK::X-TERM.I (SNARK::X-TERM SNARK::I))
;             (SNARK::X-TERM.I-GROUND (SNARK::X-TERM-GROUND-P SNARK::I))
;             (SNARK::K (+ SNARK::I 1) (+ SNARK::K 1)))
;            ((EQL SNARK::K SNARK::NXCOEFS))
;         (LET ((SNARK::X-TERM.K #))
;           (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::COEF = (SNARK::B-COEF
;                                                                                    SNARK::J)
;           DO (INCF SNARK::SUMB SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXB)
;                                               (SETF SNARK::MAXB SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::COEF = (SNARK::A-COEF
;                                                                                    SNARK::I)
;           DO (INCF SNARK::SUMA SNARK::COEF) (WHEN (> SNARK::COEF SNARK::MAXA)
;                                               (SETF SNARK::MAXA SNARK::COEF)) ...)
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

;     (EQL SNARK::J+1 SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of %EQL/INTEGER

;     (DO ((SNARK::K (+ SNARK::J 1) (+ SNARK::K 1)))
;         ((EQL SNARK::K SNARK::NYCOEFS))
;       (WHEN
;           (OR SNARK::ALL-Y-TERM-GROUND
;               (NOT (SNARK::YY-UNIFY-P SNARK::J SNARK::K)))
;         (UNLESS SNARK::NEWMAXY (SETF SNARK::MAXY #) (SETF SNARK::NEWMAXY T))
;         (SETF (SVREF SNARK::MAXY SNARK::K) 0)))
; --> BLOCK 
; ==>
;   (LET ((SNARK::K (+ SNARK::J 1)))
;     (TAGBODY
;       (GO #:G690)
;      #:G689
;       (TAGBODY
;         (WHEN (OR SNARK::ALL-Y-TERM-GROUND #)
;           (UNLESS SNARK::NEWMAXY # #)
;           (SETF #)))
;       (PSETQ SNARK::K (+ SNARK::K 1))
;      #:G690
;       (UNLESS (EQL SNARK::K SNARK::NYCOEFS) (GO #:G689))
;       (RETURN-FROM NIL (PROGN))))
; 
; note: doing signed word to integer coercion (cost 20) to K

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;           WHEN (PLUSP (SVREF SNARK::XSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::I SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::XSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::XSOL SNARK::I)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;           WHEN (PLUSP (SVREF SNARK::YSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::J SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::YSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::YSOL SNARK::J)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::WITH SNARK::XSOL1 = (CAR SNARK::V)
;           SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::XSOL SNARK::I)
;                             (SVREF SNARK::XSOL1 SNARK::I)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::WITH SNARK::YSOL1 = (CDR SNARK::V)
;           SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::YSOL SNARK::J)
;                             (SVREF SNARK::YSOL1 SNARK::J)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::WITH SNARK::XSOL1 = (CAR SNARK::V)
;           SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::ALWAYS (>= (SVREF SNARK::XSOL SNARK::I)
;                             (SVREF SNARK::XSOL1 SNARK::I)))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::J SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::YSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::YSOL SNARK::J)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NYCOEFS
;           WHEN (PLUSP (SVREF SNARK::YSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::I SNARK::FROM (+ 1
;                                              (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;                                                    WHEN (PLUSP
;                                                          (SVREF SNARK::XSOL
;                                                                 SNARK::K)) RETURN SNARK::K
;                                                    SNARK::FINALLY (ERROR
;                                                                    "Loop should have terminated"))) SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (PLUSP (SVREF SNARK::XSOL SNARK::I)))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::K SNARK::BELOW SNARK::NXCOEFS
;           WHEN (PLUSP (SVREF SNARK::XSOL SNARK::K)) RETURN SNARK::K
;           SNARK::FINALLY (ERROR "Loop should have terminated"))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from K, for:
;       the first argument of GENERIC->

;     (DO ((SNARK::K (+ SNARK::I 1) (+ SNARK::K 1)))
;         ((EQL SNARK::K SNARK::NXCOEFS))
;       (WHEN
;           (OR SNARK::ALL-X-TERM-GROUND
;               (NOT (SNARK::XX-UNIFY-P SNARK::I SNARK::K)))
;         (UNLESS SNARK::NEWMAXX (SETF SNARK::MAXX #) (SETF SNARK::NEWMAXX T))
;         (SETF (SVREF SNARK::MAXX SNARK::K) 0)))
; --> BLOCK 
; ==>
;   (LET ((SNARK::K (+ SNARK::I 1)))
;     (TAGBODY
;       (GO #:G668)
;      #:G667
;       (TAGBODY
;         (WHEN (OR SNARK::ALL-X-TERM-GROUND #)
;           (UNLESS SNARK::NEWMAXX # #)
;           (SETF #)))
;       (PSETQ SNARK::K (+ SNARK::K 1))
;      #:G668
;       (UNLESS (EQL SNARK::K SNARK::NXCOEFS) (GO #:G667))
;       (RETURN-FROM NIL (PROGN))))
; 
; note: doing signed word to integer coercion (cost 20) to K

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::MAXY.J (SVREF SNARK::MAXY SNARK::J)))
;         (WHEN (AND (PLUSP SNARK::MAXY.J) (NOT #))
;           (DECF SNARK::MAXSUM (* # SNARK::MAXY.J))
;           (UNLESS SNARK::NEWMAXY (SETF #) (SETF #))
;           (SETF # 0))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

; compiling (DECLARE-SNARK-OPTION USE-SUBSUME-BAG ...)
; compiling (DEFUN AC-UNIFY ...)
; compiling (DEFUN UNIFY-BAG ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-BAG
;     (/ (- (GET-INTERNAL-RUN-TIME) SNARK::START-TIME)
;        (FLOAT INTERNAL-TIME-UNITS-PER-SECOND))
; ==>
;   (/ (FLOAT SB-C::X SB-C::Y) SB-C::Y)
; 
; note: unable to convert to multiplication by reciprocal because: 1000.0 does not have an exact reciprocal

;     (<= (SNARK:METER-UNIFY-BAG?) SNARK::ELAPSED-TIME)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN UNIFY-BAG* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-BAG*
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF SNARK::NXCOEFS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NXCOEFS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NYCOEFS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NYCOEFS)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NXCOEFS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NXCOEFS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::NYCOEFS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::NYCOEFS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:CONSN (SNARK::TC-TERM SNARK::TC) NIL (- COUNT))
; 
; note: doing signed word to integer coercion (cost 20)

;     (SETF SNARK::FIRSTB (- COUNT))
; ==>
;   (SETQ SNARK::FIRSTB (- COUNT))
; 
; note: doing signed word to integer coercion (cost 20) to FIRSTB

; compiling (DEFUN SORT-TERMS-AND-COUNTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN SORT-TERMS-AND-COUNTS
;     (STABLE-SORT SNARK::TERMS-AND-COUNTS
;                  (LAMBDA (SNARK::TC1 SNARK::TC2)
;                    (LET ((SNARK::X #) (SNARK::Y #))
;                      (SNARK:DEREFERENCE SNARK::X SUBST :IF-VARIABLE
;                                         (SNARK:DEREFERENCE SNARK::Y SUBST
;                                                            :IF-VARIABLE #)
;                                         :IF-CONSTANT
;                                         (SNARK:DEREFERENCE SNARK::Y SUBST
;                                                            :IF-VARIABLE #)
;                                         :IF-COMPOUND
;                                         (SNARK:DEREFERENCE SNARK::Y SUBST
;                                                            :IF-VARIABLE T
;                                                            :IF-CONSTANT T)))))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (OR VECTOR CONS NULL).

; compiling (DEFUN UNIFY-BAG0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-BAG0
;     (SETF (SNARK::B-COEF SNARK::J) (- (SNARK::TC-COUNT SNARK::TC)))
; --> SB-KERNEL:%SVSET LET TRULY-THE SB-KERNEL:DATA-VECTOR-SET 
; ==>
;   (SB-KERNEL:DATA-VECTOR-SET-WITH-OFFSET (THE SIMPLE-VECTOR #:N-VECTOR-1960)
;    (SB-KERNEL:%CHECK-BOUND #:N-VECTOR-1960 (LENGTH #:N-VECTOR-1960) SNARK::J) 0
;    (THE * (- (SNARK::TC-COUNT SNARK::TC))))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the third argument of DATA-VECTOR-SET-WITH-OFFSET/SIMPLE-VECTOR

; compiling (DEFMACRO NOSOL3X ...)
; compiling (DEFMACRO NOSOL3Y ...)
; compiling (DEFMACRO UNIFY-BAG2* ...)
; compiling (DEFUN UNIFY-BAG1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-BAG1
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (+ SNARK::I 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (AREF SNARK::SIMPLE-SOLUTION SNARK::I SNARK::J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (SNARK::UNIFY-BAG2* SNARK::COMPLEX-SOLUTIONS SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::YSOL.J = (SVREF
;                                                                                      SNARK::YSOL
;                                                                                      SNARK::J)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::YSOL.J)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::YSOL.J)
;                                 (SNARK::Y-BIND SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::XSOL.I = (SVREF
;                                                                                      SNARK::XSOL
;                                                                                      SNARK::I)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::XSOL.I)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::XSOL.I)
;                                 (SNARK::X-BIND SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> AREF LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to avoid runtime dispatch on array element type due to type uncertainty: The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::YSOL SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::UNIFY-BAG2* SNARK::COMPLEX-SOLUTIONS SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::XSOL.I = (SVREF
;                                                                                      SNARK::XSOL
;                                                                                      SNARK::I)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::XSOL.I)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::XSOL.I)
;                                 (SNARK::X-BIND SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::YSOL.J = (SVREF
;                                                                                      SNARK::YSOL
;                                                                                      SNARK::J)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::YSOL.J)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::YSOL.J)
;                                 (SNARK::Y-BIND SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::YSOL SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (WHEN
;           (AND (EQL 1 (SVREF SNARK::YSOL SNARK::J))
;                (NOT (SNARK::UNFROZEN-VARIABLE-P #)))
;         (RETURN (SNARK::Y-TERM SNARK::J))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (WHEN
;           (AND (EQL 1 (SVREF SNARK::XSOL SNARK::I))
;                (NOT (SNARK::UNFROZEN-VARIABLE-P #)))
;         (RETURN (SNARK::X-TERM SNARK::I))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET ((SNARK::XSOL.I (SVREF SNARK::XSOL SNARK::I)))
;         (UNLESS (EQL 0 SNARK::XSOL.I) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::YSOL.J (SVREF SNARK::YSOL SNARK::J)))
;         (UNLESS (EQL 0 SNARK::YSOL.J) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET ((SNARK::XSOL.I (SVREF SNARK::XSOL SNARK::I)))
;         (UNLESS (EQL 0 SNARK::XSOL.I) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::YSOL.J (SVREF SNARK::YSOL SNARK::J)))
;         (UNLESS (EQL 0 SNARK::YSOL.J) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (PLUSP (SVREF SNARK::XSOL SNARK::I))
; ==>
;   (> (SVREF SNARK::XSOL SNARK::I) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::YSOL SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (PLUSP (SVREF SNARK::YSOL SNARK::J))
; ==>
;   (> (SVREF SNARK::YSOL SNARK::J) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a INTEGER, not a FIXNUM.

;     (SNARK::UNIFY-BAG2* SNARK::COMPLEX-SOLUTIONS SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> SETQ THE SNARK::NOSOL3X AND IF AND IF AND THE LOOP BLOCK LET LET 
; --> SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a REAL, not a FIXNUM.

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF SETQ THE SNARK::NOSOL3Y AND IF AND IF AND THE LOOP BLOCK 
; --> LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (DOTIMES (SNARK::I SNARK::NCOEFS)
;       (FORMAT T "~% ~S & ~S" (SVREF SNARK::TERM SNARK::I)
;               (SNARK::MAKE-A1-COMPOUND* SNARK::FN IDENTITY
;                                         (SVREF SNARK::BIND SNARK::I))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4611686018427387905), not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (EQL SNARK::I+1 SNARK::NXCOEFS)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::NOSOL3X SNARK::J+1)
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (SNARK::NOSOL3Y (+ SNARK::I 1))
; --> AND IF AND IF AND THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN 
; --> IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (EQL SNARK::I+1 SNARK::NXCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387893 4611686018427387904), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (EQL SNARK::J+1 SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: forced to do %EQL/INTEGER (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (INTEGER -4611686018427387893 4611686018427387904), not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (SNARK::UNIFY-BAG2* SNARK::COMPLEX-SOLUTIONS SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::XSOL.I = (SVREF
;                                                                                      SNARK::XSOL
;                                                                                      SNARK::I)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::XSOL.I)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::XSOL.I)
;                                 (SNARK::X-BIND SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::YSOL.J = (SVREF
;                                                                                      SNARK::YSOL
;                                                                                      SNARK::J)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::YSOL.J)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::YSOL.J)
;                                 (SNARK::Y-BIND SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (WHEN
;           (AND (EQL 1 (SVREF SNARK::YSOL SNARK::J))
;                (NOT (SNARK::UNFROZEN-VARIABLE-P #)))
;         (RETURN (SNARK::Y-TERM SNARK::J))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET ((SNARK::XSOL.I (SVREF SNARK::XSOL SNARK::I)))
;         (UNLESS (EQL 0 SNARK::XSOL.I) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::YSOL.J (SVREF SNARK::YSOL SNARK::J)))
;         (UNLESS (EQL 0 SNARK::YSOL.J) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (LET ((SNARK::XSOL.I (SVREF SNARK::XSOL SNARK::I)))
;         (UNLESS (EQL 0 SNARK::XSOL.I) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::J SNARK::NYCOEFS)
;       (LET ((SNARK::YSOL.J (SVREF SNARK::YSOL SNARK::J)))
;         (UNLESS (EQL 0 SNARK::YSOL.J) (SETF # #))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::YSOL SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-<

;     (DOTIMES (SNARK::I SNARK::NXCOEFS)
;       (WHEN
;           (AND (EQL 1 (SVREF SNARK::XSOL SNARK::I))
;                (NOT (SNARK::UNFROZEN-VARIABLE-P #)))
;         (RETURN (SNARK::X-TERM SNARK::I))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::YSOL SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS
;           SNARK::NEVER (AND (PLUSP (SVREF SNARK::XSOL SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::J SNARK::BELOW SNARK::NYCOEFS SNARK::AS SNARK::YSOL.J = (SVREF
;                                                                                      SNARK::YSOL
;                                                                                      SNARK::J)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::YSOL.J)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::YSOL.J)
;                                 (SNARK::Y-BIND SNARK::J))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::Y-TERM SNARK::J)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (SNARK::UNIFY-BAG2* (CDR SNARK::COMPLEX-SOLNS) SUBST)
; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET LOOP BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC-=

; --> IF UNLESS IF OR LET IF OR THE LOOP BLOCK LET LET SB-LOOP::LOOP-BODY 
; --> TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from J, for:
;       the first argument of GENERIC->

;     (LOOP SNARK::FOR SNARK::I SNARK::BELOW SNARK::NXCOEFS SNARK::AS SNARK::XSOL.I = (SVREF
;                                                                                      SNARK::XSOL
;                                                                                      SNARK::I)
;           SNARK::NEVER (AND (SNARK-LISP:NEQL 0 SNARK::XSOL.I)
;                             (OR (SNARK-LISP:NEQL 1 SNARK::XSOL.I)
;                                 (SNARK::X-BIND SNARK::I))
;                             (NOT
;                              (SNARK::UNFROZEN-VARIABLE-P
;                               (SNARK::X-TERM SNARK::I)))))
; --> BLOCK LET LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC->

;     (EQL SNARK::J+1 SNARK::NYCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of %EQL/INTEGER

;     (SNARK-LISP:PROG->
;       (SNARK::Y-TERM SNARK::J SNARK::-> SNARK::Y-TERM.J)
;       (SNARK::Y-BIND SNARK::J SNARK::-> SNARK::Y-BIND.J)
;       (+ SNARK::J 1 SNARK::-> SNARK::J+1)
;       (COND ((EQL SNARK::J+1 SNARK::NYCOEFS) (COND (# #) (# #) (T #)))
;             (T (COND (# # #) (# #) (T # #)))))
; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF COND IF COND THE PROGN 
; --> FLET SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2426
;        :%DEBUG-NAME (FLET #:G2426 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB65B3}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF COND IF PROGN COND IF 
; --> COND THE PROGN FLET SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2425
;        :%DEBUG-NAME (FLET #:G2425 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB6833}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF PROGN FLET 
; --> SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2424
;        :%DEBUG-NAME (FLET #:G2424 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB6AB3}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

;     (EQL SNARK::I+1 SNARK::NXCOEFS)
; --> SB-KERNEL:%EQL/INTEGER IF 
; ==>
;   (SB-KERNEL:%EQL/INTEGER SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first argument of %EQL/INTEGER

;     (SNARK-LISP:PROG->
;       (SNARK::X-TERM SNARK::I SNARK::-> SNARK::X-TERM.I)
;       (SNARK::X-BIND SNARK::I SNARK::-> SNARK::X-BIND.I)
;       (+ SNARK::I 1 SNARK::-> SNARK::I+1)
;       (COND ((EQL SNARK::I+1 SNARK::NXCOEFS) (COND (# # #) (# #) (T # #)))
;             (T (COND (# # #) (# #) (T # #)))))
; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF COND IF COND THE PROGN 
; --> FLET SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2421
;        :%DEBUG-NAME (FLET #:G2421 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB6D33}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF COND IF PROGN COND IF 
; --> COND THE PROGN FLET SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2420
;        :%DEBUG-NAME (FLET #:G2420 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB6FB3}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

; --> BLOCK LET LET LET COND IF COND THE PROGN COND IF PROGN FLET 
; --> SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME #:G2419
;        :%DEBUG-NAME (FLET #:G2419 :IN SNARK::UNIFY-BAG1)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS (SUBST) {100DAB7233}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

;     (DOTIMES (SNARK::I SNARK::NCOEFS)
;       (FORMAT T "~% ~S & ~S" (SVREF SNARK::TERM SNARK::I)
;               (SNARK::MAKE-A1-COMPOUND* SNARK::FN IDENTITY
;                                         (SVREF SNARK::BIND SNARK::I))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing signed word to integer coercion (cost 20) from I, for:
;       the first argument of GENERIC-<

; compiling (DEFUN UNIFY-IDENTITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.lisp
; in: DEFUN UNIFY-IDENTITY
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-bag.fasl written
; compilation finished in 0:00:01.173
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN SUBSUME-BAG ...)
; compiling (DEFUN SUBSUME-BAG0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp
; in: DEFUN SUBSUME-BAG0
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (<= SNARK::LEN1 SNARK::LEN2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= (+ SNARK::LEN1 SNARK::VARC) SNARK::LEN2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (DECF SNARK::LEN2 SNARK::C)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).

;     (INCF SNARK::VARC SNARK::C)
; --> SETQ THE 
; ==>
;   (+ SNARK::C SNARK::VARC)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK::LEN1 SNARK::C)
; --> SETQ THE 
; ==>
;   (+ SNARK::C SNARK::LEN1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (<= SNARK::LEN1 SNARK::LEN2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (- SNARK::LEN2 SNARK::LEN1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::LEN1 SNARK::VARC)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (<= (+ SNARK::LEN1 SNARK::VARC) SNARK::LEN2)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (- SNARK::LEN2 SNARK::LEN1 SNARK::VARC)
; --> - 
; ==>
;   (- SNARK::LEN2 SNARK::LEN1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (- (- SNARK::LEN2 SNARK::LEN1) SNARK::VARC)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK::LEN1 SNARK::LEN2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SUBSUME-BAG1 ...)
; compiling (DEFUN SUBSUME-BAG2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp
; in: DEFUN SUBSUME-BAG2
;     (SETF SNARK::C (- SNARK::C))
; ==>
;   (SETQ SNARK::C (- SNARK::C))
; 
; note: doing signed word to integer coercion (cost 20) to C

; compiling (DEFUN SUBSUME-BAG3 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp
; in: DEFUN SUBSUME-BAG3
;     (LENGTH SNARK::VARS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN SUBSUME-BAG4 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp
; in: DEFUN SUBSUME-BAG4
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAXTC1 ...)
; compiling (DEFUN COMPUTE-BOUNDS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.lisp
; in: DEFUN COMPUTE-BOUNDS
;     (> SNARK::COEF SNARK::SUM)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-bag.fasl written
; compilation finished in 0:00:00.046
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN FIRST-AND-REST-OF-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp
; in: DEFUN FIRST-AND-REST-OF-VECTOR
;     (EQL IDENTITY SNARK::TERM)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN UNIFY-IDENTITY-WITH-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp
; in: DEFUN UNIFY-IDENTITY-WITH-VECTOR
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN UNIFY-VARIABLE-WITH-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp
; in: DEFUN UNIFY-VARIABLE-WITH-VECTOR
;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC
;              (SNARK::BIND-VARIABLE-TO-TERM SNARK:VAR
;                                            (SNARK:MAKE-COMPOUND* SNARK::FN
;                                                                  SNARK::L)
;                                            SUBST)
;              SNARK:ARGS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (<= 2 MAX)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= MAX COUNT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= 2 (INCF COUNT))
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= 2 MAX)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (>= MAX COUNT)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= 2 (INCF COUNT))
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFUN UNIFY-VARIABLE-WITH-VECTOR-MAX ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp
; in: DEFUN UNIFY-VARIABLE-WITH-VECTOR-MAX
;     (+ 1 (SNARK::ARGUMENT-COUNT-A1 SNARK::FN SNARK:ARGS SUBST IDENTITY))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- (+ 1 (SNARK::ARGUMENT-COUNT-A1 SNARK::FN SNARK:ARGS SUBST IDENTITY))
;        (SNARK::ARGUMENT-COUNT-A1 SNARK::FN SNARK::ARGS2 SUBST IDENTITY T))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ASSOCIATIVE-UNIFY ...)
; compiling (DEFUN UNIFY-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.lisp
; in: DEFUN UNIFY-VECTOR
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::FIRSTARGS1 SNARK::FIRSTARGS2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/unify-vector.fasl written
; compilation finished in 0:00:00.051
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUAL-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp
; in: DEFUN EQUAL-P
;     (FUNCALL SNARK::FUN SNARK::X SNARK::Y SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN AC-EQUAL-P ...)
; compiling (DEFUN COMMUTATIVE-EQUAL-P ...)
; compiling (DEFUN ASSOCIATIVE-EQUAL-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp
; in: DEFUN ASSOCIATIVE-EQUAL-P
;     (EQL (SNARK::ARGUMENT-COUNT-A1 SNARK::FN SNARK::TERMS1 SUBST)
;          (SNARK::ARGUMENT-COUNT-A1 SNARK::FN SNARK::TERMS2 SUBST))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MEMBER-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp
; in: DEFUN MEMBER-P
;     (MEMBER SNARK::ITEM LIST)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN ASSOC-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.lisp
; in: DEFUN ASSOC-P
;     (ASSOC SNARK::ITEM SNARK::ALIST)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN LITERAL-MEMBER-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/equal.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *EXTENDED-VARIANT* ...)
; compiling (DEFUN VARIANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.lisp
; in: DEFUN VARIANT
;     (SNARK::VARIANT1 SNARK::X SNARK::Y)
; --> LET ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; --> LET COND IF PROGN WHEN IF NULL IF RASSOC 
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::CC SNARK::MATCHES)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::FUN SNARK::CC SNARK::X SNARK::Y SUBST SNARK::MATCHES)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::VARIANT1 SNARK::X SNARK::Y)
; --> LET ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; --> LET COND IF PROGN WHEN IF NULL IF RASSOC 
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::CC SNARK::MATCHES)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN VARIANTL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.lisp
; in: DEFUN VARIANTL
;     (FUNCALL SNARK::CC SNARK::MATCHES)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN VARIANT-P ...)
; compiling (DEFUN VARIANT-BAG ...)
; compiling (DEFUN VARIANT-BAG0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.lisp
; in: DEFUN VARIANT-BAG0
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN VARIANT-BAG* ...)
; compiling (DEFUN VARIANT-COMMUTE ...)
; compiling (DEFUN VARIANT-VECTOR ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/variant.fasl written
; compilation finished in 0:00:00.065
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUAL-ALIST-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp
; in: DEFUN EQUAL-ALIST-P
;     (EQL (CAR (FIRST SNARK::P1)) (CAR (FIRST SNARK::P2)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN CONJOIN-ALISTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp
; in: DEFUN CONJOIN-ALISTS
;     (EQL SNARK::X1 (CAR SNARK::Y))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::Y1 (CAR SNARK::X))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN CONJOIN-ALIST1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp
; in: DEFUN CONJOIN-ALIST1
;     (EQL SNARK::KEY (CAR SNARK::P))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS (CAR SNARK::P) (SNARK::CONJOIN SNARK::VALUE (CDR SNARK::P))
;                       SNARK::P)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G172 #:G174)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN DISJOIN-ALISTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp
; in: DEFUN DISJOIN-ALISTS
;     (EQL SNARK::X1 (CAR SNARK::Y))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::Y1 (CAR SNARK::X))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN DISJOIN-ALIST1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.lisp
; in: DEFUN DISJOIN-ALIST1
;     (EQL SNARK::KEY (CAR SNARK::P))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:LCONS (CAR SNARK::P) (SNARK::DISJOIN SNARK::VALUE (CDR SNARK::P))
;                       SNARK::P)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G248 #:G250)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/alists.fasl written
; compilation finished in 0:00:00.098
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *ATOM-HASH-CODE*)
; compiling (DEFVAR *TERM-BY-HASH-ARRAY*)
; compiling (DEFVAR *HASH-TERM-USES-VARIABLE-NUMBERS* ...)
; compiling (DEFVAR *HASH-TERM-ONLY-COMPUTES-CODE* ...)
; compiling (DEFVAR *HASH-TERM-NOT-FOUND-ACTION* ...)
; compiling (DEFUN INITIALIZE-TERM-HASH ...)
; compiling (DEFUN MAKE-ATOM-HASH-CODE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN MAKE-ATOM-HASH-CODE
;     (* 129 SNARK::*ATOM-HASH-CODE*)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (+ (* 129 SNARK::*ATOM-HASH-CODE*) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (MOD (+ (* 129 SNARK::*ATOM-HASH-CODE*) 1) 1024)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1024) (1024)) (DOUBLE-FLOAT -1024.0d0 1024.0d0) (SINGLE-FLOAT -1024.0 1024.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1024) (1024)) (DOUBLE-FLOAT -1024.0d0 1024.0d0) (SINGLE-FLOAT -1024.0 1024.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1024) (1024)) (DOUBLE-FLOAT -1024.0d0 1024.0d0) (SINGLE-FLOAT -1024.0 1024.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (<= (SETF SNARK::*ATOM-HASH-CODE* (MOD (+ # 1) 1024)) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1024.0d0 2048.0d0) (SINGLE-FLOAT -1024.0 2048.0) (RATIONAL (-1024) (2048))), not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1024.0d0 2048.0d0) (SINGLE-FLOAT -1024.0 2048.0) (RATIONAL (-1024) (2048))), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* 129 SNARK::*ATOM-HASH-CODE*)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* 129 SNARK::*ATOM-HASH-CODE*) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MOD (+ (* 129 SNARK::*ATOM-HASH-CODE*) 1) 1024)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-1024) (1024)) (DOUBLE-FLOAT -1024.0d0 1024.0d0) (SINGLE-FLOAT -1024.0 1024.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2048.0d0) (SINGLE-FLOAT (0.0) 2048.0) (RATIONAL (0) (2048))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-1024) (1024)) (DOUBLE-FLOAT -1024.0d0 1024.0d0) (SINGLE-FLOAT -1024.0 1024.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2048.0d0) (SINGLE-FLOAT (0.0) 2048.0) (RATIONAL (0) (2048))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= (SETF SNARK::*ATOM-HASH-CODE* (MOD (+ # 1) 1024)) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1024.0d0 2048.0d0) (SINGLE-FLOAT -1024.0 2048.0) (RATIONAL (-1024) (2048))), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT -1024.0d0 2048.0d0) (SINGLE-FLOAT -1024.0 2048.0) (RATIONAL (-1024) (2048))), not a FIXNUM.
;       etc.

; compiling (DEFUN FIND-TERM-BY-HASH ...)
; compiling (DEFUN TERM-BY-HASH-ARRAY-TERMS ...)
; compiling (DEFMACRO THVALUES ...)
; compiling (DEFUN HASH-TERM* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN HASH-TERM*
;     (+ 1024 (SNARK::VARIABLE-NUMBER SNARK::X))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN HASH-TERM-CODE ...)
; compiling (DEFUN HASH-TERM ...)
; compiling (DEFUN SOME-HASH-TERM ...)
; compiling (DEFUN THE-HASH-TERM ...)
; compiling (DEFUN HASH-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN HASH-LIST
;     (* SNARK::MULTIPLIER SNARK::XHASH)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (+ SNARK::MULTIPLIER 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* SNARK::MULTIPLIER SNARK::XHASH)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::MULTIPLIER 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK::XHASH SNARK::YHASH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK::X SNARK::X*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (+ SNARK::XHASH SNARK::YHASH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK::X SNARK::X*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN HASH-COMPOUND ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN HASH-COMPOUND
;     (* 2 SNARK::HASH1)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH1)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH1)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH1)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* 2 SNARK::HASH2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH (REST (REST SNARK:ARGS)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (* (SNARK::FUNCTION-HASH-CODE SNARK:HEAD)
;        (+ 1 (LENGTH (REST (REST SNARK:ARGS)))))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.

;     (* 2 SNARK::HASH1)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2))
; --> + 
; ==>
;   (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 2 SNARK::HASH2)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2))
; ==>
;   (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;      (* 2 SNARK::HASH2))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK:ARG2 SNARK::ARG2*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK:ARG1 SNARK::ARG1*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (* 2 SNARK::HASH1)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2))
; --> + 
; ==>
;   (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 2 SNARK::HASH2)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2))
; ==>
;   (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;      (* 2 SNARK::HASH2))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 2 SNARK::HASH1)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2) SNARK::HASH3)
; --> + + 
; ==>
;   (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 2 SNARK::HASH2)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2) SNARK::HASH3)
; --> + 
; ==>
;   (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;      (* 2 SNARK::HASH2))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+
;    (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;       (* 2 SNARK::HASH2))
;    SNARK::HASH3)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (EQL SNARK:ARG2 SNARK::ARG2*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK:ARG1 SNARK::ARG1*)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (* 2 SNARK::HASH1)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2) SNARK::HASH3)
; --> + + 
; ==>
;   (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 2 SNARK::HASH2)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1)
;        (* 2 SNARK::HASH2) SNARK::HASH3)
; --> + 
; ==>
;   (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;      (* 2 SNARK::HASH2))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+
;    (+ (+ (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (* 2 SNARK::HASH1))
;       (* 2 SNARK::HASH2))
;    SNARK::HASH3)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* (SNARK::FUNCTION-HASH-CODE SNARK:HEAD)
;        (+ 1 (LENGTH (REST (REST SNARK:ARGS)))))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK::HASH
;           (IF (SNARK::FUNCTION-ASSOCIATIVE SNARK:HEAD)
;               (* (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (+ 1 (LENGTH #)))
;               (SNARK::FUNCTION-HASH-CODE SNARK:HEAD)))
; --> SETQ THE 
; ==>
;   (+
;    (IF (SNARK::FUNCTION-ASSOCIATIVE SNARK:HEAD)
;        (* (SNARK::FUNCTION-HASH-CODE SNARK:HEAD) (+ 1 (LENGTH #)))
;        (SNARK::FUNCTION-HASH-CODE SNARK:HEAD))
;    SNARK::HASH)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN PRINT-TERM-HASH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN PRINT-TERM-HASH
;     (< 1 SNARK::TERMS)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (LENGTH SNARK::L)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (>= (LENGTH SNARK::L) SNARK::TERMS)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR SNARK::*TERM-BY-HASH-ARRAY*
;                                             SNARK::->* SNARK::L)
;       (LENGTH SNARK::L SNARK::-> SNARK::LEN)
;       (INCF SNARK::NTERMS SNARK::LEN)
;       (WHEN SNARK::DETAILS
;         (INCF (SNARK-SPARSE-ARRAY:SPAREF SNARK::A SNARK::LEN))))
; --> BLOCK FLET BLOCK LET 
; ==>
;   (LENGTH SNARK::L)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (INCF (SNARK-SPARSE-ARRAY:SPAREF SNARK::A SNARK::LEN))
; --> LET* 
; ==>
;   (+ 1 (SNARK-SPARSE-ARRAY::SPAREF1 #:A213 #:LEN214))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::NTERMS SNARK::LEN)
; --> SETQ THE 
; ==>
;   (+ SNARK::LEN SNARK::NTERMS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF (SNARK-SPARSE-ARRAY:SPAREF SNARK::A SNARK::LEN))
; --> LET* 
; ==>
;   (+ 1 (SNARK-SPARSE-ARRAY::SPAREF1 #:A213 #:LEN214))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< 1 SNARK::TERMS)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (>= (LENGTH SNARK::L) SNARK::TERMS)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; compiling (DEFVAR *DEFAULT-HASH-TERM-SET-COUNT-DOWN-TO-HASHING* ...)
; compiling (DEFSTRUCT (HASH-TERM-SET # ...) ...)
; compiling (DEFUN HTS-MEMBER-P ...)
; compiling (DEFUN HTS-ADJOIN-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.lisp
; in: DEFUN HTS-ADJOIN-P
;     (- SNARK::C 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-hash.fasl written
; compilation finished in 0:00:00.139
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TRIE-INDEX*)
; compiling (DEFSTRUCT (TRIE-INDEX # ...) ...)
; compiling (DEFSTRUCT (TRIE-INDEX-INTERNAL-NODE #) ...)
; compiling (DEFSTRUCT (TRIE-INDEX-LEAF-NODE # ...))
; compiling (DEFMACRO TRIE-INDEX-LEAF-NODE-ENTRIES ...)
; compiling (DEFSTRUCT (INDEX-ENTRY # ...) ...)
; compiling (DEFUN MAKE-TRIE-INDEX ...)
; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE ...)
; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFINLINE TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;     (SNARK::CONSTANT-NUMBER SNARK::CONST)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-LOOKUP-ARGS ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-ARGS ...)
; compiling (DEFINLINE FUNCTION-TRIE-INDEX-ARITY ...)
; compiling (DEFUN SIMPLY-INDEXED-P ...)
; compiling (DEFINLINE TRIE-INDEX-BUILD-PATH-FOR-TERMS ...)
; compiling (DEFUN TRIE-INDEX-BUILD-PATH-FOR-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN TRIE-INDEX-BUILD-PATH-FOR-TERM
;     (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                  SNARK::NODE T
;                                                                  SNARK::INTERNAL)
; --> 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE TRIE-INDEX-PATH-FOR-TERMS ...)
; compiling (DEFUN TRIE-INDEX-PATH-FOR-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN TRIE-INDEX-PATH-FOR-TERM
;     (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;                                                                  SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                  SNARK::NODE)
; --> 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TRIE-INDEX-INSERT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN TRIE-INDEX-INSERT
;     (FUNCALL (SNARK::TRIE-INDEX-ENTRY-CONSTRUCTOR SNARK::TRIE-INDEX) SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SNARK::TRIE-INDEX-ENTRY-CONSTRUCTOR SNARK::TRIE-INDEX))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::TERM (SNARK::INDEX-ENTRY-TERM SNARK::E))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (ASSERT (EQL SNARK::TERM (SNARK::INDEX-ENTRY-TERM SNARK::ENTRY)))
; --> TAGBODY LET WHEN IF 
; ==>
;   (EQL #:TEMP788 #:TEMP789)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-NUMBERING:NONCE)
; --> (LAMBDA NIL (INCF SNARK-NUMBERING::*NONCE*)) SB-C::%FUNCALL INCF SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN TRIE-INDEX-DELETE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN TRIE-INDEX-DELETE
;     (SNARK::CONSTANT-NUMBER (POP SNARK::PATH))
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::TERM (SNARK::INDEX-ENTRY-TERM SNARK::E))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (ASSERT (EQL SNARK::TERM (SNARK::INDEX-ENTRY-TERM SNARK::ENTRY)))
; --> TAGBODY LET WHEN IF 
; ==>
;   (EQL #:TEMP870 #:TEMP871)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFMACRO MAP-TRIE-INDEX-ENTRIES ...)
; compiling (DEFUN MAP-TRIE-INDEX-INSTANCE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-INSTANCE-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS + 
; --> SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {1005F4F3A3}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF FLET 
; --> BLOCK SNARK::SKIP-TERMS SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {1005EFEEC3}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-INSTANCE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS 
; ==>
;   (+ SNARK::N
;      (SNARK::FUNCTION-TRIE-INDEX-ARITY (SNARK::SYMBOL-NUMBERED SNARK::|FN#|)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN MAP-TRIE-INDEX-GENERALIZATION-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-GENERALIZATION-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS + 
; --> SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {100691E833}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF FLET 
; --> BLOCK SNARK::SKIP-TERMS SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {10068CD883}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF SNARK::SKIP-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-GENERALIZATION-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-TRIE-INDEX-UNIFIABLE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-UNIFIABLE-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS + 
; --> SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {100741DCD3}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF FLET 
; --> BLOCK SNARK::SKIP-TERMS SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {10073CD653}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-UNIFIABLE-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                        SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE)))
;                                    :IF-COMPOUND
;                                    (PROGN
;                                     (SNARK-LISP:PROG->
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                        SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))
;                                     (SNARK-LISP:PROG->
;                                       (SNARK:HEAD SNARK::TERM SNARK::->
;                                                   SNARK:HEAD)
;                                       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                        SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                        SNARK::NODE)
;                                       (SNARK::MAP-FOR-TERMS
;                                        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                         SNARK:HEAD SNARK::TERM)
;                                        SNARK::NODE SNARK::->* SNARK::NODE)
;                                       (FUNCALL SNARK::CC SNARK::NODE))))
; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS 
; ==>
;   (+ SNARK::N
;      (SNARK::FUNCTION-TRIE-INDEX-ARITY (SNARK::SYMBOL-NUMBERED SNARK::|FN#|)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN MAP-TRIE-INDEX-VARIANT-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-VARIANT-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS + 
; --> SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {1007EFD353}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF FLET 
; --> BLOCK SNARK::SKIP-TERMS SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {1007EAC013}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES 
; --> SB-KERNEL:%INSTANCE-REF THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF SNARK::SKIP-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE SNARK:HEAD
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (SNARK::MAP-FOR-TERMS
;        (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS SNARK:HEAD SNARK::TERM)
;        SNARK::NODE SNARK::->* SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET LET SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::FN SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|FN#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|FN#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET UNLESS IF WHEN IF SETF SETQ THE SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-VARIANT-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE
;                                       SNARK::NODE SNARK::->NONNIL SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-CONSTANT
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE
;                                       SNARK::TERM SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE))
;                                    :IF-COMPOUND
;                                    (SNARK-LISP:PROG->
;                                      (SNARK:HEAD SNARK::TERM SNARK::-> SNARK:HEAD)
;                                      (SNARK::TRIE-INDEX-INTERNAL-NODE-FUNCTION-INDEXED-CHILD-NODE
;                                       SNARK:HEAD SNARK::NODE SNARK::->NONNIL
;                                       SNARK::NODE)
;                                      (SNARK::MAP-FOR-TERMS
;                                       (SNARK::FUNCTION-TRIE-INDEX-LOOKUP-ARGS
;                                        SNARK:HEAD SNARK::TERM)
;                                       SNARK::NODE SNARK::->* SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                    SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (FUNCALL SNARK::CC SNARK::NODE))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::CONST SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (LET ((SNARK::CHILDREN (SNARK::TRIE-INDEX-INTERNAL-NODE-CONSTANT-INDEXED-CHILD-NODES SNARK::NODE))) (UNLESS SNARK::CHILDREN (WHEN SNARK::CREATE (SETF SNARK::CHILDREN (SETF # #)))) (AND SNARK::CHILDREN (LET ((SNARK::|CONST#| #)) (OR (SNARK-SPARSE-ARRAY:SPAREF SNARK::CHILDREN SNARK::|CONST#|) (AND SNARK::CREATE #)))))) 
; --> SB-C::%FUNCALL LET AND IF AND THE LET SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::NODE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAP-TRIE-INDEX-ALL-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFUN MAP-TRIE-INDEX-ALL-ENTRIES
;     (SNARK::MAP-TRIE-INDEX-ENTRIES :COUNT-CALL
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-ALL-CALLS
;                                      SNARK::TRIE-INDEX))
;                                    :COUNT-ENTRY
;                                    (INCF
;                                     (SNARK::TRIE-INDEX-RETRIEVE-ALL-COUNT
;                                      SNARK::TRIE-INDEX))
;                                    :IF-VARIABLE
;                                    (SNARK-LISP:PROG->
;                                      (SNARK::SKIP-TERMS 1 SNARK::NODE SNARK::->*
;                                       SNARK::NODE)
;                                      (FUNCALL SNARK::CC SNARK::NODE)))
; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET 
; --> SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS + 
; --> SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-ALL-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {100A589613}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF FLET 
; --> BLOCK SNARK::SKIP-TERMS SNARK::FUNCTION-TRIE-INDEX-ARITY 
; --> (LAMBDA (SNARK::FN) (ECASE (SNARK::FUNCTION-INDEX-TYPE SNARK::FN) ((NIL) (COND ((SNARK::FUNCTION-UNIFY-CODE SNARK::FN) 0) (T (LET # #)))) (:COMMUTE (LET ((SNARK::ARITY #)) (IF (EQ :ANY SNARK::ARITY) 3 SNARK::ARITY))) (:JEPD 2) (:HASH-BUT-DONT-INDEX 0))) 
; --> SB-C::%FUNCALL 
; --> #<SB-C::CLAMBDA :%SOURCE-NAME SB-C::.ANONYMOUS. :%DEBUG-NAME (LAMBDA (SNARK::FN) :IN SNARK::MAP-TRIE-INDEX-ALL-ENTRIES) :KIND :LET :TYPE #<SB-KERNEL:BUILT-IN-CLASSOID FUNCTION (read-only)> :WHERE-FROM :DEFINED :VARS (SNARK::FN) {100A501533}> 
; --> SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN PROGN SNARK-LISP:PROG-> BLOCK LET WHEN IF 
; --> FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> LABELS BLOCK COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; --> SB-KERNEL:%COERCE-CALLABLE-TO-FUN 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> PROGN SNARK-LISP:PROG-> BLOCK SNARK::MAP-FOR-TERM 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF COND THE PROGN COND IF 
; --> COND THE PROGN SNARK-LISP:PROG-> BLOCK FLET SNARK::MAP-FOR-TERM 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF PROGN COND IF PROGN 
; --> SNARK-LISP:PROG-> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET 
; --> TAGBODY SNARK-LISP::UNNAMED-PROG-> SNARK::MAP-FOR-TERMS 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND THE PROGN LET COND IF PROGN COND IF COND THE 
; --> PROGN SNARK-LISP:PROG-> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET SNARK::MAP-FOR-TERMS 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

; --> LABELS BLOCK COND IF COND IF COND THE PROGN PROGN SNARK-LISP:PROG-> BLOCK 
; --> LET WHEN IF FLET BLOCK SNARK::SKIP-TERMS 
; ==>
;   (+ SNARK::N
;      (SNARK::FUNCTION-TRIE-INDEX-ARITY (SNARK::SYMBOL-NUMBERED SNARK::|FN#|)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFINLINE MAP-TRIE-INDEX ...)
; compiling (DEFUN PRINT-TRIE-INDEX ...)
; compiling (DEFUN PRINT-INDEX* ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T TRIE-INDEX-INTERNAL-NODE T)
;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE SNARK::NODE
;                                                                    SNARK::->NONNIL
;                                                                    SNARK::NODE)
;       (SNARK::MAP-INDEX-LEAF-NODES SNARK::NODE (CONS 'SNARK:? SNARK::REVPATH)
;                                    SNARK::->* SNARK::NODE SNARK::REVPATH)
;       (FUNCALL SNARK::CC SNARK::NODE SNARK::REVPATH))
; --> BLOCK LET SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-INDEXED-CHILD-NODE 
; --> (LAMBDA (SNARK::NODE &OPTIONAL SNARK::CREATE SNARK::INTERNAL) (OR (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (AND SNARK::CREATE (PROGN (SNARK-LISP:INCREMENT-COUNTER (SNARK::TRIE-INDEX-NODE-COUNTER SNARK::*TRIE-INDEX*)) (SETF (SNARK::TRIE-INDEX-INTERNAL-NODE-VARIABLE-CHILD-NODE SNARK::NODE) (IF SNARK::INTERNAL # #)))))) 
; --> SB-C::%FUNCALL OR LET IF OR THE AND IF AND THE PROGN SETF 
; --> SB-KERNEL:%INSTANCE-SET THE 
; ==>
;   SNARK::NODE
; 
; note: deleting unreachable code

;     (SNARK::SYMBOL-NUMBERED SNARK::|FN#|)
; --> 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::SYMBOL-NUMBERED SNARK::|CONST#|)
; --> 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T TRIE-INDEX-LEAF-NODE T)
;     (FUNCALL SNARK::CC SNARK::NODE SNARK::REVPATH)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMETHOD PRINT-INDEX-LEAF-NODE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie-index.fasl written
; compilation finished in 0:00:00.507
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *TERPRI-INDENT*))
; compiling (DEFVAR *PATH-INDEX*)
; compiling (DEFSTRUCT (PATH-INDEX # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-NODE #) ...)
; compiling (DEFSTRUCT (PATH-INDEX-INTERNAL-NODE1 # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-INTERNAL-NODE2 # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-LEAF-NODE # ...) ...)
; compiling (DEFSTRUCT (PATH-INDEX-ENTRY # ...) ...)
; compiling (DEFUN MAKE-PATH-INDEX ...)
; compiling (DEFMACRO PATH-INDEX-INTERNAL-NODE1-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO ADD-PATH-INDEX-INTERNAL-NODE1-FUNCTION-INDEXED-CHILD-NODE ...)
; compiling (DEFMACRO ADD-PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE ...)
; compiling (DEFUN PATH-INDEX-ENTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-ENTRY
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN THE-PATH-INDEX-ENTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN THE-PATH-INDEX-ENTRY
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSERT (EQL SNARK::TERM (SNARK::HASH-TERM SNARK::TERM)))
; --> TAGBODY LET WHEN IF 
; ==>
;   (EQL #:TEMP444 #:TEMP445)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SOME-PATH-INDEX-ENTRY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN SOME-PATH-INDEX-ENTRY
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PATH-INDEX-DELETE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-DELETE
;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PATH-INDEX-DELETE-LEAF-NODE ...)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY*)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY-LEAF-NODES*)
; compiling (DEFVAR *PATH-INDEX-INSERT-ENTRY-INTERNAL-NODES*)
; compiling (DEFUN PATH-INDEX-INSERT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-INSERT
;     (FUNCALL (SNARK::PATH-INDEX-ENTRY-CONSTRUCTOR SNARK::PATH-INDEX) SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SNARK::PATH-INDEX-ENTRY-CONSTRUCTOR SNARK::PATH-INDEX))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (LENGTH SNARK::L)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (MAKE-ARRAY SNARK::N :INITIAL-CONTENTS SNARK::L)
; --> LOCALLY MAKE-ARRAY UNLESS IF = 
; ==>
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; --> LOCALLY MAKE-ARRAY TRULY-THE 
; ==>
;   (REPLACE
;    (TRULY-THE (SIMPLE-ARRAY T (*))
;               (SB-KERNEL:ALLOCATE-VECTOR 217 (THE SB-INT:INDEX LENGTH)
;                                          (* LENGTH 1)))
;    SB-C::INITIAL-CONTENTS)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a SIMPLE-VECTOR.

; --> LOCALLY MAKE-ARRAY UNLESS IF ERROR 
; ==>
;   (LENGTH SB-C::INITIAL-CONTENTS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN PATH-INDEX-INSERT* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-INSERT*
;     (SNARK::PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                   SNARK::NODE1)
; --> SNARK-SPARSE-ARRAY:SPAREF SNARK-SPARSE-ARRAY::SPAREF1 
; --> SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::ADD-PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE SNARK::TERM
;                                                                       SNARK::NODE1
;                                                                       SNARK::LEAF)
; --> SETF LET* SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PATH-INDEX-INSERT-APPL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-INSERT-APPL
;     (MEMBER SNARK::NODE1A SNARK::L)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN PATH-INDEX-INSERT-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-INSERT-LIST
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (FUNCALL SNARK::INDEXFUN SNARK:HEAD SNARK::I)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::INDEXFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (LOOP SNARK::WITH SNARK::NODE2 = (SNARK::PATH-INDEX-INSERT-LIST1 SNARK:HEAD
;                                                                      (LENGTH
;                                                                       SNARK:ARGS)
;                                                                      SNARK::NODE1
;                                                                      SNARK::INDEXFUN)
;           SNARK::WITH SNARK::IINODES = (SNARK::PATH-INDEX-INTERNAL-NODE2-INTEGER-INDEXED-CHILD-NODES
;                                         SNARK::NODE2)
;           SNARK::FOR SNARK::ARG SNARK::IN ...)
; --> BLOCK LET LET LET LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PATH-INDEX-INSERT-LIST1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-INSERT-LIST1
;     (MEMBER SNARK::N SNARK::L)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::INDEXFUN SNARK:HEAD SNARK::I)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::INDEXFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PATH-INDEX-INSERT-AT-LEAF ...)
; compiling (DEFUN NO-INTEGER-INDEXED-CHILD-NODES-P ...)
; compiling (DEFUN C-INDEX ...)
; compiling (DEFMACRO PATH-INDEX-VARIABLE-LEAF ...)
; compiling (DEFMACRO PATH-INDEX-CONSTANT-LEAF ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY ...)
; compiling (DEFUN MAKE-PATH-INDEX-QUERY-V ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-V
;     (SNARK::PATH-INDEX-CONSTANT-LEAF SNARK::NODE1 SNARK::TERM)
; --> LET SNARK::PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE 
; --> SNARK-SPARSE-ARRAY:SPAREF SNARK-SPARSE-ARRAY::SPAREF1 
; --> SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PATH-INDEX-QUERY-I ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-I
;     (SNARK::PATH-INDEX-CONSTANT-LEAF SNARK::NODE1 SNARK::TERM)
; --> LET SNARK::PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE 
; --> SNARK-SPARSE-ARRAY:SPAREF SNARK-SPARSE-ARRAY::SPAREF1 
; --> SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PATH-INDEX-QUERY-G ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-G
;     (SNARK::PATH-INDEX-CONSTANT-LEAF SNARK::NODE1 SNARK::TERM)
; --> LET SNARK::PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE 
; --> SNARK-SPARSE-ARRAY:SPAREF SNARK-SPARSE-ARRAY::SPAREF1 
; --> SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PATH-INDEX-QUERY-U ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-U
;     (SNARK::PATH-INDEX-CONSTANT-LEAF SNARK::NODE1 SNARK::TERM)
; --> LET SNARK::PATH-INDEX-INTERNAL-NODE1-CONSTANT-INDEXED-CHILD-NODE 
; --> SNARK-SPARSE-ARRAY:SPAREF SNARK-SPARSE-ARRAY::SPAREF1 
; --> SNARK::CONSTANT-NUMBER 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PATH-INDEX-QUERY-APPL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-APPL
;     (FUNCALL SNARK::MAKE-QUERY SNARK::ARG SUBST SNARK::NODE1
;              SNARK::HEAD-IF-ASSOCIATIVE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAKE-QUERY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::MAKE-QUERY SNARK::ARG SUBST SNARK::NODE1A
;              SNARK::HEAD-IF-ASSOCIATIVE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAKE-QUERY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::MAKE-QUERY SNARK::ARG SUBST SNARK::NODE1A)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAKE-QUERY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PATH-INDEX-QUERY-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAKE-PATH-INDEX-QUERY-LIST
;     (FUNCALL SNARK::MAKE-QUERY SNARK::ARG SUBST
;              (SVREF SNARK::IINODES
;                     (IF SNARK::INDEXFUN
;                         (FUNCALL SNARK::INDEXFUN SNARK:HEAD SNARK::I)
;                         SNARK::I)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAKE-QUERY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::INDEXFUN SNARK:HEAD SNARK::I)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::INDEXFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (LOOP SNARK::WITH SNARK::IINODES = (SNARK::PATH-INDEX-INTERNAL-NODE2-INTEGER-INDEXED-CHILD-NODES
;                                         SNARK::NODE2)
;           SNARK::FOR SNARK::ARG SNARK::IN SNARK:ARGS SNARK::AS SNARK::I SNARK::FROM ...)
; --> BLOCK LET LET LET LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* 
; --> SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 1+ 
; ==>
;   (+ SNARK::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMACRO MAP-LEAF0 ...)
; compiling (DEFMACRO MAP-LEAF ...)
; compiling (DEFUN MAP-PATH-INDEX-ENTRIES ...)
; compiling (DEFUN MAP-PATH-INDEX-BY-QUERY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN MAP-PATH-INDEX-BY-QUERY
;     (FIRST SNARK::QUERY)
; --> CAR 
; ==>
;   SNARK::QUERY
; 
; note: deleting unreachable code

;     (SNARK::MAP-LEAF SNARK::VAR-LEAF)
; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF NULL IF SETF SETQ THE FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::MAP-LEAF SNARK::V)
; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF NULL IF SETF SETQ THE FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::MAP-LEAF SNARK::QUERY)
; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF NULL IF SETF SETQ THE FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF COND IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> IF SNARK::MAP-LEAF0 SNARK-LISP:PROG-> BLOCK FLET BLOCK COND LET IF COND 
; --> IF PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (+ SNARK::N 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::TEST SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (+ SNARK::N 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMACRO MARK-PATH-INDEX-ENTRY-IN-NODES ...)
; compiling (DEFMACRO MEMBER-PATH-INDEX-ENTRY-IN-NODES ...)
; compiling (DEFUN PATH-INDEX-ENTRY-SATISFIES-QUERY-P ...)
; compiling (DEFUN PATH-INDEX-ENTRY-SATISFIES-QUERY-P* ...)
; compiling (DEFUN RETRIEVAL-SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN RETRIEVAL-SIZE
;     (< SNARK::N SNARK::MIN-SIZE)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= (SETF SNARK::MIN-SIZE SNARK::N) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (DEFUN SNARK::RETRIEVAL-SIZE (SNARK::QUERY SNARK::BOUND)
;       (COND ((NOT (CONSP SNARK::QUERY)) (COND (# #) (T # #)))
;             ((EQ 'INTERSECTION (FIRST SNARK::QUERY))
;              (LET* (# #)
;                (DOLIST # #)
;                SNARK::MIN-SIZE))
;             (T
;              (LET (#)
;                (DOLIST # # #)
;                SNARK::TOTAL-SIZE))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::RETRIEVAL-SIZE
;     (COND ((NOT (CONSP SNARK::QUERY)) (COND (# #) (T # #)))
;           ((EQ 'INTERSECTION (FIRST SNARK::QUERY))
;            (LET* (# #)
;              (DOLIST # #)
;              SNARK::MIN-SIZE))
;           (T
;            (LET (#)
;              (DOLIST # # #)
;              SNARK::TOTAL-SIZE))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM RETRIEVAL-SIZE BOUND). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (- SNARK::BOUND SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK::TOTAL-SIZE
;           (SNARK::RETRIEVAL-SIZE SNARK::ARG (- SNARK::BOUND SNARK::TOTAL-SIZE)))
; --> SETQ THE 
; ==>
;   (+ (SNARK::RETRIEVAL-SIZE SNARK::ARG (- SNARK::BOUND SNARK::TOTAL-SIZE))
;      SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (< SNARK::N SNARK::MIN-SIZE)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (<= (SETF SNARK::MIN-SIZE SNARK::N) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (INCF SNARK::TOTAL-SIZE
;           (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT
;            (SNARK::PATH-INDEX-LEAF-NODE-ENTRIES SNARK::VAR-LEAF)))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT
;     (SNARK::PATH-INDEX-LEAF-NODE-ENTRIES SNARK::VAR-LEAF))
;    SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (INCF SNARK::TOTAL-SIZE
;           (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT
;            (SNARK::PATH-INDEX-LEAF-NODE-ENTRIES SNARK::V)))
; --> SETQ THE 
; ==>
;   (+
;    (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT
;     (SNARK::PATH-INDEX-LEAF-NODE-ENTRIES SNARK::V))
;    SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (- SNARK::BOUND SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK::TOTAL-SIZE
;           (SNARK::RETRIEVAL-SIZE SNARK::V (- SNARK::BOUND SNARK::TOTAL-SIZE)))
; --> SETQ THE 
; ==>
;   (+ (SNARK::RETRIEVAL-SIZE SNARK::V (- SNARK::BOUND SNARK::TOTAL-SIZE))
;      SNARK::TOTAL-SIZE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (>= SNARK::TOTAL-SIZE SNARK::BOUND)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN SELECT-QUERY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN SELECT-QUERY
;     (< SNARK::N SNARK::MIN-SIZE)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (<= (SETF SNARK::MIN-SIZE SNARK::N) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< SNARK::N SNARK::MIN-SIZE)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (<= (SETF SNARK::MIN-SIZE SNARK::N) 1)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; compiling (DEFUN MAKE-BOOLEAN-QUERY* ...)
; compiling (DEFUN MAKE-BOOLEAN-QUERY ...)
; compiling (DEFUN MAKE-UNIOND-QUERY2 ...)
; compiling (DEFUN NODUP-APPEND ...)
; compiling (DEFUN PATH-INDEX-SPARSE-VECTOR-EXPRESSION-P ...)
; compiling (DEFUN FIX-PATH-INDEX-SPARSE-VECTOR-EXPRESSION ...)
; compiling (DEFUN SPARSE-VECTOR-EXPRESSION-DESCRIPTION ...)
; compiling (DEFUN SZ ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN SZ
;     (+ (SNARK::SZ (CAR SNARK::X)) (SNARK::SZ (CDR SNARK::X)) 1)
; ==>
;   (+ (+ (SNARK::SZ (CAR SNARK::X)) (SNARK::SZ (CDR SNARK::X))) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> + 
; ==>
;   (+ (SNARK::SZ (CAR SNARK::X)) (SNARK::SZ (CDR SNARK::X)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+ (+ (SNARK::SZ (CAR SNARK::X)) (SNARK::SZ (CDR SNARK::X))) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN TRACED-OPTIMIZE-SPARSE-VECTOR-EXPRESSION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN TRACED-OPTIMIZE-SPARSE-VECTOR-EXPRESSION
;     (EQL (SNARK::SZ SNARK::DESC) (SNARK::SZ SNARK::DESC*))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PRINT-PATH-INDEX ...)
; compiling (DEFMETHOD PRINT-INDEX-LEAF-NODE ...)
; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T PATH-INDEX-INTERNAL-NODE1 T)
;     (SNARK::SYMBOL-NUMBERED SNARK::K)
; --> 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T PATH-INDEX-INTERNAL-NODE2 T)
;     (ARRAY-DIMENSION SNARK::IINODES 0)
; 
; note: unable to optimize because: The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

; compiling (DEFMETHOD MAP-INDEX-LEAF-NODES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFMETHOD MAP-INDEX-LEAF-NODES (T PATH-INDEX-LEAF-NODE T)
;     (FUNCALL SNARK::CC SNARK::NODE SNARK::REVPATH)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PRINT-REVPATH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PRINT-REVPATH
;     (< SNARK::X 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (- SNARK::X)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::X))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER * -1), not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 2) because:
;       The first argument is a (INTEGER * -1), not a (SIGNED-BYTE 64).
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).

;     (+ SNARK::X 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PATH-INDEX-KEY-FOR-VALUE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-KEY-FOR-VALUE
;     (SNARK::SYMBOL-NUMBERED SNARK::K)
; --> 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DEFUN SNARK::PATH-INDEX-KEY-FOR-VALUE (SNARK::VALUE SNARK::TABLE)
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;        (LAMBDA (SNARK::V SNARK::K)
;          (WHEN (EQ SNARK::VALUE SNARK::V)
;            (RETURN-FROM SNARK::PATH-INDEX-KEY-FOR-VALUE #)))
;        SNARK::TABLE))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::PATH-INDEX-KEY-FOR-VALUE
;     (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;      (LAMBDA (SNARK::V SNARK::K)
;        (WHEN (EQ SNARK::VALUE SNARK::V)
;          (RETURN-FROM SNARK::PATH-INDEX-KEY-FOR-VALUE #)))
;      SNARK::TABLE))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM PATH-INDEX-KEY-FOR-VALUE (SYMBOL-NUMBERED K)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN PATH-INDEX-NODE-REVPATH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.lisp
; in: DEFUN PATH-INDEX-NODE-REVPATH
;     (POSITION SNARK::NODE
;               (SNARK::PATH-INDEX-INTERNAL-NODE2-INTEGER-INDEXED-CHILD-NODES
;                SNARK::PARENT-NODE))
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

; compiling (DEFUN PRINT-PATH-INDEX-QUERY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/path-index.fasl written
; compilation finished in 0:00:00.473
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO MAKE-TRIE-NODE ...)
; compiling (DEFMACRO TRIE-NODE-DATA ...)
; compiling (DEFMACRO TRIE-NODE-BRANCHES ...)
; compiling (DEFSTRUCT (TRIE #) ...)
; compiling (DEFUN TRIEREF ...)
; compiling (DEFUN (SETF TRIEREF) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.lisp
; in: DEFUN (SETF TRIEREF)
;     (LABELS ((SNARK::TRIE-DELETE (SNARK::NODE SNARK::KEYS)
;                (COND (# # #) (T #))))
;       (SNARK::TRIE-DELETE (SNARK::TRIE-TOP-NODE SNARK::TRIE) SNARK::KEYS)
;       NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN TRIE-SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.lisp
; in: DEFUN TRIE-SIZE
;     (+ SNARK::SIZE (SNARK::TRIE-SIZE SNARK::NODE SNARK::COUNT-ONLY-DATA-NODES?))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN MAP-TRIE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.lisp
; in: DEFUN MAP-TRIE
;     (FUNCALL FUNCTION SNARK::D)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/trie.fasl written
; compilation finished in 0:00:00.032
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFCONSTANT $FV-MAXIMUM-FEATURE-VALUE ...)
; compiling (DEFCONSTANT $FV-FEATURES-PER-SYMBOL ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-COUNT ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-COUNT ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-MAX-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-MAX-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-POS-MIN-DEPTH ...)
; compiling (DEFCONSTANT $FV-OFFSET-NEG-MIN-DEPTH ...)
; compiling (DEFCONSTANT $FV-NUMBER-GROUND ...)
; compiling (DECLARE-SNARK-OPTION FEATURE-VECTOR-SYMBOL-NUMBER-FOLDING ...)
; compiling (DEFUN NEW-FEATURE-VECTOR ...)
; compiling (DEFUN FEATURE-VECTOR-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp
; in: DEFUN FEATURE-VECTOR-LIST
;     (ASSERT (< 0 SNARK::V))
; --> TAGBODY LET WHEN IF < > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::FV-TRIE-KEY SNARK::K SNARK::V)
; --> 
; --> (LAMBDA (SNARK::FEATURE-NUMBER SNARK::FEATURE-VALUE) (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER) SNARK::FEATURE-VALUE)) 
; --> SB-C::%FUNCALL + 
; ==>
;   (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (ASSERT (< 0 SNARK::V))
; --> TAGBODY LET WHEN IF < > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (SNARK::FV-TRIE-KEY SNARK::K SNARK::V)
; --> 
; --> (LAMBDA (SNARK::FEATURE-NUMBER SNARK::FEATURE-VALUE) (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER) SNARK::FEATURE-VALUE)) 
; --> SB-C::%FUNCALL + 
; ==>
;   (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> 
; --> (LAMBDA (SNARK::FEATURE-NUMBER SNARK::FEATURE-VALUE) (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER) SNARK::FEATURE-VALUE)) 
; --> SB-C::%FUNCALL 
; ==>
;   (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
;      SNARK::FEATURE-VALUE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN UPDATE-FEATURE-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp
; in: DEFUN UPDATE-FEATURE-VECTOR
;     (MOD SNARK::SYMBOL-NUMBER SNARK::N)
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (* 1 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to fold identity operations due to type uncertainty: The first argument is a REAL, not a (OR RATIONAL (COMPLEX RATIONAL)).

;     (* 2 SNARK::N)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 3 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 4 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (+ 1
;        (CASE SNARK::ARITY
;          (0 (* 1 SNARK::N))
;          (1 (* 2 SNARK::N))
;          (2 (* 3 SNARK::N))
;          (OTHERWISE (* 4 SNARK::N))))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 5 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 6 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 7 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* 8 SNARK::N)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (+ 1
;        (CASE SNARK::ARITY
;          (0 (* 5 SNARK::N))
;          (1 (* 6 SNARK::N))
;          (2 (* 7 SNARK::N))
;          (OTHERWISE (* 8 SNARK::N))))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (* SNARK::$FV-FEATURES-PER-SYMBOL SNARK::SYMBOL-NUMBER*)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (= SNARK::V SNARK::V*)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= 0 SNARK::V)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< 1 COUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< 0 SNARK::V)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (= 0 SNARK::V)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (= SNARK::V SNARK::V*)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= 1 COUNT)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= 0 SNARK::DEPTH)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (+ SNARK::V COUNT))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX SNARK::V SNARK::DEPTH)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (MAX SNARK::V SNARK::DEPTH))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX SNARK::V (- SNARK::$FV-MAXIMUM-FEATURE-VALUE SNARK::DEPTH))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX 1 (MAX SNARK::V (- SNARK::$FV-MAXIMUM-FEATURE-VALUE SNARK::DEPTH)))
; --> LET LET IF >= <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF >= <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE COUNT)
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE
;          (IF (= 0 SNARK::V)
;              (+ 1 COUNT)
;              (+ SNARK::V COUNT)))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (+ SNARK::V COUNT))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> LET LET IF <= >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MOD SNARK::SYMBOL-NUMBER SNARK::N)
; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* 4 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 3 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 2 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 1 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ 1
;        (CASE SNARK::ARITY
;          (0 (* 1 SNARK::N))
;          (1 (* 2 SNARK::N))
;          (2 (* 3 SNARK::N))
;          (OTHERWISE (* 4 SNARK::N))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (* 8 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 7 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 6 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* 5 SNARK::N)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ 1
;        (CASE SNARK::ARITY
;          (0 (* 5 SNARK::N))
;          (1 (* 6 SNARK::N))
;          (2 (* 7 SNARK::N))
;          (OTHERWISE (* 8 SNARK::N))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (MOD SNARK::SYMBOL-NUMBER SNARK::N)
;        (IF SNARK::RELATION-SYMBOL?
;            (+ 1 (CASE SNARK::ARITY (0 #) (1 #) (2 #) (OTHERWISE #)))
;            (+ 1 (CASE SNARK::ARITY (0 #) (1 #) (2 #) (OTHERWISE #)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::$FV-FEATURES-PER-SYMBOL SNARK::SYMBOL-NUMBER*)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (<= 1 COUNT)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (<= 0 SNARK::DEPTH)
; --> >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-COUNT
;            SNARK::$FV-OFFSET-NEG-COUNT))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::V COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (+ SNARK::V COUNT))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (= SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-MAX-DEPTH
;            SNARK::$FV-OFFSET-NEG-MAX-DEPTH))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (MAX SNARK::V SNARK::DEPTH)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (MAX SNARK::V SNARK::DEPTH))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (= SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-MIN-DEPTH
;            SNARK::$FV-OFFSET-NEG-MIN-DEPTH))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (- SNARK::$FV-MAXIMUM-FEATURE-VALUE SNARK::DEPTH)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (MAX SNARK::V (- SNARK::$FV-MAXIMUM-FEATURE-VALUE SNARK::DEPTH))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MAX 1 (MAX SNARK::V (- SNARK::$FV-MAXIMUM-FEATURE-VALUE SNARK::DEPTH)))
; --> LET LET IF >= <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (= SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (< 1 COUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-COUNT
;            SNARK::$FV-OFFSET-NEG-COUNT))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE COUNT)
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (< 0 SNARK::V)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-COUNT
;            SNARK::$FV-OFFSET-NEG-COUNT))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::V COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE
;          (IF (= 0 SNARK::V)
;              (+ 1 COUNT)
;              (+ SNARK::V COUNT)))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (= SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ SNARK::BASE
;        (IF SNARK::POS
;            SNARK::$FV-OFFSET-POS-COUNT
;            SNARK::$FV-OFFSET-NEG-COUNT))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::V COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN SNARK::$FV-MAXIMUM-FEATURE-VALUE (+ SNARK::V COUNT))
; --> LET LET IF <= >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (= SNARK::V SNARK::V*)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN CLAUSE-FEATURE-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp
; in: DEFUN CLAUSE-FEATURE-VECTOR
;     (INCF
;      (SNARK-SPARSE-ARRAY:SPAREF SNARK::FV
;                                 (+ SNARK::$FV-NUMBER-GROUND
;                                    (IF (EQ :POS SNARK::POLARITY)
;                                        SNARK::$FV-OFFSET-POS-COUNT
;                                        SNARK::$FV-OFFSET-NEG-COUNT))))
; --> LET* 
; ==>
;   (+ 1 (SNARK-SPARSE-ARRAY::SPAREF1 #:FV138 #:G139))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ATOM-OR-TERM-FEATURE-VECTOR ...)
; compiling (DEFUN ATOM-FEATURE-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp
; in: DEFUN ATOM-FEATURE-VECTOR
;     (SNARK::CONSTANT-NUMBER ATOM)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TERM-FEATURE-VECTOR ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.lisp
; in: DEFUN TERM-FEATURE-VECTOR
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (SNARK::CONSTANT-NUMBER SNARK::TERM)
; --> 
; --> (LAMBDA (SNARK::CONST) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :LOOKUP SNARK::CONST)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (+ SNARK::DEPTH 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LABELS ((SNARK::TFV (SNARK::TERM SNARK::DEPTH)
;                (SNARK:DEREFERENCE SNARK::TERM SUBST :IF-CONSTANT
;                                   (SNARK::UPDATE-FEATURE-VECTOR # NIL 0
;                                                                 SNARK::POLARITY 1
;                                                                 SNARK::DEPTH
;                                                                 SNARK::FV)
;                                   :IF-COMPOUND
;                                   (SNARK-LISP:PROG->
;                                     #
;                                     #
;                                     #
;                                     #
;                                     #))))
;       (SNARK::TFV SNARK::TERM SNARK::DEPTH))
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

;     (+ SNARK::DEPTH 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector.fasl written
; compilation finished in 0:00:00.155
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFINLINE FV-TRIE-KEY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFINLINE FV-TRIE-KEY
;     (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.
; 
; note: unable to associate */* of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate *// of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 4) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ (* (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1) SNARK::FEATURE-NUMBER)
;        SNARK::FEATURE-VALUE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFINLINE FV-TRIE-KEY-FEATURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFINLINE FV-TRIE-KEY-FEATURE
;     (FLOOR SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE FV-TRIE-KEY-VALUE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFINLINE FV-TRIE-KEY-VALUE
;     (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))
; --> LET REM NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.

; --> LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAP-FV-TRIE<= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFUN MAP-FV-TRIE<=
;     (FUNCALL FUNCTION SNARK::D)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)
; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET REM NTH-VALUE MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (= SNARK::KEY1 SNARK::KEY)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)
; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- 1 (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a (OR (MEMBER 0.0 0.0d0) (RATIONAL (-1000) (2000)) (DOUBLE-FLOAT -1000.0d0 2000.0d0) (SINGLE-FLOAT -1000.0 2000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (RATIONAL (-1999) (1001)) (DOUBLE-FLOAT -1999.0d0 1001.0d0) (SINGLE-FLOAT -1999.0 1001.0)) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a (OR (MEMBER 0.0 0.0d0) (RATIONAL (-1000) (2000)) (DOUBLE-FLOAT -1000.0d0 2000.0d0) (SINGLE-FLOAT -1000.0 2000.0)), not a (SIGNED-BYTE 64).
;       The result is a (VALUES (OR (RATIONAL (-1999) (1001)) (DOUBLE-FLOAT -1999.0d0 1001.0d0) (SINGLE-FLOAT -1999.0 1001.0)) &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:PROG->
;       (REST SNARK::KEYS SNARK::-> SNARK::R)
;       (SNARK::MFVT SNARK::NODE SNARK::R T)
;       (SNARK::TRIE-NODE-BRANCHES SNARK::NODE SNARK::->NONNIL SNARK::B)
;       (FIRST SNARK::KEYS SNARK::-> SNARK::KEY)
;       (+ SNARK::KEY (- 1 (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)) SNARK::->
;          SNARK::KEY1)
;       (COND
;        ((= SNARK::KEY1 SNARK::KEY)
;         (SNARK-SPARSE-ARRAY:SPAREF SNARK::B SNARK::KEY SNARK::->NONNIL
;                                    SNARK::NODE)
;         (SNARK::MFVT SNARK::NODE SNARK::R NIL))
;        (T
;         (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR SNARK::B :MIN SNARK::KEY1 :MAX
;                                               SNARK::KEY SNARK::->* SNARK::NODE)
;         (SNARK::MFVT SNARK::NODE SNARK::R NIL))))
; --> BLOCK LET LET WHEN IF LET LET 
; ==>
;   (+ SNARK::KEY (- 1 (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (OR (RATIONAL (-1999) (1001)) (DOUBLE-FLOAT -1999.0d0 1001.0d0) (SINGLE-FLOAT -1999.0 1001.0)), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (OR (RATIONAL (-1999) (1001)) (DOUBLE-FLOAT -1999.0d0 1001.0d0) (SINGLE-FLOAT -1999.0 1001.0)), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (= SNARK::KEY1 SNARK::KEY)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-FV-TRIE>= ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.lisp
; in: DEFUN MAP-FV-TRIE>=
;     (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)
; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET REM NTH-VALUE MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a RATIONAL.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ SNARK::KEY0 SNARK::$FV-MAXIMUM-FEATURE-VALUE)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (< SNARK::K SNARK::KEY0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (>= SNARK::K SNARK::KEY)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (< SNARK::K SNARK::KEY0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

;     (>= SNARK::K SNARK::KEY)
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY)
; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF AND IF AND THE IF MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> 
; --> (LAMBDA (SNARK::KEY) (MOD SNARK::KEY (+ SNARK::$FV-MAXIMUM-FEATURE-VALUE 1))) 
; --> SB-C::%FUNCALL MOD LET IF 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-1000) (1000)) (DOUBLE-FLOAT -1000.0d0 1000.0d0) (SINGLE-FLOAT -1000.0 1000.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 2000.0d0) (SINGLE-FLOAT (0.0) 2000.0) (RATIONAL (0) (2000))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:PROG->
;       (SNARK::TRIE-NODE-BRANCHES SNARK::NODE SNARK::->NONNIL SNARK::B)
;       (REST SNARK::KEYS SNARK::-> SNARK::R)
;       (FIRST SNARK::KEYS SNARK::-> SNARK::KEY)
;       (- SNARK::KEY (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY) SNARK::-> SNARK::KEY0)
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES SNARK::B :MAX
;                                                          (+ SNARK::KEY0
;                                                             SNARK::$FV-MAXIMUM-FEATURE-VALUE)
;                                                          SNARK::->* SNARK::NODE
;                                                          SNARK::K)
;       (COND ((< SNARK::K SNARK::KEY0) (SNARK::MFVT SNARK::NODE SNARK::KEYS))
;             ((>= SNARK::K SNARK::KEY) (SNARK::MFVT SNARK::NODE SNARK::R))))
; --> BLOCK LET WHEN IF LET LET LET 
; ==>
;   (- SNARK::KEY (SNARK::FV-TRIE-KEY-VALUE SNARK::KEY))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a (OR (MEMBER 0.0 0.0d0) (RATIONAL (-1000) (2000)) (DOUBLE-FLOAT -1000.0d0 2000.0d0) (SINGLE-FLOAT -1000.0 2000.0)), not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a (OR (MEMBER 0.0 0.0d0) (RATIONAL (-1000) (2000)) (DOUBLE-FLOAT -1000.0d0 2000.0d0) (SINGLE-FLOAT -1000.0 2000.0)), not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::KEY0 SNARK::$FV-MAXIMUM-FEATURE-VALUE)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-trie.fasl written
; compilation finished in 0:00:00.063
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *FEATURE-VECTOR-ROW-INDEX*)
; compiling (DEFVAR *FEATURE-VECTOR-TERM-INDEX*)
; compiling (DEFSTRUCT (FEATURE-VECTOR-INDEX # ...) ...)
; compiling (DEFUN MAKE-FEATURE-VECTOR-ROW-INDEX ...)
; compiling (DEFUN MAKE-FEATURE-VECTOR-TERM-INDEX ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-ENTRY-NUMBER ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-ENTRY-KEYS ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-INSERT ...)
; compiling (DEFUN FEATURE-VECTOR-INDEX-DELETE ...)
; compiling (DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-FORWARD-SUBSUMPTION-CANDIDATES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp
; in: DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-FORWARD-SUBSUMPTION-CANDIDATES
;     (INCF
;      (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-CALLS SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 4)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF
;      (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-COUNT SNARK::INDEX)
;      (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ENTRIES))
; --> LET* 
; ==>
;   (+ (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ENTRIES)
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 5)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-BACKWARD-SUBSUMPTION-CANDIDATES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp
; in: DEFUN MAP-FEATURE-VECTOR-ROW-INDEX-BACKWARD-SUBSUMPTION-CANDIDATES
;     (INCF (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-CALLS SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 6)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-COUNT SNARK::INDEX)
;           (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ENTRIES))
; --> LET* 
; ==>
;   (+ (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ENTRIES)
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 7)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-GENERALIZATIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp
; in: DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-GENERALIZATIONS
;     (FUNCALL FUNCTION SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK:HEAD SNARK::HEAD2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (INCF
;      (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-COUNT SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 5)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF
;      (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-CALLS SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 4)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-INSTANCES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp
; in: DEFUN MAP-FEATURE-VECTOR-TERM-INDEX-INSTANCES
;     (FUNCALL FUNCTION SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK:HEAD SNARK::HEAD2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (INCF (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-COUNT SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 7)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-CALLS SNARK::INDEX))
; --> LET* 
; ==>
;   (+ 1
;      (TRULY-THE INTEGER
;                 (SB-KERNEL:%INSTANCE-REF
;                  (THE SNARK::FEATURE-VECTOR-INDEX #:OBJ) 6)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PRINT-FEATURE-VECTOR-INDEX1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.lisp
; in: DEFUN PRINT-FEATURE-VECTOR-INDEX1
;     (FORMAT T SNARK::FORMAT1 SNARK::CURRENT SNARK::PEAK SNARK::ADDED
;             SNARK::DELETED)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a SIMPLE-STRING.
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a FUNCTION.

;     (FORMAT T SNARK::FORMAT2 SNARK::CURRENT SNARK::PEAK SNARK::ADDED
;             SNARK::DELETED)
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a SIMPLE-STRING.
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a FUNCTION.

;     (FORMAT T SNARK::FORMAT3
;             (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-COUNT
;              SNARK::INDEX)
;             (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-GENERALIZATION-CALLS
;              SNARK::INDEX))
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a SIMPLE-STRING.
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a FUNCTION.

;     (FORMAT T SNARK::FORMAT4
;             (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-COUNT SNARK::INDEX)
;             (SNARK::FEATURE-VECTOR-INDEX-RETRIEVE-INSTANCE-CALLS SNARK::INDEX))
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a SIMPLE-STRING.
; 
; note: unable to optimize due to type uncertainty: The second argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING FUNCTION), not a FUNCTION.

;     (+ SNARK::ENTRIES-COUNT
;        (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ENTRIES))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-FEATURE-VECTOR-ROW-INDEX ...)
; compiling (DEFUN PRINT-FEATURE-VECTOR-TERM-INDEX ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/feature-vector-index.fasl written
; compilation finished in 0:00:00.085
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *TERM-MEMORY*)
; compiling (DEFSTRUCT (TERM-MEMORY-ENTRY # ...) ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFSTRUCT TERM-MEMORY-ENTRY
;     (SNARK-NUMBERING:NONCE)
; --> (LAMBDA NIL (INCF SNARK-NUMBERING::*NONCE*)) SB-C::%FUNCALL INCF SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFSTRUCT (TERM-MEMORY # ...) ...)
; compiling (DEFUN MAKE-TERM-MEMORY-ENTRY1 ...)
; compiling (DEFUN MAKE-TERM-MEMORY ...)
; compiling (DEFUN TERM-MEMORY-ENTRY ...)
; compiling (DEFUN SOME-TERM-MEMORY-ENTRY ...)
; compiling (DEFUN THE-TERM-MEMORY-ENTRY ...)
; compiling (DEFUN TM-STORE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN TM-STORE
;     (ASSERT (EQL SNARK::TERM (SNARK::TME-TERM SNARK::ENTRY)))
; --> TAGBODY LET WHEN IF 
; ==>
;   (EQL #:TEMP346 #:TEMP347)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; ==>
;   (EQL #:TEMP344 #:TEMP345)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN TM-REMOVE-ENTRY ...)
; compiling (DEFUN RETRIEVE-GENERALIZATION-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-GENERALIZATION-ENTRIES
;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :GENERALIZATION SNARK::TERM SUBST SNARK::->*
;                              SNARK::ENTRY)
;       (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :GENERALIZATION SNARK::TERM SUBST SNARK::->*
;                              SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET BLOCK LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 2))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 2))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 1))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-FEATURE-VECTOR-TERM-INDEX-GENERALIZATIONS SNARK::TERM SUBST
;                                                             SNARK::->*
;                                                             SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET BLOCK LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 2))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::TM-RETRIEVE-GENERALIZATION-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 1))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RETRIEVE-INSTANCE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-INSTANCE-ENTRIES
;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :INSTANCE SNARK::TERM SUBST SNARK::->* SNARK::ENTRY)
;       (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :INSTANCE SNARK::TERM SUBST SNARK::->* SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

; --> BLOCK FLET SNARK::MAP-TRIE-INDEX 
; --> (LAMBDA (SNARK::CC TYPE SNARK::TERM &OPTIONAL SUBST) (ECASE TYPE (:GENERALIZATION (SNARK::MAP-TRIE-INDEX-GENERALIZATION-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:INSTANCE (SNARK::MAP-TRIE-INDEX-INSTANCE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:UNIFIABLE (SNARK::MAP-TRIE-INDEX-UNIFIABLE-ENTRIES SNARK::CC SNARK::TERM SUBST)) (:VARIANT (SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES SNARK::CC SNARK::TERM SUBST)))) 
; --> SB-C::%FUNCALL ECASE LET COND IF COND IF COND IF COND IF PROGN 
; --> SNARK::MAP-TRIE-INDEX-VARIANT-ENTRIES 
; ==>
;   SNARK::TERM
; 
; note: deleting unreachable code

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 4))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 4))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-TRIE-INDEX :INSTANCE SNARK::TERM SUBST SNARK::->* SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET BLOCK LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 4))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 4))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 3))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:PROG->
;       (SNARK::MAP-FEATURE-VECTOR-TERM-INDEX-INSTANCES SNARK::TERM SUBST
;                                                       SNARK::->* SNARK::ENTRY)
;       (FUNCALL SNARK::TEST SNARK::ENTRY SNARK::->NONNIL SNARK::TEST-VALUE)
;       (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE))
; --> BLOCK FLET BLOCK LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 4))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::TM-RETRIEVE-INSTANCE-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 3))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RETRIEVE-UNIFIABLE-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-UNIFIABLE-ENTRIES
;     (INCF (SNARK::TM-RETRIEVE-UNIFIABLE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 6))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-UNIFIABLE-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 5))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF (SNARK::TM-RETRIEVE-UNIFIABLE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 6))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-UNIFIABLE-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 6))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::TM-RETRIEVE-UNIFIABLE-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 5))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RETRIEVE-RESOLVABLE-ENTRIES ...)
; compiling (DEFUN RETRIEVE-PARAMODULATABLE-ENTRIES ...)
; compiling (DEFUN RETRIEVE-VARIANT-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-VARIANT-ENTRIES
;     (INCF (SNARK::TM-RETRIEVE-VARIANT-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 8))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-VARIANT-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 7))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF (SNARK::TM-RETRIEVE-VARIANT-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 8))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-VARIANT-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 8))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::TM-RETRIEVE-VARIANT-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 7))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RETRIEVE-ALL-ENTRIES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.lisp
; in: DEFUN RETRIEVE-ALL-ENTRIES
;     (INCF (SNARK::TM-RETRIEVE-ALL-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 10))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY SNARK::TEST-VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-ALL-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 9))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF (SNARK::TM-RETRIEVE-ALL-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 10))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::CC SNARK::ENTRY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF (SNARK::TM-RETRIEVE-ALL-COUNT SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 10))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF (SNARK::TM-RETRIEVE-ALL-CALLS SNARK::*TERM-MEMORY*))
; --> LET* 
; ==>
;   (+ 1 (SB-KERNEL:%INSTANCE-REF (THE SNARK::TERM-MEMORY #:OBJ) 9))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PRINT-TERM-MEMORY ...)
; compiling (DEFUN TME-USELESS-P ...)
; compiling (DEFMACRO ROWS-CONTAINING-ATOM-POSITIVELY ...)
; compiling (DEFMACRO ROWS-CONTAINING-ATOM-NEGATIVELY ...)
; compiling (DEFMACRO ROWS-CONTAINING-PARAMODULATABLE-EQUALITY ...)
; compiling (DEFMACRO ROWS-CONTAINING-TERM ...)
; compiling (DEFMACRO REWRITES ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-TERM ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-ATOM-POSITIVELY ...)
; compiling (DEFUN INSERT-INTO-ROWS-CONTAINING-ATOM-NEGATIVELY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/term-memory.fasl written
; compilation finished in 0:00:00.197
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN DEPTH
;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-5 #:LOOP-MAXMIN-4)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-10 #:LOOP-MAXMIN-9)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-15 #:LOOP-MAXMIN-14)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (MAX (SNARK::DEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;             (SNARK::DEPTH (SNARK-LISP:CDRC SNARK::X) SUBST)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (MAX (SNARK::DEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::DEPTH (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-10 #:LOOP-MAXMIN-9)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-15 #:LOOP-MAXMIN-14)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MAXIMIZE (SNARK::DEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-5 #:LOOP-MAXMIN-4)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (MAX (SNARK::DEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::DEPTH (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ 1
;        (MAX (SNARK::DEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;             (SNARK::DEPTH (SNARK-LISP:CDRC SNARK::X) SUBST)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MINDEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN MINDEPTH
;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-64 #:LOOP-MAXMIN-63)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-69 #:LOOP-MAXMIN-68)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-74 #:LOOP-MAXMIN-73)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (+ 1
;        (MIN (SNARK::MINDEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;             (SNARK::MINDEPTH (SNARK-LISP:CDRC SNARK::X) SUBST)))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (MIN (SNARK::MINDEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::MINDEPTH (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-69 #:LOOP-MAXMIN-68)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-74 #:LOOP-MAXMIN-73)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ 1
;        (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;              SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;           SNARK::MINIMIZE (SNARK::MINDEPTH SNARK::X1 SUBST SNARK:HEAD))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE < 
; --> IF 
; ==>
;   (< #:LOOP-MAXMIN-TEMP-64 #:LOOP-MAXMIN-63)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (MIN (SNARK::MINDEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::MINDEPTH (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ 1
;        (MIN (SNARK::MINDEPTH (SNARK-LISP:CARC SNARK::X) SUBST)
;             (SNARK::MINDEPTH (SNARK-LISP:CDRC SNARK::X) SUBST)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE CONSTANTLY-ONE ...)
; compiling (DEFINLINE CONSTANTLY-NIL ...)
; compiling (DEFINLINE VARIABLE-WEIGHT1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFINLINE VARIABLE-WEIGHT1
;     (FUNCALL SNARK::W SNARK::VARIABLE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFMACRO WEIGHT-MACRO ...)
; compiling (DEFUN WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN WEIGHT
;     (SNARK::WEIGHT-MACRO SNARK::WEIGHT SNARK::CONSTANT-WEIGHT
;                          SNARK::VARIABLE-WEIGHT1 SNARK::FUNCTION-WEIGHT
;                          SNARK::FUNCTION-WEIGHT-CODE)
; --> SNARK:DEREFERENCE COND IF PROGN SNARK::VARIABLE-WEIGHT1 
; --> (LAMBDA (SNARK::VARIABLE) (LET ((SNARK::W (SNARK:VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK::VARIABLE)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + * + 
; ==>
;   (LENGTH (SNARK-LISP:RREST SNARK:ARGS))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + 
; ==>
;   (* (SNARK::FUNCTION-WEIGHT SNARK:HEAD)
;      (+ 1 (LENGTH (SNARK-LISP:RREST SNARK:ARGS))))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> SNARK:DEREFERENCE COND IF COND IF COND THE PROGN SNARK::CONSTANT-WEIGHT 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> COND THE PROGN + LOOP BLOCK LET SB-LOOP::WITH-SUM-COUNT LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-249 (SNARK::WEIGHT SNARK::X1 SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> COND THE PROGN 
; ==>
;   (+
;    (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;          SNARK::SUM (SNARK::WEIGHT SNARK::X1 SUBST))
;    (SNARK::FUNCTION-WEIGHT SNARK:HEAD))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + LOOP BLOCK LET SB-LOOP::WITH-SUM-COUNT LET SB-LOOP::LOOP-BODY 
; --> TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-247 (SNARK::WEIGHT SNARK::X1 SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + 
; ==>
;   (* (SNARK::FUNCTION-WEIGHT SNARK:HEAD)
;      (+ 1 (LENGTH (SNARK-LISP:RREST SNARK:ARGS))))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET 
; ==>
;   (+
;    (LOOP SNARK::FOR SNARK::X1 SNARK::IN SNARK:ARGS
;          SNARK::SUM (SNARK::WEIGHT SNARK::X1 SUBST))
;    (* (SNARK::FUNCTION-WEIGHT SNARK:HEAD)
;       (+ 1 (LENGTH (SNARK-LISP:RREST SNARK:ARGS)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF + + 
; ==>
;   (+ (SNARK::WEIGHT (SNARK-LISP:CARC SNARK::X) SUBST)
;      (SNARK::WEIGHT (SNARK-LISP:CDRC SNARK::X) SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF + 
; ==>
;   (+
;    (+ (SNARK::WEIGHT (SNARK-LISP:CARC SNARK::X) SUBST)
;       (SNARK::WEIGHT (SNARK-LISP:CDRC SNARK::X) SUBST))
;    (SNARK::FUNCTION-WEIGHT SNARK::*CONS*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN SIZE
;     (SNARK::WEIGHT-MACRO SNARK::SIZE SNARK::CONSTANTLY-ONE SNARK::CONSTANTLY-ONE
;                          SNARK::CONSTANTLY-ONE SNARK::CONSTANTLY-NIL)
; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + * + 
; ==>
;   (LENGTH (SNARK-LISP:RREST SNARK:ARGS))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> COND THE PROGN 
; ==>
;   (+
;    (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;          SNARK::SUM (SNARK::SIZE SNARK::X1 SUBST))
;    (SNARK::CONSTANTLY-ONE SNARK:HEAD))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET TAGBODY 
; --> UNLESS IF PROGN LET TAGBODY LET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF + 
; ==>
;   (+
;    (+ (SNARK::SIZE (SNARK-LISP:CARC SNARK::X) SUBST)
;       (SNARK::SIZE (SNARK-LISP:CDRC SNARK::X) SUBST))
;    (SNARK::CONSTANTLY-ONE SNARK::*CONS*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> COND THE PROGN + LOOP BLOCK LET SB-LOOP::WITH-SUM-COUNT LET 
; --> SB-LOOP::LOOP-BODY TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-302 (SNARK::SIZE SNARK::X1 SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> COND THE PROGN 
; ==>
;   (+
;    (LOOP SNARK::FOR SNARK::X1 SNARK::IN (SNARK::ARGSA SNARK::X)
;          SNARK::SUM (SNARK::SIZE SNARK::X1 SUBST))
;    (SNARK::CONSTANTLY-ONE SNARK:HEAD))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET + LOOP BLOCK LET SB-LOOP::WITH-SUM-COUNT LET SB-LOOP::LOOP-BODY 
; --> TAGBODY SETQ THE 
; ==>
;   (+ #:LOOP-SUM-300 (SNARK::SIZE SNARK::X1 SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF LET DOLIST BLOCK LET COND IF 
; --> PROGN LET 
; ==>
;   (+
;    (LOOP SNARK::FOR SNARK::X1 SNARK::IN SNARK:ARGS
;          SNARK::SUM (SNARK::SIZE SNARK::X1 SUBST))
;    (* (SNARK::CONSTANTLY-ONE SNARK:HEAD)
;       (+ 1 (LENGTH (SNARK-LISP:RREST SNARK:ARGS)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF + + 
; ==>
;   (+ (SNARK::SIZE (SNARK-LISP:CARC SNARK::X) SUBST)
;      (SNARK::SIZE (SNARK-LISP:CDRC SNARK::X) SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; --> SNARK:DEREFERENCE COND IF COND IF PROGN IF + 
; ==>
;   (+
;    (+ (SNARK::SIZE (SNARK-LISP:CARC SNARK::X) SUBST)
;       (SNARK::SIZE (SNARK-LISP:CDRC SNARK::X) SUBST))
;    (SNARK::CONSTANTLY-ONE SNARK::*CONS*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN WEIGH-FIRST-TWO-ARGUMENTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN WEIGH-FIRST-TWO-ARGUMENTS
;     (+ (SNARK::WEIGHT (FIRST SNARK:ARGS) SUBST)
;        (SNARK::WEIGHT (SECOND SNARK:ARGS) SUBST)
;        (SNARK::FUNCTION-WEIGHT (SNARK::HEADA SNARK::X)))
; --> + 
; ==>
;   (+ (SNARK::WEIGHT (FIRST SNARK:ARGS) SUBST)
;      (SNARK::WEIGHT (SECOND SNARK:ARGS) SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+
;    (+ (SNARK::WEIGHT (FIRST SNARK:ARGS) SUBST)
;       (SNARK::WEIGHT (SECOND SNARK:ARGS) SUBST))
;    (SNARK::FUNCTION-WEIGHT (SNARK::HEADA SNARK::X)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN MAXIMUM-ARGUMENT-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN MAXIMUM-ARGUMENT-WEIGHT
;     (LOOP SNARK::FOR SNARK::ARG SNARK::IN SNARK:ARGS
;           SNARK::MAXIMIZE (IF (AND SNARK::HEAD-IF-ASSOCIATIVE
;                                    (SNARK:DEREFERENCE SNARK::ARG SUBST
;                                                       :IF-COMPOUND-APPL
;                                                       (EQ
;                                                        SNARK::HEAD-IF-ASSOCIATIVE
;                                                        #)))
;                               (SNARK::MAXIMUM-ARGUMENT-WEIGHT
;                                (SNARK::ARGSA SNARK::ARG) SUBST
;                                SNARK::HEAD-IF-ASSOCIATIVE)
;                               (SNARK::WEIGHT SNARK::ARG SUBST)))
; --> BLOCK LET SB-LOOP::WITH-MINIMAX-VALUE LET SB-LOOP::LOOP-BODY TAGBODY 
; --> SB-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE PROGN WHEN IF OR LET IF OR THE > 
; --> IF 
; ==>
;   (> #:LOOP-MAXMIN-TEMP-368 #:LOOP-MAXMIN-367)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN WEIGHTM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN WEIGHTM
;     (MAX (SNARK::WEIGHT (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::WEIGHT (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (+
;      (SNARK::MAXIMUM-ARGUMENT-WEIGHT (SNARK::ARGSA SNARK::X) SUBST
;                                      (AND
;                                       (SNARK::FUNCTION-ASSOCIATIVE SNARK:HEAD)
;                                       SNARK:HEAD))
;      (SNARK::FUNCTION-WEIGHT SNARK:HEAD))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MAX (SNARK::WEIGHT (SNARK-LISP:CARC SNARK::X) SUBST)
;          (SNARK::WEIGHT (SNARK-LISP:CDRC SNARK::X) SUBST))
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+
;      (MAX (SNARK::WEIGHT (SNARK-LISP:CARC SNARK::X) SUBST)
;           (SNARK::WEIGHT (SNARK-LISP:CDRC SNARK::X) SUBST))
;      (SNARK::FUNCTION-WEIGHT SNARK::*CONS*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFSTRUCT (SYMBOL-COUNT # ...) ...)
; compiling (DEFUN SYMBOL-COUNT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN SYMBOL-COUNT
;     (LENGTH (SNARK-LISP:RREST SNARK:ARGS))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (SNARK::SYMBOL-COUNT1 SNARK::*CONS* 1)
; --> LET* ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; --> LET* IF INCF LET* 
; ==>
;   (+ COUNT (CDR #:V492))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::SYMBOL-COUNT1 SNARK::X 1)
; --> LET* ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; --> LET* IF INCF LET* 
; ==>
;   (+ COUNT (CDR #:V499))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::SYMBOL-COUNT1 SNARK:HEAD
;      (IF (SNARK::FUNCTION-ASSOCIATIVE SNARK:HEAD)
;          (+ 1 (LENGTH (SNARK-LISP:RREST SNARK:ARGS)))
;          1))
; --> LET* IF INCF LET* 
; ==>
;   (+ COUNT (CDR #:V483))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK::SYMBOL-COUNT1 SNARK::*CONS* 1)
; --> LET* IF INCF LET* 
; ==>
;   (+ COUNT (CDR #:V492))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::SYMBOL-COUNT1 SNARK::X 1)
; --> LET* IF INCF LET* 
; ==>
;   (+ COUNT (CDR #:V499))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFINLINE SYMBOL-COUNT-NOT-GREATERP1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFINLINE SYMBOL-COUNT-NOT-GREATERP1
;     (ASSOC (SNARK-LISP:CARC SNARK::V1) SNARK::ALIST2)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN SYMBOL-COUNT-NOT-GREATERP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN SYMBOL-COUNT-NOT-GREATERP
;     (SNARK::SYMBOL-COUNT-NOT-GREATERP1 SNARK::SCOUNT1 SNARK::SCOUNT2)
; --> 
; --> (LAMBDA (SNARK::SCOUNT1 SNARK::SCOUNT2) (LET ((SNARK::ALIST2 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT2))) (DOLIST (SNARK::V1 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT1) T) (LET ((SNARK::V2 #)) (WHEN (OR # #) (RETURN NIL)))))) 
; --> SB-C::%FUNCALL LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> LET ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN WFF-SYMBOL-COUNTS ...)
; compiling (DEFUN WFF-SYMBOL-COUNTS-NOT-GREATERP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.lisp
; in: DEFUN WFF-SYMBOL-COUNTS-NOT-GREATERP
;     (SNARK::SYMBOL-COUNT-NOT-GREATERP1 SNARK::POSCOUNT1 SNARK::POSCOUNT2)
; --> 
; --> (LAMBDA (SNARK::SCOUNT1 SNARK::SCOUNT2) (LET ((SNARK::ALIST2 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT2))) (DOLIST (SNARK::V1 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT1) T) (LET ((SNARK::V2 #)) (WHEN (OR # #) (RETURN NIL)))))) 
; --> SB-C::%FUNCALL LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> LET ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK::SYMBOL-COUNT-NOT-GREATERP1 SNARK::NEGCOUNT1 SNARK::NEGCOUNT2)
; --> 
; --> (LAMBDA (SNARK::SCOUNT1 SNARK::SCOUNT2) (LET ((SNARK::ALIST2 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT2))) (DOLIST (SNARK::V1 (SNARK::SYMBOL-COUNT-ALIST SNARK::SCOUNT1) T) (LET ((SNARK::V2 #)) (WHEN (OR # #) (RETURN NIL)))))) 
; --> SB-C::%FUNCALL LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> LET ASSOC 
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/weight.fasl written
; compilation finished in 0:00:00.159
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *POLARITY*)
; compiling (DEFUN FIFO ...)
; compiling (DEFUN LIFO ...)
; compiling (DEFUN ROW-DEPTH ...)
; compiling (DEFUN ROW-SIZE ...)
; compiling (DEFUN ROW-WEIGHT ...)
; compiling (DEFUN ROW-SIZE+DEPTH ...)
; compiling (DEFUN ROW-WEIGHT+DEPTH ...)
; compiling (DEFUN ROW-SIZE+DEPTH+LEVEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-SIZE+DEPTH+LEVEL
;     (+ (SNARK::WFF-SIZE+DEPTH (SNARK:ROW-WFF SNARK:ROW))
;        (SNARK:ROW-LEVEL SNARK:ROW))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ROW-WEIGHT+DEPTH+LEVEL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-WEIGHT+DEPTH+LEVEL
;     (+ (SNARK::WFF-WEIGHT+DEPTH (SNARK:ROW-WFF SNARK:ROW))
;        (SNARK:ROW-LEVEL SNARK:ROW))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ROW-PRIORITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-PRIORITY
;     (= 0 SNARK::F)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* SNARK::F (SNARK::WFF-SIZE (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (= 0 SNARK::F)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* SNARK::F (SNARK::WFF-WEIGHT (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (= 0 SNARK::F)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* SNARK::F (SNARK::WFF-DEPTH (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (= 0 SNARK::F)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (* SNARK::F (SNARK::WFF-SIZE (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::F (SNARK::WFF-WEIGHT (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-SIZE-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-SIZE #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-WEIGHT-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-WEIGHT #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-DEPTH-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-DEPTH #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-LEVEL-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW)))))
; --> + + 
; ==>
;   (+
;    (LET ((SNARK::F (SNARK:ROW-PRIORITY-SIZE-FACTOR?)))
;      (IF (= 0 SNARK::F)
;          0
;          (* SNARK::F (SNARK::WFF-SIZE #))))
;    (LET ((SNARK::F (SNARK:ROW-PRIORITY-WEIGHT-FACTOR?)))
;      (IF (= 0 SNARK::F)
;          0
;          (* SNARK::F (SNARK::WFF-WEIGHT #)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::F (SNARK::WFF-DEPTH (SNARK:ROW-WFF SNARK:ROW)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-SIZE-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-SIZE #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-WEIGHT-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-WEIGHT #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-DEPTH-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-DEPTH #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-LEVEL-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW)))))
; --> + 
; ==>
;   (+
;    (+
;     (LET ((SNARK::F #))
;       (IF (= 0 SNARK::F)
;           0
;           (* SNARK::F #)))
;     (LET ((SNARK::F #))
;       (IF (= 0 SNARK::F)
;           0
;           (* SNARK::F #))))
;    (LET ((SNARK::F (SNARK:ROW-PRIORITY-DEPTH-FACTOR?)))
;      (IF (= 0 SNARK::F)
;          0
;          (* SNARK::F (SNARK::WFF-DEPTH #)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-SIZE-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-SIZE #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-WEIGHT-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-WEIGHT #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-DEPTH-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK::WFF-DEPTH #))))
;      (LET ((SNARK::F (SNARK:ROW-PRIORITY-LEVEL-FACTOR?)))
;        (IF (= 0 SNARK::F)
;            0
;            (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW)))))
; ==>
;   (+
;    (+
;     (+
;      (LET (#)
;        (IF #
;            0
;            #))
;      (LET (#)
;        (IF #
;            0
;            #)))
;     (LET ((SNARK::F #))
;       (IF (= 0 SNARK::F)
;           0
;           (* SNARK::F #))))
;    (LET ((SNARK::F (SNARK:ROW-PRIORITY-LEVEL-FACTOR?)))
;      (IF (= 0 SNARK::F)
;          0
;          (* SNARK::F (SNARK:ROW-LEVEL SNARK:ROW)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ROW-WFF&ANSWER-WEIGHT+DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-WFF&ANSWER-WEIGHT+DEPTH
;     (+ (SNARK::WFF-WEIGHT+DEPTH (SNARK:ROW-WFF SNARK:ROW))
;        (SNARK::WFF-WEIGHT+DEPTH (SNARK:ROW-ANSWER SNARK:ROW)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ROW-NEG ...)
; compiling (DEFUN ROW-NEG-SIZE+DEPTH ...)
; compiling (DEFUN ROW-ANSWER-WEIGHT ...)
; compiling (DEFUN WFF-DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-DEPTH
;     (DEFUN SNARK::WFF-DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::DEPTH ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (SNARK::DEPTH ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

; compiling (DEFUN WFF-SIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-SIZE
;     (DEFUN SNARK::WFF-SIZE
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::SIZE ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-SIZE
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-SIZE
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (SNARK::SIZE ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

; compiling (DEFUN WFF-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-WEIGHT
;     (DEFUN SNARK::WFF-WEIGHT
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (SNARK::WEIGHT ATOM SUBST)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-WEIGHT
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-WEIGHT
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (SNARK::WEIGHT ATOM SUBST))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

; compiling (DEFUN WFF-SIZE+DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-SIZE+DEPTH
;     (DEFUN SNARK::WFF-SIZE+DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (+ (SNARK::SIZE ATOM SUBST) (SNARK::DEPTH ATOM SUBST))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-SIZE+DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-SIZE+DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (+ (SNARK::SIZE ATOM SUBST) (SNARK::DEPTH ATOM SUBST)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

;     (+ (SNARK::SIZE ATOM SUBST) (SNARK::DEPTH ATOM SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN WFF-WEIGHT+DEPTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-WEIGHT+DEPTH
;     (DEFUN SNARK::WFF-WEIGHT+DEPTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (+ (SNARK::WEIGHT ATOM SUBST) (SNARK::DEPTH ATOM SUBST))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-WEIGHT+DEPTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-WEIGHT+DEPTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (+ (SNARK::WEIGHT ATOM SUBST) (SNARK::DEPTH ATOM SUBST)))))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

;     (+ (SNARK::WEIGHT ATOM SUBST) (SNARK::DEPTH ATOM SUBST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN WFF-LENGTH ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-LENGTH
;     (DEFUN SNARK::WFF-LENGTH
;            (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (SNARK-LISP:PROG->
;         (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM SUBST)
;         (DECLARE (IGNORE ATOM SUBST))
;         1))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA 
; ==>
;   #'(SB-INT:NAMED-LAMBDA SNARK::WFF-LENGTH
;         (SNARK::WFF &OPTIONAL SUBST &KEY (SNARK::POLARITY :POS))
;       (BLOCK SNARK::WFF-LENGTH
;         (SNARK-LISP:PROG->
;           (SNARK::WFF-SIZE* SNARK::WFF SUBST SNARK::POLARITY SNARK::->* ATOM
;                             SUBST)
;           (DECLARE (IGNORE ATOM SUBST))
;           1)))
; 
; caught STYLE-WARNING:
;   &OPTIONAL and &KEY found in the same lambda list: (WFF &OPTIONAL SUBST &KEY (POLARITY :POS))

; compiling (DEFUN WFF-SIZE* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN WFF-SIZE*
;     (FUNCALL SNARK::ATOM-SIZE-FUN SNARK::WFF SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ATOM-SIZE-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (< SNARK::M SNARK::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (FUNCALL SNARK::ATOM-SIZE-FUN SNARK::WFF SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ATOM-SIZE-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :POS)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :NEG)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS)
;          (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;          (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :POS)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :NEG))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (THIRD SNARK:ARGS) SUBST :NEG)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :NEG))
;      (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;         (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::Y SUBST :POS)))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS)
;          (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MIN (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :POS)
;          (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :NEG))
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (FIRST SNARK:ARGS) SUBST :NEG)
;        (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN (SECOND SNARK:ARGS) SUBST :POS))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (INCF SNARK::N
;           (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::ARG SUBST
;                             SNARK::*POLARITY*))
; --> SETQ THE 
; ==>
;   (+ (SNARK::WFF-SIZE* SNARK::ATOM-SIZE-FUN SNARK::ARG SUBST SNARK::*POLARITY*)
;      SNARK::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (< SNARK::M SNARK::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN WFF-NEG ...)
; compiling (DEFUN ROW-ARGUMENT-COUNT-LIMIT-EXCEEDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-ARGUMENT-COUNT-LIMIT-EXCEEDED
;     (SNARK-LISP:PROG->
;       (SNARK:ROW-ARGUMENT-COUNT-LIMIT? SNARK::->NONNIL SNARK::LIM)
;       (QUOTE NIL SNARK::-> SNARK::ARGUMENTS)
;       (SNARK::MAP-TERMS-IN-WFF (SNARK:ROW-WFF SNARK:ROW) SNARK::->* SNARK::TERM
;                                SNARK::POLARITY)
;       (DECLARE (IGNORE SNARK::POLARITY))
;       (COND ((SNARK::MEMBER-P SNARK::TERM SNARK::ARGUMENTS))
;             ((EQL 0 SNARK::LIM) (RETURN-FROM SNARK-LISP:PROG-> T))
;             (T (DECF SNARK::LIM) (PUSH SNARK::TERM SNARK::ARGUMENTS))))
; ==>
;   (BLOCK SNARK-LISP:PROG->
;     (LET ((SNARK::LIM (SNARK:ROW-ARGUMENT-COUNT-LIMIT?)))
;       (WHEN SNARK::LIM
;         (LET (#)
;           (FLET #
;             #
;             #)))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM PROG-> T). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (DECF SNARK::LIM)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ROW-WEIGHT-LIMIT-EXCEEDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-WEIGHT-LIMIT-EXCEEDED
;     (< SNARK::LIM (SNARK:ROW-WEIGHT SNARK:ROW))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT-EXCEEDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-WEIGHT-BEFORE-SIMPLIFICATION-LIMIT-EXCEEDED
;     (< SNARK::LIM (SNARK:ROW-WEIGHT SNARK:ROW))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN ROW-PROOF-LENGTH-LIMIT-EXCEEDED ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN ROW-PROOF-LENGTH-LIMIT-EXCEEDED
;     (= SNARK::LIM-1 (SNARK-SPARSE-ARRAY:SPARSE-VECTOR-COUNT SNARK::ROW-NUMBERS))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (DEFUN SNARK::ROW-PROOF-LENGTH-LIMIT-EXCEEDED (SNARK:ROW SNARK::LIM)
;       (COND
;        ((MEMBER (SNARK:ROW-REASON SNARK:ROW)
;                 '(SNARK:ASSERTION SNARK:ASSUMPTION SNARK:NEGATED_CONJECTURE))
;         NIL)
;        (T
;         (LET (# #)
;           (LABELS #
;             #)))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::ROW-PROOF-LENGTH-LIMIT-EXCEEDED
;     (COND
;      ((MEMBER (SNARK:ROW-REASON SNARK:ROW)
;               '(SNARK:ASSERTION SNARK:ASSUMPTION SNARK:NEGATED_CONJECTURE))
;       NIL)
;      (T
;       (LET (# #)
;         (LABELS #
;           #)))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM ROW-PROOF-LENGTH-LIMIT-EXCEEDED T). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (- SNARK::LIM 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS
;     (MAX MAX SNARK::MAX1)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN MIN SNARK::MIN1)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (+ SNARK::MAX1 SNARK::MAX2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::MIN1 SNARK::MIN2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::MAX1 SNARK::MAX2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::MIN1 SNARK::MIN2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ MAX SNARK::MAX1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ MIN SNARK::MIN1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MAX MAX SNARK::MAX1)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN MIN SNARK::MIN1)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS-NEG ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.lisp
; in: DEFUN MAXIMUM-AND-MINIMUM-CLAUSE-LENGTHS-NEG
;     (MAX SNARK::MAX1 SNARK::MAX2)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::MIN1 SNARK::MIN2)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX SNARK::MAX1 SNARK::MAX2)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN SNARK::MIN1 SNARK::MIN2)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX MAX SNARK::MAX1)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MIN MIN SNARK::MIN1)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (MAX SNARK::MAX1 SNARK::MAX2)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN SNARK::MIN1 SNARK::MIN2)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MAX SNARK::MAX1 SNARK::MAX2)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN SNARK::MIN1 SNARK::MIN2)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MAX MAX SNARK::MAX1)
; --> LET LET IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (MIN MIN SNARK::MIN1)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (+ MAX SNARK::MAX1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ MIN SNARK::MIN1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/eval.fasl written
; compilation finished in 0:00:00.178
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SKOLEM-FUNCTION-ALIST* ...)
; compiling (DEFVAR *INPUT-WFF* ...)
; compiling (DEFVAR *INPUT-WFF-SUBSTITUTION*)
; compiling (DEFVAR *INPUT-WFF-SUBSTITUTION2*)
; compiling (DEFVAR *INPUT-WFF-NEW-ANTECEDENTS*)
; compiling (DEFVAR *INPUT-WFF-MODAL-PREFIX*)
; compiling (DEFVAR *INPUT-PROPOSITION-VARIABLES* ...)
; compiling (DEFUN KEYWORD-ARGUMENT-LIST-P ...)
; compiling (DEFUN CAN-BE-NAME1 ...)
; compiling (DEFUN CAN-BE-FREE-VARIABLE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-FREE-VARIABLE-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a free variable." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-VARIABLE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-VARIABLE-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a variable." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-CONSTANT-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-CONSTANT-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a constant." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-CONSTANT-ALIAS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-CONSTANT-ALIAS
;     (FUNCALL SNARK::ACTION "~S cannot be the alias of a constant." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-PROPOSITION-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-PROPOSITION-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a proposition." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-FUNCTION-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-FUNCTION-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a function." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-RELATION-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-RELATION-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a relation." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-LOGICAL-SYMBOL-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-LOGICAL-SYMBOL-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a logical symbol." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-SORT-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-SORT-NAME
;     (FIND (SNARK:VARIABLE-SORT-MARKER?) SNARK::S)
; --> NTH-VALUE MULTIPLE-VALUE-BIND LET 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to expand inline because: upgraded array element type not known at compile time
; 
; note: unable to optimize due to type uncertainty: The first argument is a T, not a CHARACTER.

;     (FUNCALL SNARK::ACTION "~S cannot be the name of a sort." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-ROW-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-ROW-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a row." SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CAN-BE-CONSTANT-OR-FUNCTION-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CAN-BE-CONSTANT-OR-FUNCTION-NAME
;     (FUNCALL SNARK::ACTION "~S cannot be the name of a constant or function."
;              SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ACTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CHECK-USABLE-HEAD1 ...)
; compiling (DEFUN CERROR1 ...)
; compiling (DEFUN CERROR2 ...)
; compiling (DEFUN VARIABLE-SYMBOL-PREFIXED-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN VARIABLE-SYMBOL-PREFIXED-P
;     (STRING SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (CHAR SNARK::S SNARK::POS)
; --> AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to optimize because: Upgraded element type of array is not known at compile time.

;     (STRING SNARK::PREFIX)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (STRING= SNARK::PREFIX SNARK::S :START2 SNARK::POS :END2
;              (+ SNARK::POS SNARK::PLEN))
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-BASE-STRING.The second argument is a STRING, not a SIMPLE-BASE-STRING.
; 
; note: doing unsigned word to integer coercion (cost 20)

;     (SETF SNARK::POS (+ SNARK::POS SNARK::PLEN))
; ==>
;   (SETQ SNARK::POS (+ SNARK::POS SNARK::PLEN))
; 
; note: doing signed word to integer coercion (cost 20) to POS

; compiling (DEFUN UNSORTABLE-VARIABLE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN UNSORTABLE-VARIABLE-NAME
;     (POSITION-IF-NOT #'DIGIT-CHAR-P SNARK::S :START (+ 1 SNARK::V))
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF-NOT
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to expand inline because: upgraded array element type not known at compile time

; compiling (DEFUN SORT-FROM-VARIABLE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN SORT-FROM-VARIABLE-NAME
;     (POSITION (SNARK:VARIABLE-SORT-MARKER?) SNARK::S :FROM-END T)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION SB-C::ITEM SEQUENCE SB-C::FROM-END SB-C::START
;                             SB-C::END
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY)
;                             (SB-KERNEL:EFFECTIVE-FIND-POSITION-TEST SB-C::TEST
;                                                                     SB-C::TEST-NOT))
; 
; note: unable to expand inline because: upgraded array element type not known at compile time
; 
; note: unable to optimize due to type uncertainty: The first argument is a T, not a CHARACTER.

;     (POSITION-IF-NOT #'DIGIT-CHAR-P SNARK::S :FROM-END T)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%FIND-POSITION-IF-NOT
;    (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SB-C::PREDICATE) SEQUENCE SB-C::FROM-END
;    SB-C::START SB-C::END (SB-KERNEL:EFFECTIVE-FIND-POSITION-KEY SB-C::KEY))
; 
; note: unable to expand inline because: upgraded array element type not known at compile time

; compiling (DEFUN DECLARE-VARIABLE ...)
; compiling (DEFUN INPUT-WFF ...)
; compiling (DEFUN INPUT-WFF1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-WFF1
;     (FUNCALL SNARK::FUN SNARK:HEAD (REST SNARK::WFF) SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN INPUT-WFFS1 ...)
; compiling (DEFUN INPUT-WFFS2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-WFFS2
;     (SNARK-LISP:LCONS
;      (SNARK::INPUT-WFF1 (FIRST SNARK::WFFS)
;                         (SNARK::MAP-POLARITY (FIRST SNARK::POLARITY-MAP)
;                                              SNARK::POLARITY))
;      (SNARK::INPUT-WFFS2 (REST SNARK::WFFS) SNARK::POLARITY
;                          (REST SNARK::POLARITY-MAP))
;      SNARK::WFFS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G685 #:G687)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G685 #:G687)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN INPUT-QUOTED-CONSTANT ...)
; compiling (DEFUN INPUT-EQUALITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-EQUALITY
;     (LENGTH (REST (FIRST SNARK:ARGS)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH (REST (SECOND SNARK:ARGS)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN INPUT-DISEQUALITY ...)
; compiling (DEFUN INPUT-NEGATION ...)
; compiling (DEFUN INPUT-CONJUNCTION ...)
; compiling (DEFUN INPUT-DISJUNCTION ...)
; compiling (DEFUN INPUT-IMPLICATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-IMPLICATION
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN INPUT-REVERSE-IMPLICATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-REVERSE-IMPLICATION
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN INPUT-KIF-FORWARD-IMPLICATION ...)
; compiling (DEFUN INPUT-KIF-BACKWARD-IMPLICATION ...)
; compiling (DEFUN INPUT-NAND ...)
; compiling (DEFUN INPUT-NOR ...)
; compiling (DEFUN INPUT-LISP-LIST ...)
; compiling (DEFUN INPUT-LISP-LIST* ...)
; compiling (DEFUN INPUT-FUNCTION-AS-RELATION-RESULT-SORT2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-FUNCTION-AS-RELATION-RESULT-SORT2
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN INPUT-FUNCTION-AS-RELATION-RESULT-SORT ...)
; compiling (DEFUN INPUT-FUNCTION-AS-RELATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-FUNCTION-AS-RELATION
;     (MAKE-SYMBOL
;      (SNARK-LISP:TO-STRING (FIRST (SNARK:VARIABLE-SYMBOL-PREFIXES?))
;                            (SNARK-NUMBERING:NONCE)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-STRING.

;     (MAKE-SYMBOL
;      (SNARK-LISP:TO-STRING (FIRST (SNARK:VARIABLE-SYMBOL-PREFIXES?))
;                            SNARK::RESULTSORT (SNARK-NUMBERING:NONCE)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-STRING.

;     (SNARK-NUMBERING:NONCE)
; --> (LAMBDA NIL (INCF SNARK-NUMBERING::*NONCE*)) SB-C::%FUNCALL INCF SETQ THE 
; ==>
;   (+ 1 SNARK-NUMBERING::*NONCE*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INPUT-FLOAT-FUNCTION-AS-RELATION ...)
; compiling (DEFUN INPUT-RELATION-AS-FUNCTION ...)
; compiling (DEFUN INPUT-EQUIVALENCE ...)
; compiling (DEFUN INPUT-EXCLUSIVE-OR ...)
; compiling (DEFUN INPUT-CONDITIONAL ...)
; compiling (DEFUN INPUT-CONDITIONAL-ANSWER ...)
; compiling (DEFUN INPUT-QUANTIFICATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-QUANTIFICATION
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN INPUT-QUANTIFIER-VARIABLE ...)
; compiling (DEFUN MAKE-VARIABLE-FROM-VAR-SPEC ...)
; compiling (DEFUN INPUT-QUANTIFIER-VARIABLES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-QUANTIFIER-VARIABLES
;     (FUNCALL
;      (IF (EQUAL (REST SNARK::X) (REST SNARK::Y))
;          'WARN
;          'ERROR)
;      "In quantification, variable ~A is being rebound." (FIRST SNARK::X))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (IF (EQUAL (REST SNARK::X) (REST SNARK::Y))
;        'WARN
;        'ERROR))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSOC (FIRST SNARK::X) SNARK::*INPUT-WFF-SUBSTITUTION*)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN INPUT-VARIABLES-IN-FORM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-VARIABLES-IN-FORM
;     (MEMBER SNARK::EXPR SNARK::VARS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC SNARK::EXPR SNARK::SUBSTITUTION)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (RASSOC (CDR SNARK::V) SNARK::RESULT)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (RASSOC SNARK::X SNARK::RESULT)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (RASSOC SNARK::X SNARK::SUBSTITUTION)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (PUSHNEW (FIRST SNARK::VAR-SPEC) SNARK::VARS)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN CREATE-SKOLEM-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CREATE-SKOLEM-TERM
;     (LENGTH SNARK::FREE-VARS-IN-FORM)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR CONS VECTOR SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; compiling (DEFUN CREATE-SKOLEM-SYMBOL ...)
; compiling (DEFVAR *NEW-SYMBOL-PREFIX*)
; compiling (DEFVAR *NUMBER-OF-NEW-SYMBOLS*)
; compiling (DEFVAR *NEW-SYMBOL-TABLE*)
; compiling (DEFUN NEWSYM-PREFIX ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN NEWSYM-PREFIX
;     (REM SNARK::N 26)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).

;     (FLOOR SNARK::N 26)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a INTEGER, not a (UNSIGNED-BYTE 64).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN NEWSYM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN NEWSYM
;     (INCF SNARK::*NUMBER-OF-NEW-SYMBOLS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-NEW-SYMBOLS*)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN NEWSYM2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN NEWSYM2
;     (= 0 SNARK::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (+ 1 SNARK::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INPUT-FORM* ...)
; compiling (DEFUN INPUT-FORM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-FORM
;     (FUNCALL SNARK::FUN SNARK:HEAD SNARK::TERMS SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN INPUT-ATOM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-ATOM
;     (ASSOC ATOM SNARK::*INPUT-WFF-SUBSTITUTION*)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN INPUT-TERM ...)
; compiling (DEFUN INPUT-TERM1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-TERM1
;     (ASSOC SNARK::TERM SNARK::*INPUT-WFF-SUBSTITUTION*)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN INPUT-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-TERMS
;     (SNARK-LISP:LCONS (SNARK::INPUT-TERM1 (FIRST SNARK::TERMS) SNARK::POLARITY)
;                       (SNARK::INPUT-TERMS (REST SNARK::TERMS) SNARK::POLARITY)
;                       SNARK::TERMS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G1735 #:G1737)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G1735 #:G1737)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAP-POLARITY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN MAP-POLARITY
;     (FUNCALL SNARK::FUN SNARK::POLARITY)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN OPPOSITE-POLARITY ...)
; compiling (DEFUN INPUT-ATOM-WITH-KEYWORD-ARGUMENTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN INPUT-ATOM-WITH-KEYWORD-ARGUMENTS
;     (LENGTH SNARK::KEYWORDS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (POSITION (FIRST SNARK::L) SNARK::KEYWORDS)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

; compiling (DEFUN ATOM-WITH-KEYWORDS-INPUTTER ...)
; compiling (DEFUN CLAUSIFY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.lisp
; in: DEFUN CLAUSIFY
;     (FUNCALL SNARK::MAP-FUN SNARK::CLAUSE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAP-FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::LITS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (CONS SNARK::WFF SNARK::LITS))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::LITS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC
;              (CONS
;               (IF SNARK::POS
;                   SNARK::WFF
;                   SNARK::-WFF)
;               SNARK::LITS))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SNARK::LITS)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN REPORT-NOT-2-ARGUMENTS-QUANTIFICATION ...)
; compiling (DEFUN REPORT-NOT-2-ARGUMENTS-IMPLICATION ...)
; compiling (DEFUN REQUIRE-N-ARGUMENTS ...)
; compiling (DEFUN REQUIRE-N-OR-MORE-ARGUMENTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/input.fasl written
; compilation finished in 0:00:00.308
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO WITH-NO-OUTPUT ...)
; compiling (DEFUN PRINT-FUNCTION-SYMBOL ...)
; compiling (DEFUN PRINT-VARIABLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-VARIABLE
;     (FLOOR SNARK::NUM 6)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a RATIONAL.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12.0d0) (SINGLE-FLOAT (0.0) 12.0) (RATIONAL (0) (12))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12.0d0) (SINGLE-FLOAT (0.0) 12.0) (RATIONAL (0) (12))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PRINT-TERM3 ...)
; compiling (DEFUN PRINT-TERM ...)
; compiling (DEFUN PRINT-ROW-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-ROW-TERM
;     (LENGTH (SNARK::ARGSA SNARK::TERM))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (< (SNARK:PRINT-ROW-LENGTH-LIMIT?) (LENGTH (SNARK::ARGSA SNARK::TERM)))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.

; compiling (DEFMETHOD PRINT-GIVEN-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFMETHOD PRINT-GIVEN-ROW (T)
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WHEN (SNARK:PRINT-TIME-USED?) (SNARK-LISP:PRINT-INCREMENTAL-TIME-USED))
;       (DOTIMES (SNARK::DUMMY (- (CASE # # #) 1))
;         (DECLARE (IGNORABLE SNARK::DUMMY))
;         (SNARK::TERPRI))
;       (SNARK::TERPRI)
;       (SNARK:PRINT-ROW SNARK:ROW :STRING "Infer_from_row ")
;       (PRINC " ")
;       (FORCE-OUTPUT))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (BLOCK #:EXIT-TAG-94
;     (SB-C::%WITHIN-CLEANUP :UNWIND-PROTECT
;                            (SB-C::%UNWIND-PROTECT
;                             (SB-C::%ESCAPE-FUN #:EXIT-TAG-94)
;                             (SB-C::%CLEANUP-FUN #:CLEANUP-FUN-92))
;                            (RETURN-FROM #:DROP-THRU-TAG-93
;                              (PROGN
;                               (WHEN # #)
;                               (DOTIMES # # #)
;                               (SNARK::TERPRI)
;                               (SNARK:PRINT-ROW SNARK:ROW :STRING
;                                                "Infer_from_row ")
;                               (PRINC " ")
;                               (FORCE-OUTPUT)))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-TAG-94 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (-
;      (CASE (SNARK:PRINT-ROWS-WHEN-DERIVED?)
;        ((:SIGNAL NIL) (SNARK:PRINT-GIVEN-ROW-LINES-SIGNALLING?))
;        (OTHERWISE (SNARK:PRINT-GIVEN-ROW-LINES-PRINTING?)))
;      1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES
;         (SNARK::DUMMY
;          (- (CASE (SNARK:PRINT-ROWS-WHEN-DERIVED?) (# #) (OTHERWISE #)) 1))
;       (DECLARE (IGNORABLE SNARK::DUMMY))
;       (SNARK::TERPRI))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK::DUMMY 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WHEN (SNARK:PRINT-TIME-USED?) (SNARK-LISP:PRINT-INCREMENTAL-TIME-USED))
;       (DOTIMES (SNARK::DUMMY (- (CASE # # #) 1))
;         (DECLARE (IGNORABLE SNARK::DUMMY))
;         (SNARK::TERPRI))
;       (SNARK::TERPRI)
;       (SNARK:PRINT-ROW SNARK:ROW :STRING "Infer_from_row ")
;       (PRINC " ")
;       (FORCE-OUTPUT))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFMETHOD PRINT-DERIVED-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFMETHOD PRINT-DERIVED-ROW (T)
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WHEN (SNARK:PRINT-TIME-USED?) (SNARK-LISP:PRINT-INCREMENTAL-TIME-USED))
;       (SNARK::TERPRI)
;       (SNARK:PRINT-ROW SNARK:ROW)
;       (PRINC " "))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (BLOCK #:EXIT-TAG-135
;     (SB-C::%WITHIN-CLEANUP :UNWIND-PROTECT
;                            (SB-C::%UNWIND-PROTECT
;                             (SB-C::%ESCAPE-FUN #:EXIT-TAG-135)
;                             (SB-C::%CLEANUP-FUN #:CLEANUP-FUN-133))
;                            (RETURN-FROM #:DROP-THRU-TAG-134
;                              (PROGN
;                               (WHEN # #)
;                               (SNARK::TERPRI)
;                               (SNARK:PRINT-ROW SNARK:ROW)
;                               (PRINC " ")))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-TAG-135 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-PROCESSED-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-PROCESSED-ROW
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WHEN (SNARK:PRINT-TIME-USED?) (SNARK-LISP:PRINT-INCREMENTAL-TIME-USED))
;       (SNARK::TERPRI)
;       (SNARK:LET-OPTIONS ((SNARK:USE-TO-LISP-CODE NIL))
;         (SNARK:PRINT-ROW SNARK:ROW :STRING "Processing_row "))
;       (PRINC " "))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-PURE-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-PURE-ROW
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WHEN (SNARK:PRINT-TIME-USED?) (SNARK-LISP:PRINT-INCREMENTAL-TIME-USED))
;       (SNARK::TERPRI)
;       (SNARK:PRINT-ROW SNARK:ROW :STRING "Pure_row ")
;       (PRINC " "))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFVAR *PRINTING-DELETED-MESSAGES* ...)
; compiling (DEFUN PRINT-DELETED-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-DELETED-WFF
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (COND
;        ((EQUAL SNARK::*PRINTING-DELETED-MESSAGES* SNARK::MSG)
;         (FORMAT T ",~A" (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)))
;        (T (SNARK::TERPRI-COMMENT)
;         (FORMAT T "~A ~A" SNARK::MSG (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW))
;         (SETF SNARK::*PRINTING-DELETED-MESSAGES* SNARK::MSG))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-UNORIENTABLE-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-UNORIENTABLE-WFF
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WARN "Could not orient ~A." SNARK::EQUALITY-OR-EQUIVALENCE))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFVAR *SZS-FILESPEC* ...)
; compiling (DEFVAR *SZS-CONJECTURE* ...)
; compiling (DEFUN PRINT-SZS-STATUS ...)
; compiling (DEFUN PRINT-SZS-ANSWERS-SHORT ...)
; compiling (DEFUN PRINT-FINAL-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-FINAL-ROW
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (UNLESS (EQ :TPTP SNARK::P)
;         (SNARK::TERPRI)
;         (SNARK::TERPRI)
;         (PRINC "(Refutation")
;         (SNARK:PRINT-ANCESTRY SNARK:ROW)
;         (SNARK::TERPRI)
;         (PRINC ")"))
;       (WHEN (OR (EQ :TPTP SNARK::P) (EQ :TPTP-TOO SNARK::P))
;         (SNARK::TERPRI)
;         (SNARK::TERPRI)
;         (PRINC "#||")
;         (SNARK::TERPRI)
;         (SNARK::PRINT-SZS-STATUS :PROOF-FOUND T)
;         (SNARK::TERPRI)
;         (SNARK::PRINT-SZS-ANSWERS-SHORT (LIST (SNARK:ROW-ANSWER SNARK:ROW)))
;         (PRINC "% SZS output start Refutation")
;         (SNARK:PRINT-ANCESTRY SNARK:ROW :FORMAT :TPTP)
;         (SNARK::TERPRI)
;         ...))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN REPLACE-ROWS-BY-NAME-OR-NUMBER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN REPLACE-ROWS-BY-NAME-OR-NUMBER
;     (SNARK-LISP:LCONS (SNARK::REPLACE-ROWS-BY-NAME-OR-NUMBER (CAR SNARK::X))
;                       (SNARK::REPLACE-ROWS-BY-NAME-OR-NUMBER (CDR SNARK::X))
;                       SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G334 #:G336)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G333 #:G335)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G333 #:G335)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PRINT-ROW-REASON ...)
; compiling (DEFUN PRINT-ROW3 ...)
; compiling (DEFUN PRINT-ROW-LENGTH-LIMIT1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN PRINT-ROW-LENGTH-LIMIT1
;     (MIN SNARK::N1 SNARK::N2)
; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> LET LET IF <= OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> LET LET IF <= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN PRINT-ROW ...)
; compiling (DEFVAR *PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP* ...)
; compiling (DEFUN TERM-TO-LISP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.lisp
; in: DEFUN TERM-TO-LISP
;     (FUNCALL SNARK::FUN SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::FUN SNARK:HEAD SNARK:ARGS SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:LCONS (SNARK:TERM-TO-LISP (FIRST SNARK:ARGS))
;                       (SNARK::ARGS-TO-LISP (REST SNARK:ARGS)) SNARK:ARGS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G475 #:G477)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G475 #:G477)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN CONS-TERM-TO-LISP ...)
; compiling (DEFUN QUANT-COMPOUND-TO-LISP ...)
; compiling (DEFUN ROW-SORTS ...)
; compiling (DEFUN DERIVATION-SORTS ...)
; compiling (DEFUN SUBSORT-FORMS ...)
; compiling (DEFUN DERIVATION-SUBSORT-FORMS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/output.fasl written
; compilation finished in 0:00:00.222
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *MANUAL-ORDERING-RESULTS* ...))
; compiling (DEFUN MANUAL-ORDERING-COMPARE-TERMS ...)
; compiling (DEFUN DEFINITION-P ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS0
;     (FUNCALL (SNARK:USE-TERM-ORDERING?) SNARK::X SNARK::Y SUBST SNARK::TESTVAL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (SNARK:USE-TERM-ORDERING?))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::X SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS1
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::TERPRI-COMMENT)
;       (COND
;        ((AND SNARK:ROW (SNARK:ROW-NUMBER SNARK:ROW))
;         (FORMAT T "Could not orient ~A " (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)))
;        (T (FORMAT T "Could not orient ~A=~A " SNARK::X SNARK::Y))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::TERPRI-COMMENT)
;       (FORMAT T "Oriented ~A ~A " (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)
;               (COND ((EQ '> SNARK::DIR) "left-to-right")
;                     ((EQ '< SNARK::DIR) "right-to-left"))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::TERPRI-COMMENT)
;       (COND
;        ((AND SNARK:ROW (SNARK:ROW-NUMBER SNARK:ROW))
;         (FORMAT T "Could not orient ~A " (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)))
;        (T (FORMAT T "Could not orient ~A=~A " SNARK::X SNARK::Y))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::TERPRI-COMMENT)
;       (FORMAT T "Oriented ~A ~A " (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)
;               (COND ((EQ '> SNARK::DIR) "left-to-right")
;                     ((EQ '< SNARK::DIR) "right-to-left"))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::TERPRI-COMMENT)
;       (COND
;        ((AND SNARK:ROW (SNARK:ROW-NUMBER SNARK:ROW))
;         (FORMAT T "Could not orient ~A " (SNARK:ROW-NAME-OR-NUMBER SNARK:ROW)))
;        (T (FORMAT T "Could not orient ~A=~A " SNARK::X SNARK::Y))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SIMPLIFICATION-ORDERING-COMPARE-TERMS
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ORDERING
;       (SNARK::SIMPLIFICATION-ORDERING-COMPARE-TERMS1 SNARK::X SNARK::Y SUBST
;                                                      SNARK::TESTVAL WARN
;                                                      SNARK:ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFVAR *SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS-HASH-TABLE*)
; compiling (DEFUN INITIALIZE-SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS-HASH-TABLE ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS ...)
; compiling (DEFUN SIMPLIFICATION-ORDERING-GREATERP ...)
; compiling (DEFUN INSTANTIATING-DIRECTION1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN INSTANTIATING-DIRECTION1
;     (EQL SNARK::XV SNARK::YV)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN INSTANTIATING-DIRECTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN INSTANTIATING-DIRECTION
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ORDERING
;       (SNARK::INSTANTIATING-DIRECTION1 (SNARK::VARIABLES SNARK::X SUBST)
;                                        (SNARK::VARIABLES SNARK::Y SUBST)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN LITERAL-ORDERING-A ...)
; compiling (DEFUN LITERAL-ORDERING-P ...)
; compiling (DEFUN LITERAL-ORDERING-N ...)
; compiling (DEFUN LITERAL-IS-NOT-DOMINATED-IN-CLAUSE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN LITERAL-IS-NOT-DOMINATED-IN-CLAUSE-P
;     (FUNCALL SNARK::ORDERFUN ATOM SNARK::POLARITY SNARK::ATOM2 SNARK::POLARITY2
;              SUBST '<)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ORDERFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN LITERAL-IS-NOT-DOMINATING-IN-CLAUSE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN LITERAL-IS-NOT-DOMINATING-IN-CLAUSE-P
;     (FUNCALL SNARK::ORDERFUN ATOM SNARK::POLARITY SNARK::ATOM2 SNARK::POLARITY2
;              SUBST '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ORDERFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN LITERAL-SATISFIES-ORDERING-RESTRICTION-P ...)
; compiling (DEFUN SELECTED-ATOMS-IN-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SELECTED-ATOMS-IN-ROW
;     (FUNCALL SNARK::ORDERFUN SNARK::ATOM2 SNARK::POLARITY2 ATOM SNARK::POLARITY
;              NIL '<)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ORDERFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::ORDERFUN SNARK::ATOM2 SNARK::POLARITY2 ATOM SNARK::POLARITY
;              NIL '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ORDERFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DELETE-IF
;      (LAMBDA (SNARK::Y)
;        (SNARK-LISP:MVLET ((# SNARK::Y))
;          (EQ '<
;              (FUNCALL SNARK::ORDERFUN SNARK::ATOM2 SNARK::POLARITY2 ATOM
;                       SNARK::POLARITY NIL '<))))
;      SNARK::L)
; 
; note: unable to open code due to type uncertainty: The second argument is a (OR (SIMPLE-ARRAY * (*)) NULL SB-KERNEL:EXTENDED-SEQUENCE CONS), not a LIST.

;     (ASSOC (OR SNARK::ORDERFUN 'SNARK::NO-LITERAL-ORDERING) SNARK::SELECTIONS)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN SELECTED-ATOM-IN-ROW-P ...)
; compiling (DEFUN SELECTED-ATOM-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SELECTED-ATOM-P
;     (FUNCALL SNARK::ORDERFUN (SNARK::INSTANTIATE SNARK::ATOM2 SNARK::N)
;              SNARK::POLARITY2
;              (SNARK::SETQ-ONCE SNARK::ATOM* (SNARK::INSTANTIATE ATOM SNARK::N))
;              SNARK::POLARITY SUBST '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::ORDERFUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SELECTED-ATOMS-IN-HYPERRESOLUTION-ELECTRONS-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.lisp
; in: DEFUN SELECTED-ATOMS-IN-HYPERRESOLUTION-ELECTRONS-P
;     (LENGTH SNARK::ELECTRONS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (DECF SNARK::K)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMETHOD THEORY-REWRITE ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/simplification-ordering.fasl written
; compilation finished in 0:00:00.117
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SYMBOLS-IN-SYMBOL-TABLE*))
; compiling (DEFVAR ORDERING-IS-TOTAL ...)
; compiling (DEFVAR *SYMBOL-ORDERING*)
; compiling (DEFUN INITIALIZE-SYMBOL-ORDERING ...)
; compiling (DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE
;     (= 1 SNARK::ARITY1)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= 2 SNARK::ARITY2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= 2 SNARK::ARITY1)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= 1 SNARK::ARITY2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (> SNARK::ARITY1 SNARK::ARITY2)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (STRING> SNARK::SYMBOL1 SNARK::SYMBOL2)
; ==>
;   (SB-KERNEL:STRING>* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a STRING, not a SIMPLE-BASE-STRING.The second argument is a STRING, not a SIMPLE-BASE-STRING.

;     (EQL SNARK::ARITY1 SNARK::ARITY2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (> SNARK::ARITY1 SNARK::ARITY2)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFUN DEFAULT-SYMBOL-ORDERING-COMPARE1
;     (STRING< (SYMBOL-NAME SNARK::SYMBOL1) (SYMBOL-NAME SNARK::SYMBOL2))
; ==>
;   (SB-KERNEL:STRING<* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.The second argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.

;     (STRING> (SYMBOL-NAME SNARK::SYMBOL1) (SYMBOL-NAME SNARK::SYMBOL2))
; ==>
;   (SB-KERNEL:STRING>* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.The second argument is a SIMPLE-STRING, not a SIMPLE-BASE-STRING.

; compiling (DEFUN DECLARE-ORDERING-GREATERP2 ...)
; compiling (DEFINLINE SYMBOL-ORDERING-COMPARE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFINLINE SYMBOL-ORDERING-COMPARE
;     (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SYMBOL-ORDERING-COMPARE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFUN SYMBOL-ORDERING-COMPARE1
;     (FUNCALL
;      (IF (OR (EQ T SNARK::ORDERING-FUN) (EQ :ARITY SNARK::ORDERING-FUN)
;              (EQ :REVERSE SNARK::ORDERING-FUN))
;          #'SNARK::DEFAULT-SYMBOL-ORDERING-COMPARE
;          SNARK::ORDERING-FUN)
;      SNARK::SYMBOL1 SNARK::SYMBOL2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (IF (OR (EQ T SNARK::ORDERING-FUN) (EQ :ARITY SNARK::ORDERING-FUN)
;            (EQ :REVERSE SNARK::ORDERING-FUN))
;        #'SNARK::DEFAULT-SYMBOL-ORDERING-COMPARE
;        SNARK::ORDERING-FUN))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::POSET-GREATERP SNARK::*SYMBOL-ORDERING* SNARK::N1 SNARK::N2)
; --> 
; --> (LAMBDA (SNARK::POSET SNARK::X SNARK::Y) (AND (NOT (EQL SNARK::X SNARK::Y)) (SNARK-SPARSE-ARRAY:SPAREF SNARK::POSET SNARK::X SNARK::Y))) 
; --> SB-C::%FUNCALL AND IF NOT IF 
; ==>
;   (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::POSET-GREATERP SNARK::*SYMBOL-ORDERING* SNARK::N2 SNARK::N1)
; --> 
; --> (LAMBDA (SNARK::POSET SNARK::X SNARK::Y) (AND (NOT (EQL SNARK::X SNARK::Y)) (SNARK-SPARSE-ARRAY:SPAREF SNARK::POSET SNARK::X SNARK::Y))) 
; --> SB-C::%FUNCALL AND IF NOT IF 
; ==>
;   (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN OPPOSITE-ORDER ...)
; compiling (DEFUN PRINT-SYMBOL-ORDERING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFUN PRINT-SYMBOL-ORDERING
;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;        (SNARK-SPARSE-ARRAY:SPARSE-MATRIX-ROWS SNARK::*SYMBOL-ORDERING*)
;        SNARK::->* SNARK:ROW SNARK::|X#|)
;       (SNARK::SYMBOL-NUMBERED SNARK::|X#| SNARK::-> SNARK::X)
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR SNARK:ROW SNARK::->* SNARK::|Y#|)
;       (SNARK::SYMBOL-NUMBERED SNARK::|Y#| SNARK::-> SNARK::Y)
;       (WHEN
;           (SNARK-LISP:IMPLIES (SNARK-LISP:NEQ SNARK-LISP:NONE SNARK::SYMBOLS)
;                               (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::X)
;                                       SNARK::SYMBOLS))
;         (OR (ASSOC SNARK::X SNARK::L) (FIRST (PUSH # SNARK::L)) SNARK::->
;             SNARK::V)
;         (PUSH SNARK::Y (THIRD SNARK::V)))
;       (WHEN
;           (SNARK-LISP:IMPLIES (SNARK-LISP:NEQ SNARK-LISP:NONE SNARK::SYMBOLS)
;                               (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::Y)
;                                       SNARK::SYMBOLS))
;         (OR (ASSOC SNARK::Y SNARK::L) (FIRST (PUSH # SNARK::L)) SNARK::->
;             SNARK::V)
;         (PUSH SNARK::X (SECOND SNARK::V))))
; --> BLOCK FLET BLOCK LET SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SORT SNARK::L 'SNARK::CONSTANT-NAME-LESSP :KEY #'FIRST)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SNARK-LISP:PROG->
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES
;        (SNARK-SPARSE-ARRAY:SPARSE-MATRIX-ROWS SNARK::*SYMBOL-ORDERING*)
;        SNARK::->* SNARK:ROW SNARK::|X#|)
;       (SNARK::SYMBOL-NUMBERED SNARK::|X#| SNARK::-> SNARK::X)
;       (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR SNARK:ROW SNARK::->* SNARK::|Y#|)
;       (SNARK::SYMBOL-NUMBERED SNARK::|Y#| SNARK::-> SNARK::Y)
;       (WHEN
;           (SNARK-LISP:IMPLIES (SNARK-LISP:NEQ SNARK-LISP:NONE SNARK::SYMBOLS)
;                               (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::X)
;                                       SNARK::SYMBOLS))
;         (OR (ASSOC SNARK::X SNARK::L) (FIRST (PUSH # SNARK::L)) SNARK::->
;             SNARK::V)
;         (PUSH SNARK::Y (THIRD SNARK::V)))
;       (WHEN
;           (SNARK-LISP:IMPLIES (SNARK-LISP:NEQ SNARK-LISP:NONE SNARK::SYMBOLS)
;                               (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::Y)
;                                       SNARK::SYMBOLS))
;         (OR (ASSOC SNARK::Y SNARK::L) (FIRST (PUSH # SNARK::L)) SNARK::->
;             SNARK::V)
;         (PUSH SNARK::X (SECOND SNARK::V))))
; --> BLOCK FLET BLOCK LET FLET BLOCK LET SNARK::SYMBOL-NUMBERED 
; --> (LAMBDA (SNARK::N) (FUNCALL SNARK-NUMBERING:*STANDARD-EQL-NUMBERING* :INVERSE SNARK::N)) 
; --> SB-C::%FUNCALL FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-NUMBERING:*STANDARD-EQL-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::X) SNARK::SYMBOLS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC SNARK::X SNARK::L)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER (SNARK::SYMBOL-TO-NAME SNARK::Y) SNARK::SYMBOLS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC SNARK::Y SNARK::L)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN DECLARE-ORDERING-GREATERP ...)
; compiling (DEFUN RPO-ADD-CREATED-FUNCTION-SYMBOL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.lisp
; in: DEFUN RPO-ADD-CREATED-FUNCTION-SYMBOL
;     (> (SNARK:FUNCTION-ARITY SNARK::FN) (SNARK:FUNCTION-ARITY SYMBOL))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/symbol-ordering.fasl written
; compilation finished in 0:00:00.089
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN COMPARE-MULTISETS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.lisp
; in: DEFUN COMPARE-MULTISETS
;     (MINUSP (CDR SNARK::Y))
; ==>
;   (< (CDR SNARK::Y) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP (CDR SNARK::X))
; ==>
;   (> (CDR SNARK::X) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (FUNCALL SNARK::COMPARE (CAR SNARK::X) (CAR SNARK::Y) '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE (CAR SNARK::X) (CAR SNARK::Y))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (PLUSP (CDR SNARK::X))
; ==>
;   (> (CDR SNARK::X) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP (CDR SNARK::Y))
; ==>
;   (< (CDR SNARK::Y) 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (FUNCALL SNARK::COMPARE (CAR SNARK::X) (CAR SNARK::Y) '<)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE SNARK::X SNARK::Y '=)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MINUSP (CDR SNARK::Y))
; ==>
;   (< (CDR SNARK::Y) 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (PLUSP (CDR SNARK::X))
; ==>
;   (> (CDR SNARK::X) 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (MINUSP (CDR SNARK::Y))
; ==>
;   (< (CDR SNARK::Y) 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN COMPARE-TERM-MULTISETS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.lisp
; in: DEFUN COMPARE-TERM-MULTISETS
;     (FUNCALL SNARK::COMPARE (FIRST SNARK::XARGS) (FIRST SNARK::YARGS) SUBST
;              SNARK::TESTVAL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MEMBER (FIRST SNARK::XARGS) SNARK::YARGS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER (FIRST SNARK::YARGS) SNARK::XARGS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::COMPARE SNARK::TERM (SNARK::TC-TERM SNARK::Y) SUBST NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE (SNARK::TC-TERM SNARK::X) SNARK::TERM SUBST NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE (SNARK::TC-TERM SNARK::Y) SNARK::TERM SUBST NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE (SNARK::TC-TERM SNARK::X) SNARK::TERM SUBST '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::COMPARE (SNARK::TC-TERM SNARK::Y) SNARK::TERM SUBST '>)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ASSOC SNARK::TERM SNARK::CONSTANT-COUNTS)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::COMPARE SNARK::X SNARK::Y SUBST '=)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::COMPARE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL (FIRST SNARK::XARGS) (FIRST SNARK::YARGS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::TERM (SNARK::TC-TERM SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/multiset-ordering.fasl written
; compilation finished in 0:00:00.112
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *RPO-CACHE*)
; compiling (DEFVAR *RPO-CACHE-NUMBERING*)
; compiling (DEFVAR *AC-RPO-CACHE*)
; compiling (DEFUN RPO-COMPARE-TERMS-TOP ...)
; compiling (DEFUN RPO-CACHE-LOOKUP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-CACHE-LOOKUP
;     (FUNCALL SNARK::*RPO-CACHE-NUMBERING* :LOOKUP SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::*RPO-CACHE-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::*RPO-CACHE-NUMBERING* :LOOKUP SNARK::Y)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::*RPO-CACHE-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN RPO-CACHE-STORE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-CACHE-STORE
;     (FUNCALL SNARK::*RPO-CACHE-NUMBERING* :LOOKUP SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::*RPO-CACHE-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::*RPO-CACHE-NUMBERING* :LOOKUP SNARK::Y)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::*RPO-CACHE-NUMBERING*)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE RPO-COMPARE-VARIABLE*COMPOUND ...)
; compiling (DEFINLINE RPO-COMPARE-COMPOUND*VARIABLE ...)
; compiling (DEFUN RPO-COMPARE-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-COMPARE-TERMS
;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::X SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN RPO-COMPARE-COMPOUND*CONSTANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-COMPARE-COMPOUND*CONSTANT
;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::TERM) SNARK::CONSTANT)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::TERM SNARK::CONSTANT)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN RPO-COMPARE-CONSTANT*COMPOUND ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-COMPARE-COMPOUNDS0
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ORDERING-AC
;       (SNARK::AC-RPO-COMPARE-COMPOUNDS SNARK::FN (SNARK::FLATARGS SNARK::X SUBST)
;                                        (SNARK::FLATARGS SNARK::Y SUBST) SUBST))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-AC-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::FN (SNARK:HEAD SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ORDERING-AC
;       (SNARK::AC-RPO-COMPARE-COMPOUNDS SNARK::FN (SNARK::FLATARGS SNARK::X SUBST)
;                                        (SNARK::FLATARGS SNARK::Y SUBST) SUBST))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ORDERING-AC-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN RPO-COMPARE-LISTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.lisp
; in: DEFUN RPO-COMPARE-LISTS
;     (EQL (SETF SNARK::XARG (POP SNARK::XARGS))
;          (SETF SNARK::YARG (POP SNARK::YARGS)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN RPO-COMPARE-COMPOUNDS> ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS< ...)
; compiling (DEFUN RPO-COMPARE-COMPOUNDS? ...)
; compiling (DEFUN THEREIS-RPO-EQUAL-OR-GREATERP ...)
; compiling (DEFUN RPO-COMPARE-ALISTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/recursive-path-ordering.fasl written
; compilation finished in 0:00:00.159
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN AC-RPO-COMPARE-COMPOUNDS ...)
; compiling (DEFUN AC-RPO-COMPARE-COMPOUNDS* ...)
; compiling (DEFUN EMB-NO-BIG ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp
; in: DEFUN EMB-NO-BIG
;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::ARGI) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN BIG-HEAD-AND-NO-SMALL-HEAD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp
; in: DEFUN BIG-HEAD-AND-NO-SMALL-HEAD
;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::ARG) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::ARG SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN COMPARE-NO-SMALL-HEADS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp
; in: DEFUN COMPARE-NO-SMALL-HEADS
;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::Y) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::Y) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::Y) (SNARK:HEAD SNARK::X))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) (SNARK:HEAD SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::Y) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::Y) (SNARK:HEAD SNARK::X))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) (SNARK:HEAD SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::Y SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::Y (SNARK:HEAD SNARK::X))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::Y SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::Y (SNARK:HEAD SNARK::X))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::FN)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::X SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN COMPARE-ARGUMENT-COUNTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp
; in: DEFUN COMPARE-ARGUMENT-COUNTS
;     (PLUSP SNARK::VARIABLE-COUNT)
; ==>
;   (> SNARK::VARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (< SNARK::NONVARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::D)
; ==>
;   (> SNARK::D 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP SNARK::VARIABLE-COUNT)
; ==>
;   (< SNARK::VARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (> SNARK::NONVARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP SNARK::D)
; ==>
;   (< SNARK::D 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (> SNARK::NONVARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP SNARK::VARIABLE-COUNT)
; ==>
;   (< SNARK::VARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::VARIABLE-COUNT)
; ==>
;   (> SNARK::VARIABLE-COUNT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (INCF SNARK::NONVARIABLE-COUNT SNARK::INC)
; --> SETQ THE 
; ==>
;   (+ SNARK::INC SNARK::NONVARIABLE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (PLUSP SNARK::VARIABLE-COUNT)
; ==>
;   (> SNARK::VARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (INCF SNARK::VARIABLE-COUNT SNARK::C)
; --> SETQ THE 
; ==>
;   (+ SNARK::C SNARK::VARIABLE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).

;     (MINUSP SNARK::VARIABLE-COUNT)
; ==>
;   (< SNARK::VARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (INCF SNARK::VARIABLE-COUNT SNARK::C)
; --> SETQ THE 
; ==>
;   (+ SNARK::C SNARK::VARIABLE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (PLUSP SNARK::VARIABLE-COUNT)
; ==>
;   (> SNARK::VARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (MINUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (< SNARK::NONVARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (+ SNARK::VARIABLE-COUNT SNARK::NONVARIABLE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (PLUSP SNARK::D)
; ==>
;   (> SNARK::D 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (MINUSP SNARK::VARIABLE-COUNT)
; ==>
;   (< SNARK::VARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (> SNARK::NONVARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (+ SNARK::VARIABLE-COUNT SNARK::NONVARIABLE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MINUSP SNARK::D)
; ==>
;   (< SNARK::D 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (PLUSP SNARK::NONVARIABLE-COUNT)
; ==>
;   (> SNARK::NONVARIABLE-COUNT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

; compiling (DEFUN AC-RPO-CACHE-LOOKUP ...)
; compiling (DEFUN AC-RPO-CACHE-STORE ...)
; compiling (DEFUN EQL-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.lisp
; in: DEFUN EQL-LIST
;     (SNARK-LISP:NEQL (POP SNARK::L1) (POP SNARK::L2))
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/ac-rpo.fasl written
; compilation finished in 0:00:00.139
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFINLINE VARIABLE-KBO-WEIGHT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp
; in: DEFINLINE VARIABLE-KBO-WEIGHT
;     (FUNCALL SNARK::W SNARK:VAR)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN KBO-EVALUATE-TERM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp
; in: DEFUN KBO-EVALUATE-TERM
;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::TERM)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT (SNARK::VARIABLE-KBO-WEIGHT SNARK::TERM))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (* SNARK::MULT SNARK::W (MAX 1 (- (LENGTH SNARK:ARGS) 1)))
; --> * 
; ==>
;   (* SNARK::MULT SNARK::W)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (* SNARK::MULT SNARK::W (MAX 1 (- (LENGTH SNARK:ARGS) 1)))
; ==>
;   (* (* SNARK::MULT SNARK::W) (MAX 1 (- (LENGTH SNARK:ARGS) 1)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.

;     (* SNARK::MULT SNARK::W)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::TERM)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT (SNARK::CONSTANT-KBO-WEIGHT SNARK::TERM))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (* SNARK::MULT (SNARK::VARIABLE-KBO-WEIGHT SNARK::TERM))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::WEIGHT (* SNARK::MULT (SNARK::VARIABLE-KBO-WEIGHT SNARK::TERM)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT SNARK::W)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::WEIGHT (* SNARK::MULT SNARK::W))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT SNARK::W (MAX 1 (- (LENGTH SNARK:ARGS) 1)))
; --> * 
; ==>
;   (* SNARK::MULT SNARK::W)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (* (* SNARK::MULT SNARK::W) (MAX 1 (- (LENGTH SNARK:ARGS) 1)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::WEIGHT (* SNARK::MULT SNARK::W (MAX 1 (- (LENGTH SNARK:ARGS) 1))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (SNARK::CONSTANT-KBO-WEIGHT SNARK::TERM))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::WEIGHT (* SNARK::MULT (SNARK::CONSTANT-KBO-WEIGHT SNARK::TERM)))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN KBO-EVALUATE-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp
; in: DEFUN KBO-EVALUATE-TERMS
;     (* SNARK::MULT (POP SNARK::WS))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN KBO-COMPARE-TERMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.lisp
; in: DEFUN KBO-COMPARE-TERMS
;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (> SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (> SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (> SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT
;        (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;           (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT (SNARK::VARIABLE-KBO-WEIGHT SNARK::X))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT
;        (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;           (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y))
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* SNARK::MULT (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* SNARK::MULT (POP SNARK::WS))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (* SNARK::MULT SNARK::W
;        (- (MAX 1 (- (LENGTH SNARK::XARGS) 1))
;           (MAX 1 (- (LENGTH SNARK::YARGS) 1))))
; --> * 
; ==>
;   (* SNARK::MULT SNARK::W)
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (LENGTH SNARK::XARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SNARK::YARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (* SNARK::MULT SNARK::W
;        (- (MAX 1 (- (LENGTH SNARK::XARGS) 1))
;           (MAX 1 (- (LENGTH SNARK::YARGS) 1))))
; ==>
;   (* (* SNARK::MULT SNARK::W)
;      (- (MAX 1 (- (LENGTH SNARK::XARGS) 1))
;         (MAX 1 (- (LENGTH SNARK::YARGS) 1))))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.

;     (> SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y))
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (* SNARK::MULT (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK:VAR) (LET ((SNARK::W (SNARK:KBO-VARIABLE-WEIGHT?))) (IF (NUMBERP SNARK::W) SNARK::W (FUNCALL SNARK::W SNARK:VAR)))) 
; --> SB-C::%FUNCALL LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::W)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT
;        (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;           (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to Eliminate %negate/%negate of rationals due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT (SNARK::CONSTANT-KBO-WEIGHT SNARK::X))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::CONST) (IF (SNARK::CONSTANT-BUILTIN-P SNARK::CONST) (LET ((SNARK::V (SNARK:KBO-BUILTIN-CONSTANT-WEIGHT?))) (IF (NUMBERP SNARK::V) SNARK::V (FUNCALL SNARK::V SNARK::CONST))) (SNARK::CONSTANT-KBO-WEIGHT0 SNARK::CONST))) 
; --> SB-C::%FUNCALL IF LET IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::V)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (* SNARK::MULT
;        (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;           (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (> SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK::WEIGHT 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;        (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT
;        (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;           (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (SNARK::VARIABLE-KBO-WEIGHT SNARK::X))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;        (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT
;        (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::X)
;           (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y))
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (- (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (POP SNARK::WS))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT SNARK::W
;        (- (MAX 1 (- (LENGTH SNARK::XARGS) 1))
;           (MAX 1 (- (LENGTH SNARK::YARGS) 1))))
; --> * 
; ==>
;   (* SNARK::MULT SNARK::W)
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (* (* SNARK::MULT SNARK::W)
;      (- (MAX 1 (- (LENGTH SNARK::XARGS) 1))
;         (MAX 1 (- (LENGTH SNARK::YARGS) 1))))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (+ SNARK::WEIGHT (* SNARK::MULT SNARK::W (- (MAX 1 (- # 1)) (MAX 1 (- # 1)))))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (< SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (< SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK:HEAD (SNARK:HEAD SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y))
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (< SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE (SNARK:HEAD SNARK::X) SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;        (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT
;        (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;           (SNARK::VARIABLE-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK::MULT)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER SNARK::MULT))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline float arithmetic (cost 1) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT (SNARK::CONSTANT-KBO-WEIGHT SNARK::X))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (< SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::X (SNARK:HEAD SNARK::Y))
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;        (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (* SNARK::MULT
;        (- (SNARK::CONSTANT-KBO-WEIGHT SNARK::X)
;           (SNARK::CONSTANT-KBO-WEIGHT SNARK::Y)))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (> SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       etc.

;     (< SNARK::WEIGHT 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (SNARK::SYMBOL-ORDERING-COMPARE SNARK::X SNARK::Y)
; --> 
; --> (LAMBDA (SNARK::SYMBOL1 SNARK::SYMBOL2) (COND ((EQL SNARK::SYMBOL1 SNARK::SYMBOL2) (QUOTE =)) (T (SNARK::SYMBOL-ORDERING-COMPARE1 SNARK::SYMBOL1 SNARK::SYMBOL2)))) 
; --> SB-C::%FUNCALL COND IF 
; ==>
;   (EQL SNARK::SYMBOL1 SNARK::SYMBOL2)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/knuth-bendix-ordering2.fasl written
; compilation finished in 0:00:00.135
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *SUBSUMING* ...))
; compiling (DEFSTRUCT (REWRITE #) ...)
; compiling (DEFVAR *REDEX-PATH* ...)
; compiling (DEFUN REWRITE-PATTERNS-AND-VALUES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-PATTERNS-AND-VALUES
;     (FUNCALL FUNCTION SNARK::PATTERN SNARK::VALUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::PATTERN)
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::VALUE))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::PATTERN SNARK::NEWVAR1)
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::VALUE SNARK::NEWVAR1))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::PATTERN)
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::VALUE))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::PATTERN SNARK::NEWVAR1)
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::VALUE SNARK::NEWVAR1))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL FUNCTION
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::PATTERN
;                                   SNARK::NEWVAR2)
;              (SNARK:MAKE-COMPOUND SNARK:HEAD SNARK::NEWVAR1 SNARK::VALUE
;                                   SNARK::NEWVAR2))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFVAR *REWRITES-USED*)
; compiling (DEFVAR REWRITE-STRATEGY ...)
; compiling (DEFVAR FULLY-REWRITTEN-COMPOUNDS)
; compiling (DEFUN REDEX-AT-TOP? ...)
; compiling (DEFUN REDEX-POLARITY ...)
; compiling (DEFUN SET-REDEX-POLARITY ...)
; compiling (DEFUN REDEX-LITERAL? ...)
; compiling (DEFUN REDEX-CLAUSE? ...)
; compiling (DEFUN REWRITER ...)
; compiling (DEFUN REWRITE-CONSTANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-CONSTANT
;     (FUNCALL COND (SNARK::REWRITE-PATTERN SNARK:REWRITE)
;              (SNARK::REWRITE-VALUE SNARK:REWRITE) NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN COND)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PUSHNEW-UNLESS-NIL SNARK::W SNARK::*REWRITES-USED*)
; --> LET UNLESS IF PROGN PUSHNEW LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN REWRITE-COMPOUND ...)
; compiling (DEFUN REWRITE-COMPOUND-BY-CODE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-COMPOUND-BY-CODE
;     (FUNCALL SNARK::FUN SNARK::TERM SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PUSHNEW-UNLESS-NIL
;      (AND (NOT (SNARK:FUNCTION-LOGICAL-SYMBOL-P SNARK:HEAD))
;           (SNARK::FUNCTION-CODE-NAME SNARK:HEAD))
;      SNARK::*REWRITES-USED*)
; --> LET UNLESS IF PROGN PUSHNEW LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN DECLARE-CONSTANTS ...)
; compiling (DEFUN REWRITE-COMPOUND-BY-RULE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-COMPOUND-BY-RULE
;     (FUNCALL COND SNARK::PATTERN SNARK::VALUE SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN COND)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PUSHNEW-UNLESS-NIL SNARK::W SNARK::*REWRITES-USED*)
; --> LET UNLESS IF PROGN PUSHNEW LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (DEFUN SNARK::REWRITE-COMPOUND-BY-RULE
;            (SNARK::TERM SUBST SNARK::SYMBOL-COUNT)
;       (SNARK-LISP:PROG->
;         (WHEN (SNARK:TRACE-REWRITE?)
;           (FORMAT T "~2%; REWRITE-COMPOUND-BY-RULE will try to rewrite~%;   ~A."
;                   (SNARK:TERM-TO-LISP SNARK::TERM SUBST)))
;         (SNARK::RETRIEVE-GENERALIZATION-ENTRIES SNARK::TERM SUBST
;                                                 #'SNARK::TME-REWRITES SNARK::->*
;                                                 SNARK::E SNARK::REWRITES)
;         (DECLARE (IGNORE SNARK::E))
;         (DOLIST SNARK::REWRITES SNARK::->* SNARK:REWRITE)
;         (SNARK::REWRITE-ROW SNARK:REWRITE SNARK::-> SNARK::W)
;         (WHEN (AND (SNARK-LISP:IMPLIES SNARK::W #) (SNARK-LISP:IMPLIES # #))
;           (SNARK::REWRITE-CONDITION SNARK:REWRITE SNARK::-> COND)
;           (SNARK::REWRITE-PATTERN SNARK:REWRITE SNARK::-> SNARK::PATTERN)
;           (SNARK::REWRITE-VALUE SNARK:REWRITE SNARK::-> SNARK::VALUE)
;           (WHEN (EQ :VERBOSE #)
;             (FORMAT T "~%; Try ~A -> ~A." SNARK::PATTERN SNARK::VALUE))
;           (SNARK::REWRITE-PATTERN-SYMBOL-COUNT SNARK:REWRITE SNARK::->
;                                                SNARK::PATTERN-SYMBOL-COUNT)
;           (QUOTE NIL SNARK::-> SNARK::V)
;           (COND (# #) (T # # # #))))
;       (WHEN (SNARK:TRACE-REWRITE?)
;         (FORMAT T "~%; REWRITE-COMPOUND-BY-RULE failed to rewrite it."))
;       SNARK-LISP:NONE)
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::REWRITE-COMPOUND-BY-RULE
;     (SNARK-LISP:PROG->
;       (WHEN (SNARK:TRACE-REWRITE?)
;         (FORMAT T "~2%; REWRITE-COMPOUND-BY-RULE will try to rewrite~%;   ~A."
;                 (SNARK:TERM-TO-LISP SNARK::TERM SUBST)))
;       (SNARK::RETRIEVE-GENERALIZATION-ENTRIES SNARK::TERM SUBST
;                                               #'SNARK::TME-REWRITES SNARK::->*
;                                               SNARK::E SNARK::REWRITES)
;       (DECLARE (IGNORE SNARK::E))
;       (DOLIST SNARK::REWRITES SNARK::->* SNARK:REWRITE)
;       (SNARK::REWRITE-ROW SNARK:REWRITE SNARK::-> SNARK::W)
;       (WHEN (AND (SNARK-LISP:IMPLIES SNARK::W #) (SNARK-LISP:IMPLIES # #))
;         (SNARK::REWRITE-CONDITION SNARK:REWRITE SNARK::-> COND)
;         (SNARK::REWRITE-PATTERN SNARK:REWRITE SNARK::-> SNARK::PATTERN)
;         (SNARK::REWRITE-VALUE SNARK:REWRITE SNARK::-> SNARK::VALUE)
;         (WHEN (EQ :VERBOSE #)
;           (FORMAT T "~%; Try ~A -> ~A." SNARK::PATTERN SNARK::VALUE))
;         (SNARK::REWRITE-PATTERN-SYMBOL-COUNT SNARK:REWRITE SNARK::->
;                                              SNARK::PATTERN-SYMBOL-COUNT)
;         (QUOTE NIL SNARK::-> SNARK::V)
;         (COND (# #) (T # # # #))))
;     (WHEN (SNARK:TRACE-REWRITE?)
;       (FORMAT T "~%; REWRITE-COMPOUND-BY-RULE failed to rewrite it."))
;     SNARK-LISP:NONE)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM REWRITE-COMPOUND-BY-RULE TERM*). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN REWRITE-LIST ...)
; compiling (DEFUN REWRITE-LIST-BY-RULE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-LIST-BY-RULE
;     (FUNCALL COND SNARK::PATTERN SNARK::VALUE SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN COND)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PUSHNEW-UNLESS-NIL SNARK::W SNARK::*REWRITES-USED*)
; --> LET UNLESS IF PROGN PUSHNEW LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (DEFUN SNARK::REWRITE-LIST-BY-RULE (SNARK::TERM SUBST SNARK::SYMBOL-COUNT)
;       (SNARK-LISP:PROG->
;         (SNARK::RETRIEVE-GENERALIZATION-ENTRIES SNARK::TERM SUBST
;                                                 #'SNARK::TME-REWRITES SNARK::->*
;                                                 SNARK::E SNARK::REWRITES)
;         (DECLARE (IGNORE SNARK::E))
;         (DOLIST SNARK::REWRITES SNARK::->* SNARK:REWRITE)
;         (SNARK::REWRITE-ROW SNARK:REWRITE SNARK::-> SNARK::W)
;         (WHEN (SNARK-LISP:IMPLIES SNARK::W (AND # #))
;           (SNARK::REWRITE-CONDITION SNARK:REWRITE SNARK::-> COND)
;           (SNARK::REWRITE-PATTERN SNARK:REWRITE SNARK::-> SNARK::PATTERN)
;           (SNARK::REWRITE-VALUE SNARK:REWRITE SNARK::-> SNARK::VALUE)
;           (SNARK::REWRITE-PATTERN-SYMBOL-COUNT SNARK:REWRITE SNARK::->
;                                                SNARK::PATTERN-SYMBOL-COUNT)
;           (SNARK::REWRITE-PATTERNS-AND-VALUES SNARK::PATTERN SNARK::VALUE
;                                               SNARK::PATTERN-SYMBOL-COUNT
;                                               (SNARK::REWRITE-EMBEDDINGS
;                                                SNARK:REWRITE)
;                                               SNARK::SYMBOL-COUNT SNARK::->*
;                                               SNARK::PATTERN* SNARK::VALUE*)
;           (SNARK:UNIFY SNARK::PATTERN* SNARK::TERM SUBST SNARK::->* SUBST)
;           (WHEN (AND # #)
;             (SNARK-LISP:PUSHNEW-UNLESS-NIL SNARK::W SNARK::*REWRITES-USED*)
;             (DOLIST # #)
;             (SNARK::INSTANTIATE SNARK::VALUE* SUBST SNARK::-> SNARK::TERM*)
;             (RETURN-FROM SNARK::REWRITE-LIST-BY-RULE SNARK::TERM*))))
;       SNARK-LISP:NONE)
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::REWRITE-LIST-BY-RULE
;     (SNARK-LISP:PROG->
;       (SNARK::RETRIEVE-GENERALIZATION-ENTRIES SNARK::TERM SUBST
;                                               #'SNARK::TME-REWRITES SNARK::->*
;                                               SNARK::E SNARK::REWRITES)
;       (DECLARE (IGNORE SNARK::E))
;       (DOLIST SNARK::REWRITES SNARK::->* SNARK:REWRITE)
;       (SNARK::REWRITE-ROW SNARK:REWRITE SNARK::-> SNARK::W)
;       (WHEN (SNARK-LISP:IMPLIES SNARK::W (AND # #))
;         (SNARK::REWRITE-CONDITION SNARK:REWRITE SNARK::-> COND)
;         (SNARK::REWRITE-PATTERN SNARK:REWRITE SNARK::-> SNARK::PATTERN)
;         (SNARK::REWRITE-VALUE SNARK:REWRITE SNARK::-> SNARK::VALUE)
;         (SNARK::REWRITE-PATTERN-SYMBOL-COUNT SNARK:REWRITE SNARK::->
;                                              SNARK::PATTERN-SYMBOL-COUNT)
;         (SNARK::REWRITE-PATTERNS-AND-VALUES SNARK::PATTERN SNARK::VALUE
;                                             SNARK::PATTERN-SYMBOL-COUNT
;                                             (SNARK::REWRITE-EMBEDDINGS
;                                              SNARK:REWRITE)
;                                             SNARK::SYMBOL-COUNT SNARK::->*
;                                             SNARK::PATTERN* SNARK::VALUE*)
;         (SNARK:UNIFY SNARK::PATTERN* SNARK::TERM SUBST SNARK::->* SUBST)
;         (WHEN (AND # #)
;           (SNARK-LISP:PUSHNEW-UNLESS-NIL SNARK::W SNARK::*REWRITES-USED*)
;           (DOLIST # #)
;           (SNARK::INSTANTIATE SNARK::VALUE* SUBST SNARK::-> SNARK::TERM*)
;           (RETURN-FROM SNARK::REWRITE-LIST-BY-RULE SNARK::TERM*))))
;     SNARK-LISP:NONE)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM REWRITE-LIST-BY-RULE TERM*). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFVAR *REWRITE-COUNT-WARNING* ...)
; compiling (DEFMACRO REWRITE-*MOST ...)
; compiling (DEFUN EQ-ARGS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN EQ-ARGS
;     (EQL (SNARK-LISP:CARC SNARK::TERM) (FIRST SNARK:ARGS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL (SNARK-LISP:CDRC SNARK::TERM) (SECOND SNARK:ARGS))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN REWRITE-INNERMOST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-INNERMOST
;     (SNARK::REWRITE-*MOST
;      (LET ((SNARK:HEAD (SNARK:HEAD SNARK::TERM))
;            (SNARK:ARGS (SNARK:ARGS SNARK::TERM))
;            SNARK::ARGS*)
;        (COND ((OR # #)) (T (SETF #)))
;        (SNARK:DEREFERENCE SNARK::TERM SUBST)
;        (COND ((NOT #) (WHEN # #))
;              ((AND # # # # #) (RETURN-FROM SNARK::REWRITE-*MOST SNARK::TERM))
;              ((AND SNARK::HEAD-IF-ASSOCIATIVE #)
;               (RETURN-FROM SNARK::REWRITE-*MOST SNARK::TERM))
;              (T
;               (LET #
;                 #)))))
; --> BLOCK LET LOOP BLOCK TAGBODY PROGN WHEN IF WHEN IF AND IF EQL REM 
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> BLOCK LET LOOP BLOCK TAGBODY PROGN INCF SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::FANCY-MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*)
; --> LET* IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:G589)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::REWRITE-*MOST
;      (LET ((SNARK:HEAD (SNARK:HEAD SNARK::TERM))
;            (SNARK:ARGS (SNARK:ARGS SNARK::TERM))
;            SNARK::ARGS*)
;        (COND ((OR # #)) (T (SETF #)))
;        (SNARK:DEREFERENCE SNARK::TERM SUBST)
;        (COND ((NOT #) (WHEN # #))
;              ((AND # # # # #) (RETURN-FROM SNARK::REWRITE-*MOST SNARK::TERM))
;              ((AND SNARK::HEAD-IF-ASSOCIATIVE #)
;               (RETURN-FROM SNARK::REWRITE-*MOST SNARK::TERM))
;              (T
;               (LET #
;                 #)))))
; --> BLOCK LET LOOP BLOCK TAGBODY PROGN INCF SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN REWRITE-OUTERMOST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-OUTERMOST
;     (SNARK::REWRITE-*MOST
;      (LET ((SNARK:HEAD (SNARK:HEAD SNARK::TERM)))
;        (COND
;         ((AND SNARK::HEAD-IF-ASSOCIATIVE #)
;          (LET #
;            #))
;         (T
;          (LET #
;            #)))))
; --> BLOCK LET LOOP BLOCK TAGBODY PROGN WHEN IF WHEN IF AND IF EQL REM 
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> BLOCK LET LOOP BLOCK TAGBODY PROGN INCF SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK::FANCY-MAKE-COMPOUND* SNARK:HEAD SNARK::ARGS*)
; --> LET* IF FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:G681)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN #:G684)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK::REWRITE-*MOST
;      (LET ((SNARK:HEAD (SNARK:HEAD SNARK::TERM)))
;        (COND
;         ((AND SNARK::HEAD-IF-ASSOCIATIVE #)
;          (LET #
;            #))
;         (T
;          (LET #
;            #)))))
; --> BLOCK LET LOOP BLOCK TAGBODY PROGN INCF SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN REWRITE-LIST-INNERMOST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-LIST-INNERMOST
;     (SNARK-LISP:LCONS SNARK::X*
;                       (SNARK::REWRITE-LIST-INNERMOST SNARK::Y SUBST
;                                                      SNARK::HEAD-IF-ASSOCIATIVE
;                                                      (REST SNARK::POLARITY-MAP)
;                                                      (IF SNARK::NEWLY-SIMPLIFIED
;                                                          (ACONS SNARK::X
;                                                                 SNARK::X*
;                                                                 SNARK::REWRITE-ALIST)
;                                                          SNARK::REWRITE-ALIST))
;                       SNARK::TERMS)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G737 #:G739)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G737 #:G739)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN REWRITE-LIST-OUTERMOST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN REWRITE-LIST-OUTERMOST
;     (SNARK-LISP:NEQL SNARK::X* SNARK::X)
; --> 
; --> (LAMBDA (SNARK-LISP::X SNARK-LISP::Y) (NOT (EQL SNARK-LISP::X SNARK-LISP::Y))) 
; --> SB-C::%FUNCALL NOT IF 
; ==>
;   (EQL SNARK-LISP::X SNARK-LISP::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN AC-INVERSE-RULE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.lisp
; in: DEFUN AC-INVERSE-RULE-P
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN APPLY-AC-INVERSE-RULE ...)
; compiling (DEFUN APPLY-AC-INVERSE-RULE* ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite.fasl written
; compilation finished in 0:00:00.167
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN EQUALITY-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN EQUALITY-REWRITER
;     (FUNCALL SNARK::FUN ATOM SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN MAKE-CHARACTERISTIC-ATOM-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN MAKE-CHARACTERISTIC-ATOM-REWRITER
;     (FUNCALL SNARK::PRED SNARK::TERM)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::PRED)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN REFLEXIVITY-REWRITER ...)
; compiling (DEFUN IRREFLEXIVITY-REWRITER ...)
; compiling (DEFUN ASSOCIATIVE-IDENTITY-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN ASSOCIATIVE-IDENTITY-REWRITER
;     (EQL IDENTITY SNARK::X)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN ASSOCIATIVE-IDENTITY-PARAMODULATER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN ASSOCIATIVE-IDENTITY-PARAMODULATER
;     (FUNCALL SNARK::CC
;              (SNARK::MAKE-A1-COMPOUND* SNARK:HEAD IDENTITY (REVERSE SNARK::L))
;              SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (MEMBER SNARK::X SNARK::L)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (EQL IDENTITY SNARK::X)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN NONVARIABLE-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN NONVARIABLE-REWRITER
;     (SNARK:DEREFERENCE SNARK::X SUBST :IF-VARIABLE SNARK-LISP:NONE :IF-CONSTANT
;                        SNARK-LISP:TRUE :IF-COMPOUND SNARK-LISP:TRUE)
; --> COND IF COND IF COND THE PROGN 
; ==>
;   SNARK-LISP:TRUE
; 
; note: deleting unreachable code

; compiling (DEFUN THE-TERM-REWRITER ...)
; compiling (DEFUN NOT-WFF-REWRITER ...)
; compiling (DEFUN AND-WFF-REWRITER ...)
; compiling (DEFUN OR-WFF-REWRITER ...)
; compiling (DEFUN IMPLIES-WFF-REWRITER ...)
; compiling (DEFUN IMPLIED-BY-WFF-REWRITER ...)
; compiling (DEFUN IMPLIES-WFF-REWRITER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN IMPLIES-WFF-REWRITER1
;     (EQL (SNARK:ARG1 SNARK::X) SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::X (SNARK:ARG1 SNARK::Y))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::X SNARK::Y)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN DISTRIBUTIVE-LAW1-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN DISTRIBUTIVE-LAW1-P
;     (LENGTH
;      (SETF SNARK::VARS
;              (SNARK::VARIABLES SNARK::RHS SUBST
;                                (SNARK::VARIABLES SNARK::LHS SUBST))))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN CANCEL1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.lisp
; in: DEFUN CANCEL1
;     (EQL IDENTITY (CAR SNARK::ARGS2))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL IDENTITY (CAR SNARK::ARGS1))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (SNARK-LISP:CONSN (SNARK::TC-TERM SNARK::V) SNARK::ARGS2 (- COUNT))
; 
; note: doing signed word to integer coercion (cost 20)

; compiling (DEFUN MAKE-CANCEL ...)
; compiling (DEFUN DECLARE-CANCELLATION-LAW ...)
; compiling (DEFUN DISTRIBUTIVITY-REWRITER ...)
; compiling (DEFUN DECLARE-DISTRIBUTIVE-LAW ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/rewrite-code.fasl written
; compilation finished in 0:00:00.183
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-strings2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-CODE-FOR-STRINGS ...)
; compiling (DEFUN STRING-LIST-P ...)
; compiling (DEFUN STRING-TO-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-strings2.lisp
; in: DEFUN STRING-TO-LIST
;     (STRING CHAR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DEFUN LIST-TO-STRING ...)
; compiling (DEFUN LIST-TO-STRING-TERM-REWRITER ...)
; compiling (DEFUN STRING-TO-LIST-TERM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-strings2.fasl written
; compilation finished in 0:00:00.022
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SUM*)
; compiling (DEFVAR *PRODUCT*)
; compiling (DEFVAR *LESS*)
; compiling (DEFVAR *RECIPROCAL*)
; compiling (DEFUN RNUMBERP ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN RNUMBERP
;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (IMAGPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a COMPLEX, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (IMAGPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a COMPLEX, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

; compiling (DEFUN NONZERO-RNUMBERP ...)
; compiling (DEFUN NONZERO-RATIONALP ...)
; compiling (DEFUN LESS? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN LESS?
;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (< (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (REALPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (REALPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (= (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (IMAGPART SNARK::X)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (IMAGPART SNARK::Y)
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX RATIONAL).

;     (< (IMAGPART SNARK::X) (IMAGPART SNARK::Y))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (REALPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (< (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (REALPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (REALPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float realpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (= (REALPART SNARK::X) (REALPART SNARK::Y))
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (IMAGPART SNARK::X)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (IMAGPART SNARK::Y)
; 
; note: forced to do full call
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       unable to do complex float imagpart (cost 3) because:
;       The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).

;     (< (IMAGPART SNARK::X) (IMAGPART SNARK::Y))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN LESSEQ? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN LESSEQ?
;     (= SNARK::X SNARK::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.The second argument is a NUMBER, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       The second argument is a T, not a (COMPLEX DOUBLE-FLOAT).
;       etc.

; compiling (DEFUN GREATER? ...)
; compiling (DEFUN GREATEREQ? ...)
; compiling (DEFUN EUCLIDEAN-QUOTIENT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN EUCLIDEAN-QUOTIENT
;     (TRUNCATE NUMBER SNARK::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (MINUSP SNARK::REMAINDER)
; ==>
;   (< SNARK::REMAINDER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (PLUSP SNARK::DIVISOR)
; ==>
;   (> SNARK::DIVISOR 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (MINUSP SNARK::REMAINDER)
; ==>
;   (< SNARK::REMAINDER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (PLUSP SNARK::DIVISOR)
; ==>
;   (> SNARK::DIVISOR 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (- SNARK::QUOTIENT 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK::REMAINDER SNARK::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK::QUOTIENT 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK::REMAINDER SNARK::DIVISOR)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN EUCLIDEAN-REMAINDER ...)
; compiling (DEFUN CEILING-REMAINDER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN CEILING-REMAINDER
;     (CEILING NUMBER SNARK::DIVISOR)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< SB-C::DIVISOR 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ SB-C::TRU 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; ==>
;   (- REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN ROUND-REMAINDER ...)
; compiling (DEFUN DECLARE-ARITHMETIC-CHARACTERISTIC-RELATION ...)
; compiling (DEFUN DECLARE-ARITHMETIC-RELATION ...)
; compiling (DEFUN DECLARE-ARITHMETIC-FUNCTION ...)
; compiling (DEFUN DECLARE-CODE-FOR-NUMBERS ...)
; compiling (DEFUN DECLARE-ARITHMETIC-INEQUALITY-RELATIONS ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER0 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER1 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER2 ...)
; compiling (DEFUN ARITHMETIC-TERM-SORT-COMPUTER3 ...)
; compiling (DEFUN ARITHMETIC-EXPR-ARGS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-EXPR-ARGS
;     (FUNCALL SNARK::PRED SNARK::ARG)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::PRED)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (DEFUN SNARK::ARITHMETIC-EXPR-ARGS (SNARK::X SUBST SNARK::PRED)
;       (SNARK-LISP:PROG->
;         (SNARK::SPLIT-IF (SNARK:ARGS SNARK::X) SUBST SNARK::->* SNARK::ARG)
;         (OR (FUNCALL SNARK::PRED SNARK::ARG)
;             (RETURN-FROM SNARK::ARITHMETIC-EXPR-ARGS SNARK-LISP:NONE))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::ARITHMETIC-EXPR-ARGS
;     (SNARK-LISP:PROG->
;       (SNARK::SPLIT-IF (SNARK:ARGS SNARK::X) SUBST SNARK::->* SNARK::ARG)
;       (OR (FUNCALL SNARK::PRED SNARK::ARG)
;           (RETURN-FROM SNARK::ARITHMETIC-EXPR-ARGS SNARK-LISP:NONE))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM ARITHMETIC-EXPR-ARGS NONE). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN ARITHMETIC-ATOM-REWRITER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-ATOM-REWRITER1
;     (APPLY SNARK::OPERATOR SNARK:ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::OPERATOR)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ARITHMETIC-ATOM-REWRITER4 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-ATOM-REWRITER4
;     (LENGTH SNARK:ARGS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN ARITHMETIC-TERM-REWRITER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-TERM-REWRITER1
;     (APPLY SNARK::OPERATOR SNARK:ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::OPERATOR)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ARITHMETIC-TERM-REWRITER2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-TERM-REWRITER2
;     (APPLY SNARK::OPERATOR SNARK:ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::OPERATOR)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ARITHMETIC-TERM-REWRITER3 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-TERM-REWRITER3
;     (APPLY SNARK::OPERATOR SNARK::NUMS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::OPERATOR)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL SNARK::ABSORBER SNARK::NUM)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL IDENTITY SNARK::NUM)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::NUM SNARK:ARG1)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN ARITHMETIC-TERM-REWRITER4 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-TERM-REWRITER4
;     (FUNCALL SNARK::OPERATOR SNARK::ARG)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::OPERATOR)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN ARITHMETIC-TERM-REWRITER5 ...)
; compiling (DEFUN DECOMPOSE-PRODUCT-TERM ...)
; compiling (DEFUN SUM-TERM-REWRITER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN SUM-TERM-REWRITER1
;     (+ SNARK::MULT1 SNARK::MULT2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN UMINUS-TERM-REWRITER ...)
; compiling (DEFUN ARITHMETIC-RELATION-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN ARITHMETIC-RELATION-REWRITER
;     (FUNCALL SNARK::FUN ATOM SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (PUSHNEW (SNARK::FUNCTION-CODE-NAME SNARK::FN) SNARK::*REWRITES-USED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::FUN ATOM SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (PUSHNEW (SNARK::FUNCTION-CODE-NAME SNARK::FN) SNARK::*REWRITES-USED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN TERM-REL-TERM-TO-0-REL-DIFFERENCE-ATOM-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN TERM-REL-TERM-TO-0-REL-DIFFERENCE-ATOM-REWRITER
;     (PUSHNEW (SNARK::FUNCTION-CODE-NAME SNARK::*PRODUCT*) SNARK::*REWRITES-USED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (PUSHNEW (SNARK::FUNCTION-CODE-NAME SNARK::*SUM*) SNARK::*REWRITES-USED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN SUM-REL-NUMBER-ATOM-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN SUM-REL-NUMBER-ATOM-REWRITER
;     (- SNARK::B SNARK:ARG1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK::A SNARK:ARG1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN PRODUCT-REL-NUMBER-ATOM-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN PRODUCT-REL-NUMBER-ATOM-REWRITER
;     (MINUSP SNARK:ARG1)
; ==>
;   (< SNARK:ARG1 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (/ SNARK::B SNARK:ARG1)
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (MINUSP SNARK:ARG1)
; ==>
;   (< SNARK:ARG1 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (/ SNARK::A SNARK:ARG1)
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a REAL, not a INTEGER.
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (MINUSP SNARK:ARG1)
; ==>
;   (< SNARK:ARG1 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (/ SNARK::B SNARK:ARG1)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (MINUSP SNARK:ARG1)
; ==>
;   (< SNARK:ARG1 0)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (/ SNARK::A SNARK:ARG1)
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN RECIPROCAL-REL-NUMBER-ATOM-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.lisp
; in: DEFUN RECIPROCAL-REL-NUMBER-ATOM-REWRITER
;     (/ SNARK::B)
; ==>
;   (/ 1 (THE NUMBER SNARK::B))
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The second argument is a NUMBER, not a INTEGER.

;     (/ SNARK::A)
; ==>
;   (/ 1 (THE NUMBER SNARK::A))
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The second argument is a NUMBER, not a INTEGER.

; compiling (DEFMETHOD CHECKPOINT-THEORY ...)
; compiling (DEFMETHOD UNCHECKPOINT-THEORY ...)
; compiling (DEFMETHOD RESTORE-THEORY ...)
; compiling (DEFMETHOD THEORY-CLOSURE ...)
; compiling (DEFMETHOD THEORY-ASSERT ...)
; compiling (DEFMETHOD THEORY-DENY ...)
; compiling (DEFMETHOD THEORY-SIMPLIFY ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-numbers3.fasl written
; compilation finished in 0:00:00.238
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-lists2.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN DECLARE-CODE-FOR-LISTS ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-lists2.fasl written
; compilation finished in 0:00:00.003
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-bags4.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFVAR *SINGLETON-BAG*)
; compiling (DEFVAR *BAG-UNION*)
; compiling (DEFUN DECLARE-CODE-FOR-BAGS ...)
; compiling (DEFUN BAGP ...)
; compiling (DEFUN INPUT-BAG-TERM ...)
; compiling (DEFUN INPUT-BAG*-TERM ...)
; compiling (DEFUN BAG-UNION-TERM-TO-LISP ...)
; compiling (DEFUN BAG-TO-LIST ...)
; compiling (DEFUN LIST-TO-BAG ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/code-for-bags4.fasl written
; compilation finished in 0:00:00.040
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN CONSTRUCTOR-REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN CONSTRUCTOR-IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN VARIABLES-REFLEXIVITY-SATISFIER ...)
; compiling (DEFUN VARIABLES-IRREFLEXIVITY-FALSIFIER ...)
; compiling (DEFUN VARIABLE-SATISFIER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp
; in: DEFUN VARIABLE-SATISFIER
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN NONVARIABLE-SATISFIER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp
; in: DEFUN NONVARIABLE-SATISFIER
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN RESOLVE-CODE-EXAMPLE1 ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE2 ...)
; compiling (DEFUN RESOLVE-CODE-EXAMPLE2-SATISFIER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp
; in: DEFUN RESOLVE-CODE-EXAMPLE2-SATISFIER
;     (FUNCALL SNARK::CC SUBST
;              (SNARK:MAKE-COMPOUND SNARK::*NOT*
;                                   (SNARK:MAKE-COMPOUND SNARK::*=*
;                                                        (FIRST SNARK:ARGS)
;                                                        (THIRD SNARK:ARGS))))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SUBST
;              (SNARK:MAKE-COMPOUND SNARK::*NOT*
;                                   (SNARK:MAKE-COMPOUND SNARK::*=*
;                                                        (SECOND SNARK:ARGS)
;                                                        (THIRD SNARK:ARGS))))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFINE-PLIST-SLOT-ACCESSOR FUNCTION ...)
; compiling (DEFUN RESOLVE-CODE-RESOLVER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.lisp
; in: DEFUN RESOLVE-CODE-RESOLVER1
;     (SNARK-LISP:PROG->
;       (DOLIST (SNARK::FUNCTION-RESOLVE-CODE-SATISFY-CODE (SNARK:HEAD ATOM))
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN ATOM SUBST SNARK::->* SUBST SNARK::RES)
;       (SNARK::RESOLVER SNARK::NEGATOMS SNARK::POSATOMS SUBST
;                        (IF (AND SNARK::RESIDUE SNARK::RES)
;                            (SNARK::DISJOIN SNARK::RESIDUE SNARK::RES)
;                            (OR SNARK::RESIDUE SNARK::RES))))
; --> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (DOLIST (SNARK::FUNCTION-RESOLVE-CODE-FALSIFY-CODE (SNARK:HEAD ATOM))
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN ATOM SUBST SNARK::->* SUBST SNARK::RES)
;       (SNARK::RESOLVER SNARK::NEGATOMS SNARK::POSATOMS SUBST
;                        (IF (AND SNARK::RESIDUE SNARK::RES)
;                            (SNARK::DISJOIN SNARK::RESIDUE SNARK::RES)
;                            (OR SNARK::RESIDUE SNARK::RES))))
; --> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SUBST SNARK::RESIDUE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN RESOLVE-CODE-EXAMPLE3 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code.fasl written
; compilation finished in 0:00:00.203
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN TABLE-SATISFIER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.lisp
; in: DEFUN TABLE-SATISFIER
;     (SNARK-LISP:PROG->
;       (SNARK::PREDICATE-TO-TABLE (SNARK:FUNCTION-NAME (SNARK:HEAD ATOM))
;                                  SNARK::-> SNARK::TABLE SNARK::MAPPER
;                                  SNARK::EXPORTERS)
;       (FUNCALL SNARK::MAPPER SNARK::TABLE SNARK::EXPORTERS SNARK::PATTERN SUBST
;                SNARK::->* SUBST)
;       (FUNCALL SNARK::CC SUBST))
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TABLE-REWRITER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.lisp
; in: DEFUN TABLE-REWRITER
;     (SNARK-LISP:PROG->
;       (SNARK::PREDICATE-TO-TABLE (SNARK:FUNCTION-NAME (SNARK:HEAD ATOM))
;                                  SNARK::-> SNARK::TABLE SNARK::MAPPER
;                                  SNARK::EXPORTERS)
;       (FUNCALL SNARK::MAPPER SNARK::TABLE SNARK::EXPORTERS SNARK::PATTERN NIL
;                SNARK::->* SUBST)
;       (DECLARE (IGNORE SUBST))
;       (RETURN-FROM SNARK::TABLE-REWRITER SNARK-LISP:TRUE))
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION FLET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:PROG->
;       (SNARK::PREDICATE-TO-TABLE (SNARK:FUNCTION-NAME (SNARK:HEAD ATOM))
;                                  SNARK::-> SNARK::TABLE SNARK::MAPPER
;                                  SNARK::EXPORTERS)
;       (QUOTE NIL SNARK::-> SNARK::*FROZEN-VARIABLES*)
;       (FUNCALL SNARK::MAPPER SNARK::TABLE SNARK::EXPORTERS SNARK::PATTERN NIL
;                SNARK::->* SUBST)
;       (DECLARE (IGNORE SUBST))
;       (RETURN-FROM SNARK::TABLE-REWRITER SNARK-LISP:NONE))
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET FLET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::MAPPER)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TABLE-LOOKUP-PATTERN ...)
; compiling (DEFUN SIMPLE-TABLE-MAPPER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.lisp
; in: DEFUN SIMPLE-TABLE-MAPPER
;     (FUNCALL (FIRST SNARK::E) (FIRST SNARK::R))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (FIRST SNARK::E))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PREDICATE-TO-TABLE ...)
; compiling (DEFUN RELATION-TO-TABLE ...)
; compiling (DEFUN TEST-TABLE-RESOLVER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/resolve-code-tables.fasl written
; compilation finished in 0:00:00.064
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL ORDERING-IS-TOTAL ...))
; compiling (DEFVAR OPTIONS-PRINT-MODE ...)
; compiling (DEFVAR *SNARK-IS-RUNNING* ...)
; compiling (DEFVAR *AGENDA-OF-FALSE-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-NEW-EMBEDDINGS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-INPUT-ROWS-TO-GIVE*)
; compiling (DEFVAR *AGENDA-OF-INPUT-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-BACKWARD-SIMPLIFIABLE-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-ROWS-TO-PROCESS*)
; compiling (DEFVAR *AGENDA-OF-ROWS-TO-GIVE*)
; compiling (DEFVAR *PROOF*)
; compiling (DEFVAR *FALSE-ROWS*)
; compiling (DEFVAR *CONSTRAINT-ROWS*)
; compiling (DEFVAR *HINT-ROWS*)
; compiling (DEFVAR *MANUAL-ORDERING-RESULTS*)
; compiling (DEFVAR CRITIQUE-OPTIONS ...)
; compiling (DEFVAR *PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*)
; compiling (DEFVAR *NEGATIVE-HYPERRESOLUTION*)
; compiling (DEFVAR *FIND-ELSE-SUBSTITUTION* ...)
; compiling (DEFVAR *PROCESSING-ROW* ...)
; compiling (DEFVAR *HINTS-SUBSUMED*)
; compiling (DECLAIM (SPECIAL REWRITE-STRATEGY ...))
; compiling (DEFVAR RECURSIVE-UNSTORE ...)
; compiling (DEFUN CRITIQUE-OPTIONS ...)
; compiling (DEFVAR *NUMBER-OF-GIVEN-ROWS* ...)
; compiling (DEFVAR *NUMBER-OF-BACKWARD-ELIMINATED-ROWS* ...)
; compiling (DEFVAR *NUMBER-OF-AGENDA-FULL-DELETED-ROWS* ...)
; compiling (DECLAIM (TYPE INTEGER ...) ...)
; compiling (DEFUN CLEAR-STATISTICS ...)
; compiling (DEFUN PRINT-SUMMARY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PRINT-SUMMARY
;     (< 0 SNARK::TOTAL-NUMBER-OF-ROWS)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (< 0 SNARK::*NUMBER-OF-ROWS*)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       etc.

;     (- SNARK::*NUMBER-OF-BACKWARD-ELIMINATED-ROWS*
;        SNARK::*NUMBER-OF-AGENDA-FULL-DELETED-ROWS*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN PRINT-REWRITES ...)
; compiling (DEFVAR REWRITES-INITIALIZED)
; compiling (DEFPARAMETER INITIALIZATION-FUNCTIONS ...)
; compiling (DEFUN INITIALIZE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN INITIALIZE
;     (FUNCALL SNARK::FN)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN INITIALIZE-ROWS2 ...)
; compiling (DEFMACRO WITH-INPUT-FUNCTIONS-DISABLED ...)
; compiling (DEFUN INITIALIZE-AGENDA ...)
; compiling (DEFUN INITIALIZE-REWRITES ...)
; compiling (DEFUN STORE-BOOLEAN-RING-REWRITES ...)
; compiling (DEFUN RENUMBER-ROW ...)
; compiling (DEFVAR *EMBEDDING-VARIABLES* ...)
; compiling (DEFUN EMBEDDING-VARIABLE-P ...)
; compiling (DEFVAR *ASSERT-REWRITE-POLARITY* ...)
; compiling (DEFUN ASSERT-REWRITE-CHECK ...)
; compiling (DEFUN ASSERT-REWRITE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN ASSERT-REWRITE
;     (SNARK::MAKE-ROW1 SNARK::WFF)
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW1 (SNARK:ARG1 SNARK::WFF))
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW1 (SNARK:ARG2 SNARK::WFF))
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW1 (SNARK:ARG1 SNARK::WFF))
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW1 (SNARK:ARG2 SNARK::WFF))
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW1 SNARK::WFF)
; --> SNARK::MAKE-ROW PROG1 LET SNARK::MAKE-ROW0 INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> SNARK::MAKE-ROW PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFMACRO ASSERTION ...)
; compiling (DEFUN ASSERTIONFUN ...)
; compiling (DEFUN ASSERT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN ASSERT
;     (FUNCALL SNARK::CONC-NAME SNARK::WFF)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CONC-NAME)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ASSERT
;       (WHEN SNARK::NAME
;         (UNLESS (SNARK::CAN-BE-ROW-NAME SNARK::NAME 'WARN)
;           (SETF SNARK::NAME NIL)))
;       (WHEN (EQ 'SNARK:CONJECTURE SNARK::REASON)
;         (SETF SNARK::WFF `(NOT ,SNARK::WFF))
;         (SETF SNARK::REASON 'SNARK:NEGATED_CONJECTURE)
;         (SETF SNARK::*SZS-CONJECTURE* T))
;       (ASSERT
;        (MEMBER SNARK::REASON
;                '(SNARK:ASSERTION SNARK:ASSUMPTION SNARK:NEGATED_CONJECTURE
;                                  SNARK:HINT)))
;       (UNLESS SNARK::SUPPORTED-SUPPLIED
;         (SETF SNARK::SUPPORTED (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SUPPORTED '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::SEQUENTIAL-SUPPLIED
;         (SETF SNARK::SEQUENTIAL (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SEQUENTIAL '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::CONTEXT (SETF SNARK::CONTEXT (ECASE SNARK::REASON # #)))
;       (WHEN (EQ :CURRENT SNARK::CONTEXT)
;         (SETF SNARK::CONTEXT (SNARK:CURRENT-ROW-CONTEXT)))
;       (LET ((SNARK::N 0))
;         (SNARK-LISP:PROG->
;           (NOT (SNARK:USE-WELL-SORTING?) SNARK::->
;                SNARK::*%CHECK-FOR-WELL-SORTED-ATOM%*)
;           (SNARK:INPUT-WFF SNARK::WFF :CLAUSIFY (SNARK:USE-CLAUSIFICATION?)
;                            SNARK::-> SNARK::WFF SNARK::DP-ALIST SNARK::INPUT-WFF1
;                            SNARK::INPUT-WFF-SUBST)
;           (DECLARE (IGNORE SNARK::DP-ALIST))
;           (WHEN SNARK::*FIND-ELSE-SUBSTITUTION* (SETF #))
;           (MAPCAR (LAMBDA # #) SNARK::CONSTRAINTS SNARK::->
;                   SNARK::CONSTRAINT-ALIST)
;           (WHEN (EQ 'SNARK::FROM-WFF SNARK:ANSWER) (COND # # #))
;           (SNARK:INPUT-WFF SNARK:ANSWER :*INPUT-WFF-SUBSTITUTION*
;                            SNARK::INPUT-WFF-SUBST SNARK::-> SNARK:ANSWER)
;           (IF (AND SNARK::MAGIC #)
;               (SNARK::MAGIC-TRANSFORM-WFF SNARK::WFF :TRANSFORM-NEGATIVE-CLAUSES
;                                           SNARK::SUPPORTED
;                                           :TRANSFORM-POSITIVE-UNITS #)
;               SNARK::WFF
;               SNARK::->
;               SNARK::WFF)
;           (SNARK::WELL-SORT-WFFS (LIST* SNARK::WFF SNARK:ANSWER #) SNARK::->*
;                                  SUBST)
;           (INCF SNARK::N)
;           (SNARK::MAP-CONJUNCTS SNARK::WFF SNARK::->* SNARK::WFF)
;           ...)
;         (UNLESS (EQL 1 SNARK::N)
;           (SNARK-LISP:WITH-STANDARD-IO-SYNTAX2
;             (WARN "Input wff ~A has ~D well-sorted instances." SNARK::WFF
;                   SNARK::N)))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ASSERT-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:PROG->
;       (NOT (SNARK:USE-WELL-SORTING?) SNARK::->
;            SNARK::*%CHECK-FOR-WELL-SORTED-ATOM%*)
;       (SNARK:INPUT-WFF SNARK::WFF :CLAUSIFY (SNARK:USE-CLAUSIFICATION?) SNARK::->
;                        SNARK::WFF SNARK::DP-ALIST SNARK::INPUT-WFF1
;                        SNARK::INPUT-WFF-SUBST)
;       (DECLARE (IGNORE SNARK::DP-ALIST))
;       (WHEN SNARK::*FIND-ELSE-SUBSTITUTION*
;         (SETF SNARK::WFF
;                 (SNARK::INSTANTIATE SNARK::WFF SNARK::*FIND-ELSE-SUBSTITUTION*)))
;       (MAPCAR
;        (LAMBDA (SNARK::X)
;          (CONS (FIRST SNARK::X)
;                (SNARK:INPUT-WFF `# :*INPUT-WFF-SUBSTITUTION*
;                                 SNARK::INPUT-WFF-SUBST)))
;        SNARK::CONSTRAINTS SNARK::-> SNARK::CONSTRAINT-ALIST)
;       (WHEN (EQ 'SNARK::FROM-WFF SNARK:ANSWER)
;         (COND ((AND # #) (SETF #)) ((AND # # # #) (SETF #)) (T (SETF #))))
;       (SNARK:INPUT-WFF SNARK:ANSWER :*INPUT-WFF-SUBSTITUTION*
;                        SNARK::INPUT-WFF-SUBST SNARK::-> SNARK:ANSWER)
;       (IF (AND SNARK::MAGIC (NOT (EQ 'SNARK:HINT SNARK::REASON)))
;           (SNARK::MAGIC-TRANSFORM-WFF SNARK::WFF :TRANSFORM-NEGATIVE-CLAUSES
;                                       SNARK::SUPPORTED :TRANSFORM-POSITIVE-UNITS
;                                       (SNARK:TEST-OPTION29?))
;           SNARK::WFF
;           SNARK::->
;           SNARK::WFF)
;       (SNARK::WELL-SORT-WFFS
;        (LIST* SNARK::WFF SNARK:ANSWER (MAPCAR #'CDR SNARK::CONSTRAINT-ALIST))
;        SNARK::->* SUBST)
;       (INCF SNARK::N)
;       (SNARK::MAP-CONJUNCTS SNARK::WFF SNARK::->* SNARK::WFF)
;       ...)
; --> BLOCK LET MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET LET LET 
; --> FLET BLOCK FLET BLOCK CATCH 
; ==>
;   (BLOCK #:EXIT-BLOCK-1313
;     (SB-C::%WITHIN-CLEANUP :CATCH
;                            (SB-C::%CATCH (SB-C::%ESCAPE-FUN #:EXIT-BLOCK-1313)
;                             'SNARK::FAIL)
;                            (LET* ((SNARK::WFF #) (SNARK:ROW #))
;                              (WHEN (SNARK:USE-ASSERTION-ANALYSIS?)
;                                (SNARK::ASSERTION-ANALYSIS SNARK:ROW))
;                              (SNARK::RECORD-NEW-INPUT-WFF SNARK:ROW))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-BLOCK-1313 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ASSERT
;       (WHEN SNARK::NAME
;         (UNLESS (SNARK::CAN-BE-ROW-NAME SNARK::NAME 'WARN)
;           (SETF SNARK::NAME NIL)))
;       (WHEN (EQ 'SNARK:CONJECTURE SNARK::REASON)
;         (SETF SNARK::WFF `(NOT ,SNARK::WFF))
;         (SETF SNARK::REASON 'SNARK:NEGATED_CONJECTURE)
;         (SETF SNARK::*SZS-CONJECTURE* T))
;       (ASSERT
;        (MEMBER SNARK::REASON
;                '(SNARK:ASSERTION SNARK:ASSUMPTION SNARK:NEGATED_CONJECTURE
;                                  SNARK:HINT)))
;       (UNLESS SNARK::SUPPORTED-SUPPLIED
;         (SETF SNARK::SUPPORTED (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SUPPORTED '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::SEQUENTIAL-SUPPLIED
;         (SETF SNARK::SEQUENTIAL (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SEQUENTIAL '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::CONTEXT (SETF SNARK::CONTEXT (ECASE SNARK::REASON # #)))
;       (WHEN (EQ :CURRENT SNARK::CONTEXT)
;         (SETF SNARK::CONTEXT (SNARK:CURRENT-ROW-CONTEXT)))
;       (LET ((SNARK::N 0))
;         (SNARK-LISP:PROG->
;           (NOT (SNARK:USE-WELL-SORTING?) SNARK::->
;                SNARK::*%CHECK-FOR-WELL-SORTED-ATOM%*)
;           (SNARK:INPUT-WFF SNARK::WFF :CLAUSIFY (SNARK:USE-CLAUSIFICATION?)
;                            SNARK::-> SNARK::WFF SNARK::DP-ALIST SNARK::INPUT-WFF1
;                            SNARK::INPUT-WFF-SUBST)
;           (DECLARE (IGNORE SNARK::DP-ALIST))
;           (WHEN SNARK::*FIND-ELSE-SUBSTITUTION* (SETF #))
;           (MAPCAR (LAMBDA # #) SNARK::CONSTRAINTS SNARK::->
;                   SNARK::CONSTRAINT-ALIST)
;           (WHEN (EQ 'SNARK::FROM-WFF SNARK:ANSWER) (COND # # #))
;           (SNARK:INPUT-WFF SNARK:ANSWER :*INPUT-WFF-SUBSTITUTION*
;                            SNARK::INPUT-WFF-SUBST SNARK::-> SNARK:ANSWER)
;           (IF (AND SNARK::MAGIC #)
;               (SNARK::MAGIC-TRANSFORM-WFF SNARK::WFF :TRANSFORM-NEGATIVE-CLAUSES
;                                           SNARK::SUPPORTED
;                                           :TRANSFORM-POSITIVE-UNITS #)
;               SNARK::WFF
;               SNARK::->
;               SNARK::WFF)
;           (SNARK::WELL-SORT-WFFS (LIST* SNARK::WFF SNARK:ANSWER #) SNARK::->*
;                                  SUBST)
;           (INCF SNARK::N)
;           (SNARK::MAP-CONJUNCTS SNARK::WFF SNARK::->* SNARK::WFF)
;           ...)
;         (UNLESS (EQL 1 SNARK::N)
;           (SNARK-LISP:WITH-STANDARD-IO-SYNTAX2
;             (WARN "Input wff ~A has ~D well-sorted instances." SNARK::WFF
;                   SNARK::N)))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK::MAKE-ROW :WFF SNARK::WFF :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::INSTANTIATE SNARK::CONSTRAINT-ALIST SUBST))
;                      :ANSWER
;                      (IF (AND SNARK::MAGIC
;                               (SNARK::MAGIC-GOAL-OCCURS-P SNARK::WFF))
;                          SNARK-LISP:FALSE
;                          (SNARK::FAIL-WHEN-DISALLOWED
;                           (SNARK::INSTANTIATE SNARK:ANSWER SUBST)))
;                      :CONTEXT
;                      (SNARK::THE-ROW-CONTEXT2 SNARK::CONTEXT SNARK::PARTITIONS)
;                      :REASON SNARK::REASON :SUPPORTED ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::N)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::ASSERT
;       (WHEN SNARK::NAME
;         (UNLESS (SNARK::CAN-BE-ROW-NAME SNARK::NAME 'WARN)
;           (SETF SNARK::NAME NIL)))
;       (WHEN (EQ 'SNARK:CONJECTURE SNARK::REASON)
;         (SETF SNARK::WFF `(NOT ,SNARK::WFF))
;         (SETF SNARK::REASON 'SNARK:NEGATED_CONJECTURE)
;         (SETF SNARK::*SZS-CONJECTURE* T))
;       (ASSERT
;        (MEMBER SNARK::REASON
;                '(SNARK:ASSERTION SNARK:ASSUMPTION SNARK:NEGATED_CONJECTURE
;                                  SNARK:HINT)))
;       (UNLESS SNARK::SUPPORTED-SUPPLIED
;         (SETF SNARK::SUPPORTED (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SUPPORTED '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::SEQUENTIAL-SUPPLIED
;         (SETF SNARK::SEQUENTIAL (ECASE SNARK::REASON # # # #)))
;       (ASSERT (MEMBER SNARK::SEQUENTIAL '(NIL T :UNINHERITED)))
;       (UNLESS SNARK::CONTEXT (SETF SNARK::CONTEXT (ECASE SNARK::REASON # #)))
;       (WHEN (EQ :CURRENT SNARK::CONTEXT)
;         (SETF SNARK::CONTEXT (SNARK:CURRENT-ROW-CONTEXT)))
;       (LET ((SNARK::N 0))
;         (SNARK-LISP:PROG->
;           (NOT (SNARK:USE-WELL-SORTING?) SNARK::->
;                SNARK::*%CHECK-FOR-WELL-SORTED-ATOM%*)
;           (SNARK:INPUT-WFF SNARK::WFF :CLAUSIFY (SNARK:USE-CLAUSIFICATION?)
;                            SNARK::-> SNARK::WFF SNARK::DP-ALIST SNARK::INPUT-WFF1
;                            SNARK::INPUT-WFF-SUBST)
;           (DECLARE (IGNORE SNARK::DP-ALIST))
;           (WHEN SNARK::*FIND-ELSE-SUBSTITUTION* (SETF #))
;           (MAPCAR (LAMBDA # #) SNARK::CONSTRAINTS SNARK::->
;                   SNARK::CONSTRAINT-ALIST)
;           (WHEN (EQ 'SNARK::FROM-WFF SNARK:ANSWER) (COND # # #))
;           (SNARK:INPUT-WFF SNARK:ANSWER :*INPUT-WFF-SUBSTITUTION*
;                            SNARK::INPUT-WFF-SUBST SNARK::-> SNARK:ANSWER)
;           (IF (AND SNARK::MAGIC #)
;               (SNARK::MAGIC-TRANSFORM-WFF SNARK::WFF :TRANSFORM-NEGATIVE-CLAUSES
;                                           SNARK::SUPPORTED
;                                           :TRANSFORM-POSITIVE-UNITS #)
;               SNARK::WFF
;               SNARK::->
;               SNARK::WFF)
;           (SNARK::WELL-SORT-WFFS (LIST* SNARK::WFF SNARK:ANSWER #) SNARK::->*
;                                  SUBST)
;           (INCF SNARK::N)
;           (SNARK::MAP-CONJUNCTS SNARK::WFF SNARK::->* SNARK::WFF)
;           ...)
;         (UNLESS (EQL 1 SNARK::N)
;           (SNARK-LISP:WITH-STANDARD-IO-SYNTAX2
;             (WARN "Input wff ~A has ~D well-sorted instances." SNARK::WFF
;                   SNARK::N)))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%ASSERT-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN ASSUME ...)
; compiling (DEFUN PROVE ...)
; compiling (DEFUN NEW-PROVE ...)
; compiling (DEFUN HINT ...)
; compiling (DEFUN FAIL ...)
; compiling (DEFUN FAIL-WHEN-NIL ...)
; compiling (DEFUN FAIL-WHEN-TRUE ...)
; compiling (DEFUN FAIL-WHEN-FALSE ...)
; compiling (DEFUN FAIL-WHEN-CONSTRAINT-TRUE ...)
; compiling (DEFUN FAIL-WHEN-DISALLOWED ...)
; compiling (DEFVAR *CHECK-FOR-DISALLOWED-ANSWER* ...)
; compiling (DEFUN ANSWER-DISALLOWED-P ...)
; compiling (DEFUN MAKE-DEMODULANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-DEMODULANT
;     (SNARK::MAKE-ROW :WFF (SNARK::INSTANTIATE SNARK::WFF2* 1) :CONSTRAINTS
;                      (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW2) 1)
;                      :ANSWER
;                      (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK::ROW2) 1)
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK::ROW2) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK::ROW2) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-ANSWER2 ...)
; compiling (DEFMACRO MAKE-RESOLVENT-PART ...)
; compiling (DEFUN MAKE-RESOLVENT1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-RESOLVENT1
;     (SNARK::MAKE-ROW :WFF SNARK::WFF :CONSTRAINTS
;                      (SNARK::DISJOIN-ALISTS
;                       (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW1) 1
;                                           SUBST)
;                       (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW2) 2
;                                           SUBST))
;                      :ANSWER
;                      (SNARK::MAKE-ANSWER2 SNARK::ROW1 SNARK::ROW2 SUBST
;                                           SNARK::ATOM1*
;                                           (EQ SNARK-LISP:FALSE
;                                               SNARK::TRUTHVALUE1))
;                      :SUPPORTED
;                      (OR (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW1)
;                          (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW2))
;                      :SEQUENTIAL
;                      (OR (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW1)
;                          (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW2))
;                      :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-RESOLVENT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-RESOLVENT
;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE
;                       (IF (EQ SNARK-LISP:TRUE SNARK::TRUTHVALUE1)
;                           (SNARK::DISJOIN
;                            (SNARK::MAKE-RESOLVENT-PART SNARK::ROW2 SNARK::ATOM2
;                                                        SNARK::ATOM2*
;                                                        SNARK::TRUTHVALUE2 2
;                                                        SUBST)
;                            (SNARK::MAKE-RESOLVENT-PART SNARK::ROW1 SNARK::ATOM1
;                                                        SNARK::ATOM1*
;                                                        SNARK::TRUTHVALUE1 1
;                                                        SUBST))
;                           (SNARK::DISJOIN
;                            (SNARK::MAKE-RESOLVENT-PART SNARK::ROW1 SNARK::ATOM1
;                                                        SNARK::ATOM1*
;                                                        SNARK::TRUTHVALUE1 1
;                                                        SUBST)
;                            (SNARK::MAKE-RESOLVENT-PART SNARK::ROW2 SNARK::ATOM2
;                                                        SNARK::ATOM2*
;                                                        SNARK::TRUTHVALUE2 2
;                                                        SUBST))))
;                      :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::DISJOIN-ALISTS
;                        (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW1) 1
;                                            SUBST)
;                        (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW2) 2
;                                            SUBST)))
;                      :ANSWER
;                      (SNARK::MAKE-ANSWER2 SNARK::ROW1 SNARK::ROW2 SUBST
;                                           SNARK::ATOM1*
;                                           (EQ SNARK-LISP:FALSE
;                                               SNARK::TRUTHVALUE1))
;                      :SUPPORTED
;                      (OR (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW1)
;                          (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW2))
;                      :SEQUENTIAL
;                      (OR (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW1)
;                          (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW2))
;                      :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-RESOLVENTA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-RESOLVENTA
;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE
;                       (LET ((SNARK::WFF #))
;                         (IF SNARK::RESIDUE
;                             (SNARK::DISJOIN # SNARK::WFF)
;                             SNARK::WFF)))
;                      :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW1) 1
;                                           SUBST))
;                      :ANSWER
;                      (SNARK::FAIL-WHEN-DISALLOWED
;                       (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK::ROW1) 1
;                                           SUBST))
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK::ROW1) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK::ROW1) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-RESOLVENTB ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-RESOLVENTB
;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE
;                       (SNARK::INSTANTIATE SNARK::RESIDUE SUBST))
;                      :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW1) 1
;                                           SUBST))
;                      :ANSWER
;                      (SNARK::FAIL-WHEN-DISALLOWED
;                       (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK::ROW1) 1
;                                           SUBST))
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK::ROW1) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK::ROW1) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-RESOLVENTC ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-RESOLVENTC
;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE
;                       (SNARK::INSTANTIATE (SNARK:ROW-WFF SNARK:ROW) 1 SUBST))
;                      :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::INSTANTIATE SNARK::CONSTRAINT-ALIST* 1 SUBST))
;                      :ANSWER
;                      (SNARK::FAIL-WHEN-DISALLOWED
;                       (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK:ROW) 1 SUBST))
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK:ROW) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK:ROW) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-HYPERRESOLVENT-NUCLEUS-PART ...)
; compiling (DEFVAR *RESOLVE-FUNCTIONS-USED* ...)
; compiling (DEFUN MAKE-HYPERRESOLVENT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-HYPERRESOLVENT
;     (LENGTH SNARK::ELECTRONS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (DECF SNARK::K)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW :WFF SNARK::WFF :CONSTRAINTS SNARK::CONSTRAINT-ALIST :ANSWER
;                      SNARK:ANSWER :SUPPORTED SNARK::SUPPORTED :SEQUENTIAL
;                      SNARK::SEQUENTIAL :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-UR-RESOLVENT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-UR-RESOLVENT
;     (LENGTH SNARK::ELECTRONS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (DECF SNARK::K)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW :WFF
;                      (IF SNARK::TARGET-ATOM
;                          (IF (EQ :POS SNARK::TARGET-POLARITY)
;                              (SNARK::INSTANTIATE SNARK::TARGET-ATOM SUBST)
;                              (SNARK:MAKE-COMPOUND SNARK::*NOT*
;                                                   (SNARK::INSTANTIATE
;                                                    SNARK::TARGET-ATOM SUBST)))
;                          SNARK-LISP:FALSE)
;                      :CONSTRAINTS SNARK::CONSTRAINT-ALIST :ANSWER SNARK:ANSWER
;                      :SUPPORTED SNARK::SUPPORTED :SEQUENTIAL SNARK::SEQUENTIAL
;                      :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-PARAMODULANT-FORM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-PARAMODULANT-FORM
;     (FUNCALL SNARK::CC
;              (SNARK::SUBSTITUTE SNARK::VALUE1* SNARK::TERM2* SNARK::WFF2* SUBST))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-PARAMODULANT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-PARAMODULANT
;     (SNARK-LISP:PROG->
;       (SNARK::CONTEXT-INTERSECTION-P SNARK::CONTEXT1 SNARK::CONTEXT2
;                                      SNARK::->NONNIL SNARK::CONTEXT)
;       (CATCH 'SNARK::FAIL
;         (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;          (SNARK::DISJOIN-ALISTS (SNARK::INSTANTIATE # 2 SUBST)
;                                 (SNARK::INSTANTIATE # 1 SUBST))
;          SNARK::-> SNARK::CONSTRAINT)
;         (SNARK::INSTANTIATE SNARK::EQUALITY1 1 SUBST SNARK::-> SNARK::EQUALITY1*)
;         (SNARK::MAKE-ANSWER2 SNARK::ROW1 SNARK::ROW2 SUBST SNARK::EQUALITY1* T
;                              SNARK::-> SNARK:ANSWER)
;         (OR (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW1)
;             (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW2) SNARK::->
;             SNARK::SUPPORTED)
;         (OR (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW1)
;             (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW2) SNARK::->
;             SNARK::SEQUENTIAL)
;         (LIST 'SNARK:PARAMODULATE SNARK::ROW2 SNARK::ROW1 SNARK::->
;               SNARK::REASON)
;         (SNARK::MAKE-RESOLVENT-PART SNARK::ROW1 SNARK::EQUALITY1
;                                     SNARK::EQUALITY1* SNARK-LISP:FALSE 1 SUBST
;                                     SNARK::-> SNARK::W1)
;         (SNARK::INSTANTIATE SNARK::VALUE1* SUBST SNARK::-> SNARK::VALUE1*)
;         (SNARK::INSTANTIATE (SNARK:ROW-WFF SNARK::ROW2) 2 SUBST SNARK::->
;                             SNARK::WFF2*)
;         (SNARK::MAKE-PARAMODULANT-FORM SNARK::VALUE1* SNARK::TERM2* SNARK::WFF2*
;                                        SUBST SNARK::->* SNARK::W2)
;         ...))
; --> BLOCK LET WHEN IF CATCH BLOCK SB-C::%WITHIN-CLEANUP LET LET LET LET LET 
; --> LET LET LET LET FLET BLOCK CATCH 
; ==>
;   (BLOCK #:EXIT-BLOCK-2013
;     (SB-C::%WITHIN-CLEANUP :CATCH
;                            (SB-C::%CATCH (SB-C::%ESCAPE-FUN #:EXIT-BLOCK-2013)
;                             'SNARK::FAIL)
;                            (SNARK::RECORD-NEW-DERIVED-ROW
;                             (SNARK::MAKE-ROW :WFF (SNARK::FAIL-WHEN-TRUE #)
;                                              :CONSTRAINTS SNARK::CONSTRAINT
;                                              :ANSWER SNARK:ANSWER :SUPPORTED
;                                              SNARK::SUPPORTED :SEQUENTIAL
;                                              SNARK::SEQUENTIAL :CONTEXT ...))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-BLOCK-2013 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE (SNARK::DISJOIN SNARK::W1 SNARK::W2))
;                      :CONSTRAINTS SNARK::CONSTRAINT :ANSWER SNARK:ANSWER
;                      :SUPPORTED SNARK::SUPPORTED :SEQUENTIAL SNARK::SEQUENTIAL
;                      :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-PARAMODULANTA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-PARAMODULANTA
;     (SNARK-LISP:PROG->
;       (CATCH 'SNARK::FAIL
;         (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;          (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK::ROW2) 2 SUBST)
;          SNARK::-> SNARK::CONSTRAINT)
;         (SNARK::FAIL-WHEN-DISALLOWED
;          (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK::ROW2) 2 SUBST) SNARK::->
;          SNARK:ANSWER)
;         (SNARK::ROW-SUPPORTED-INHERITABLY SNARK::ROW2 SNARK::-> SNARK::SUPPORTED)
;         (SNARK::ROW-SEQUENTIAL-INHERITABLY SNARK::ROW2 SNARK::->
;                                            SNARK::SEQUENTIAL)
;         (LIST 'SNARK:PARAMODULATE SNARK::ROW2
;               (SNARK::FUNCTION-CODE-NAME (SNARK:HEAD SNARK::TERM2*)) SNARK::->
;               SNARK::REASON)
;         (SNARK::MAKE-PARAMODULANT-FORM (SNARK::INSTANTIATE SNARK::VALUE1* SUBST)
;                                        SNARK::TERM2*
;                                        (SNARK::INSTANTIATE
;                                         (SNARK:ROW-WFF SNARK::ROW2) 2 SUBST)
;                                        SUBST SNARK::->* SNARK::W2)
;         (CATCH 'SNARK::FAIL
;           (SNARK::RECORD-NEW-DERIVED-ROW
;            (SNARK::MAKE-ROW :WFF # :CONSTRAINTS SNARK::CONSTRAINT :ANSWER
;                             SNARK:ANSWER :SUPPORTED SNARK::SUPPORTED :SEQUENTIAL
;                             SNARK::SEQUENTIAL :CONTEXT ...)))))
; --> BLOCK CATCH BLOCK SB-C::%WITHIN-CLEANUP LET LET LET LET LET FLET BLOCK 
; --> CATCH 
; ==>
;   (BLOCK #:EXIT-BLOCK-2051
;     (SB-C::%WITHIN-CLEANUP :CATCH
;                            (SB-C::%CATCH (SB-C::%ESCAPE-FUN #:EXIT-BLOCK-2051)
;                             'SNARK::FAIL)
;                            (SNARK::RECORD-NEW-DERIVED-ROW
;                             (SNARK::MAKE-ROW :WFF
;                                              (SNARK::FAIL-WHEN-TRUE SNARK::W2)
;                                              :CONSTRAINTS SNARK::CONSTRAINT
;                                              :ANSWER SNARK:ANSWER :SUPPORTED
;                                              SNARK::SUPPORTED :SEQUENTIAL
;                                              SNARK::SEQUENTIAL :CONTEXT ...))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-BLOCK-2051 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (SNARK::MAKE-ROW :WFF (SNARK::FAIL-WHEN-TRUE SNARK::W2) :CONSTRAINTS
;                      SNARK::CONSTRAINT :ANSWER SNARK:ANSWER :SUPPORTED
;                      SNARK::SUPPORTED :SEQUENTIAL SNARK::SEQUENTIAL :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN CANONICALIZE-WFF ...)
; compiling (DEFUN INDEX-TERMS-IN-ATOM-OF-DERIVED-WFF ...)
; compiling (DEFUN DONT-MAKE-EMBEDDING-P ...)
; compiling (DEFUN EMBEDDING-TYPES ...)
; compiling (DEFUN STORE-REWRITE2 ...)
; compiling (DEFUN STORE-REWRITE ...)
; compiling (DEFUN MAYBE-STORE-ATOM-REWRITE ...)
; compiling (DEFUN STORE-GIVEN-ROW ...)
; compiling (DEFUN STORE-GIVEN-ROW-EQUALITY ...)
; compiling (DEFUN STORE-DERIVED-WFF ...)
; compiling (DEFUN RECURSIVELY-UNSTORE-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN RECURSIVELY-UNSTORE-WFF
;     (FUNCALL SNARK::STOP-PREDICATE SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::STOP-PREDICATE)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN UNSTORE-WFF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN UNSTORE-WFF
;     (DELETE SNARK:REWRITE (SNARK::TME-REWRITES SNARK::E) :COUNT 1)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (DELETE SNARK:ROW SNARK::L :KEY #'CAR)
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (INCF SNARK::*NUMBER-OF-BACKWARD-ELIMINATED-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-BACKWARD-ELIMINATED-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN DELETE-ROW ...)
; compiling (DEFUN DELETE-ROWS ...)
; compiling (DEFUN MAKE-SPLIT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-SPLIT
;     (SNARK::MAKE-ROW :WFF
;                      (IF (EQ :POS SNARK::POLARITY)
;                          SNARK::WFF
;                          (SNARK:MAKE-COMPOUND SNARK::*NOT* SNARK::WFF))
;                      :CONSTRAINTS SNARK::CONSTRAINT-ALIST :ANSWER
;                      (IF SNARK::SUPPRESS-ANSWER
;                          SNARK-LISP:FALSE
;                          SNARK:ANSWER)
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK:ROW) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK:ROW) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN FACTORER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN FACTORER
;     (SNARK-LISP:PROG->
;       (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::CONTEXT)
;       (SNARK-LISP:DOPAIRS (SNARK::ATOMS-IN-WFF2 (SNARK:ROW-WFF SNARK:ROW) NIL
;                                                 :POS 1)
;         SNARK::->*
;         SNARK::X
;         SNARK::Y)
;       (WHEN
;           (AND (OR (EQ # #) (EQ :BOTH #) (EQ :BOTH #))
;                (NOT (SNARK::DO-NOT-FACTOR #)) (NOT (SNARK::DO-NOT-FACTOR #))
;                (SNARK-LISP:IMPLIES (SNARK::ROW-SEQUENTIAL SNARK:ROW) (OR # #)))
;         (SNARK:UNIFY (FIRST SNARK::X) (FIRST SNARK::Y) SNARK::->* SUBST)
;         (CATCH 'SNARK::FAIL
;           (SNARK::RECORD-NEW-DERIVED-ROW
;            (SNARK::MAKE-ROW :WFF # :CONSTRAINTS # :ANSWER # :SUPPORTED #
;                             :SEQUENTIAL # :CONTEXT ...)))))
; --> BLOCK LET WHEN IF SNARK-LISP:DOPAIRS DO BLOCK LET TAGBODY TAGBODY UNLESS 
; --> IF PROGN SNARK-LISP::UNNAMED-PROG-> WHEN IF FLET BLOCK CATCH 
; ==>
;   (BLOCK #:EXIT-BLOCK-2463
;     (SB-C::%WITHIN-CLEANUP :CATCH
;                            (SB-C::%CATCH (SB-C::%ESCAPE-FUN #:EXIT-BLOCK-2463)
;                             'SNARK::FAIL)
;                            (SNARK::RECORD-NEW-DERIVED-ROW
;                             (SNARK::MAKE-ROW :WFF (SNARK::FAIL-WHEN-TRUE #)
;                                              :CONSTRAINTS
;                                              (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                                               #)
;                                              :ANSWER
;                                              (SNARK::FAIL-WHEN-DISALLOWED #)
;                                              :SUPPORTED
;                                              (SNARK::ROW-SUPPORTED SNARK:ROW)
;                                              :SEQUENTIAL
;                                              (SNARK::ROW-SEQUENTIAL SNARK:ROW)
;                                              :CONTEXT ...))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM #:EXIT-BLOCK-2463 (SB-C::%UNKNOWN-VALUES)). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (SNARK::MAKE-ROW :WFF
;                      (SNARK::FAIL-WHEN-TRUE
;                       (SNARK::INSTANTIATE (SNARK:ROW-WFF SNARK:ROW) 1 SUBST))
;                      :CONSTRAINTS
;                      (SNARK::FAIL-WHEN-CONSTRAINT-TRUE
;                       (SNARK::INSTANTIATE (SNARK:ROW-CONSTRAINTS SNARK:ROW) 1
;                                           SUBST))
;                      :ANSWER
;                      (SNARK::FAIL-WHEN-DISALLOWED
;                       (SNARK::INSTANTIATE (SNARK:ROW-ANSWER SNARK:ROW) 1 SUBST))
;                      :SUPPORTED (SNARK::ROW-SUPPORTED SNARK:ROW) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK:ROW) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN RESOLVE-WITH-X=X ...)
; compiling (DEFUN RESOLVE-WITH-X-EQ-X ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN RESOLVE-WITH-X-EQ-X
;     (SNARK-LISP:PROG->
;       (SNARK::INSTANTIATE ATOM 1 SNARK::-> SNARK::ATOM*)
;       (DOLIST (SNARK::FUNCTION-RESOLVE-CODE SNARK::REL SNARK::POLARITY)
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN SNARK::ATOM* NIL SNARK::->* SUBST &OPTIONAL
;                SNARK::RESIDUE)
;       (UNLESS SNARK::RESIDUE
;         (WHEN
;             (SNARK::MAKE-RESOLVENTA SNARK:ROW ATOM SNARK::ATOM*
;                                     (IF #
;                                         SNARK-LISP:TRUE
;                                         SNARK-LISP:FALSE)
;                                     SUBST SNARK::CONTEXT)
;           (SETF SNARK::RESOLVED T))))
; --> BLOCK LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN RESOLVE-WITH-X-EQ-X2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN RESOLVE-WITH-X-EQ-X2
;     (SNARK-LISP:PROG->
;       (SNARK::INSTANTIATE ATOM 1 SNARK::-> SNARK::ATOM*)
;       (DOLIST (SNARK::FUNCTION-RESOLVE-CODE SNARK::REL SNARK::POLARITY)
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN SNARK::ATOM* NIL SNARK::->* SUBST &OPTIONAL
;                SNARK::RESIDUE)
;       (UNLESS SNARK::RESIDUE
;         (WHEN
;             (SNARK::MAKE-RESOLVENTC SNARK:ROW SUBST SNARK::CONTEXT
;                                     (SNARK::SUBSTITUTE # ATOM
;                                                        SNARK::CONSTRAINT-ALIST))
;           (SETF SNARK::RESOLVED T))))
; --> BLOCK LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN FUNCTION-RESOLVE-CODE2 ...)
; compiling (DEFUN RESOLVER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN RESOLVER
;     (SNARK-LISP:PROG->
;       (QUOTE NIL SNARK::-> SNARK::ATOM1*)
;       (WHEN (SNARK::ROW-SUPPORTED SNARK::ROW1)
;         (DOLIST
;             (AND (SNARK:COMPOUND-P SNARK::ATOM1)
;                  (SNARK::FUNCTION-RESOLVE-CODE2 # SNARK::TRUTHVALUE1))
;          SNARK::->*
;          SNARK::FUN)
;         (FUNCALL SNARK::FUN
;                  (SNARK::SETQ-ONCE SNARK::ATOM1*
;                                    (SNARK::INSTANTIATE SNARK::ATOM1 1))
;                  NIL SNARK::->* SUBST &OPTIONAL SNARK::RESIDUE)
;         (WHEN
;             (SNARK::SELECTED-ATOM-P SNARK::ATOM1 SNARK::POLARITY1
;                                     SNARK::SELECTED-ATOMS-IN-ROW1 SNARK::ORDERFUN
;                                     SUBST 1 SNARK::ATOM1*)
;           (SNARK::MAKE-RESOLVENTA SNARK::ROW1 SNARK::ATOM1 SNARK::ATOM1*
;                                   SNARK::TRUTHVALUE1 SUBST SNARK::CONTEXT1
;                                   SNARK::RESIDUE)))
;       (SNARK::RETRIEVE-RESOLVABLE-ENTRIES SNARK::ATOM1 NIL
;                                           (IF (EQ SNARK-LISP:FALSE
;                                                   SNARK::TRUTHVALUE2)
;                                               #'SNARK::TME-ROWS-CONTAINING-ATOM-POSITIVELY
;                                               #'SNARK::TME-ROWS-CONTAINING-ATOM-NEGATIVELY)
;                                           SNARK::->* SNARK::ATOM2-ENTRY
;                                           SNARK::ROW2S)
;       (SNARK::TME-TERM SNARK::ATOM2-ENTRY SNARK::-> SNARK::ATOM2)
;       (QUOTE NIL SNARK::-> SNARK::ATOM2*)
;       (SNARK:MAP-ROWS :ROWSET SNARK::ROW2S :REVERSE T SNARK::->* SNARK::ROW2)
;       (SNARK::ROW-CONTEXT-LIVE? SNARK::ROW2 SNARK::->NONNIL SNARK::CONTEXT2)
;       (SNARK::SELECTED-ATOMS-IN-ROW SNARK::ROW2 SNARK::ORDERFUN SNARK::->
;                                     SNARK::SELECTED-ATOMS-IN-ROW2)
;       (WHEN
;           (AND (SNARK::ROW-GIVEN-P SNARK::ROW2)
;                (NOT (SNARK::ROW-HINT-P SNARK::ROW2))
;                (OR (AND # #)
;                    (SNARK::MEETS-BINARY-RESTRICTIONS-P SNARK::ROW1 SNARK::ROW2))
;                (SNARK::SELECTED-ATOM-P SNARK::ATOM2 SNARK::POLARITY2
;                                        SNARK::SELECTED-ATOMS-IN-ROW2
;                                        SNARK::ORDERFUN))
;         (SNARK::SETQ-ONCE SNARK::ATOM1* (SNARK::INSTANTIATE SNARK::ATOM1 1))
;         (SNARK::SETQ-ONCE SNARK::ATOM2* (SNARK::INSTANTIATE SNARK::ATOM2 2))
;         (SNARK:UNIFY SNARK::ATOM1* SNARK::ATOM2* NIL SNARK::->* SUBST)
;         (WHEN
;             (AND
;              (SNARK::SELECTED-ATOM-P SNARK::ATOM1 SNARK::POLARITY1
;                                      SNARK::SELECTED-ATOMS-IN-ROW1
;                                      SNARK::ORDERFUN SUBST 1 SNARK::ATOM1*)
;              (SNARK::SELECTED-ATOM-P SNARK::ATOM2 SNARK::POLARITY2
;                                      SNARK::SELECTED-ATOMS-IN-ROW2
;                                      SNARK::ORDERFUN SUBST 2 SNARK::ATOM2*))
;           (SNARK::MAKE-RESOLVENT SNARK::ROW1 SNARK::ATOM1 SNARK::ATOM1*
;                                  SNARK::TRUTHVALUE1 SNARK::ROW2 SNARK::ATOM2
;                                  SNARK::ATOM2* SNARK::TRUTHVALUE2 SUBST
;                                  SNARK::CONTEXT1 SNARK::CONTEXT2))))
; --> BLOCK LET WHEN IF DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FLET ((SNARK::RESOLVER1
;                (SNARK::ATOM1 SNARK::TRUTHVALUE1 SNARK::TRUTHVALUE2
;                 SNARK::POLARITY1 SNARK::POLARITY2)
;              (SNARK-LISP:PROG->
;                (QUOTE NIL SNARK::-> SNARK::ATOM1*)
;                (WHEN # # # #)
;                (SNARK::RETRIEVE-RESOLVABLE-ENTRIES SNARK::ATOM1 NIL # SNARK::->*
;                                                    SNARK::ATOM2-ENTRY
;                                                    SNARK::ROW2S)
;                (SNARK::TME-TERM SNARK::ATOM2-ENTRY SNARK::-> SNARK::ATOM2)
;                (QUOTE NIL SNARK::-> SNARK::ATOM2*)
;                (SNARK:MAP-ROWS :ROWSET SNARK::ROW2S :REVERSE T SNARK::->*
;                                SNARK::ROW2)
;                (SNARK::ROW-CONTEXT-LIVE? SNARK::ROW2 SNARK::->NONNIL
;                                          SNARK::CONTEXT2)
;                (SNARK::SELECTED-ATOMS-IN-ROW SNARK::ROW2 SNARK::ORDERFUN
;                                              SNARK::->
;                                              SNARK::SELECTED-ATOMS-IN-ROW2)
;                (WHEN # # # # #))))
;       (SNARK-LISP:PROG->
;         (DOLIST SNARK::SELECTED-ATOMS-IN-ROW1 SNARK::->* SNARK::X)
;         (VALUES-LIST SNARK::X SNARK::-> SNARK::ATOM1 SNARK::POLARITY1)
;         (UNLESS (EQ :NEG SNARK::POLARITY1)
;           (SNARK::RESOLVER1 SNARK::ATOM1 SNARK-LISP:FALSE SNARK-LISP:TRUE :POS
;            :NEG))
;         (UNLESS (EQ :POS SNARK::POLARITY1)
;           (SNARK::RESOLVER1 SNARK::ATOM1 SNARK-LISP:TRUE SNARK-LISP:FALSE :NEG
;            :POS))))
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN CODE-RESOLVER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN CODE-RESOLVER
;     (SNARK-LISP:PROG->
;       (WHEN (SNARK::ROW-SUPPORTED SNARK::ROW1)
;         (SNARK::ROW-CONTEXT-LIVE? SNARK::ROW1 SNARK::->NONNIL SNARK::CONTEXT1)
;         (SNARK::INSTANTIATE (SNARK:ROW-WFF SNARK::ROW1) 1 SNARK::-> SNARK::WFF1)
;         (DOLIST (SNARK:USE-RESOLVE-CODE?) SNARK::->* SNARK::FUN)
;         (FUNCALL SNARK::FUN SNARK::WFF1 NIL SNARK::->* SUBST &OPTIONAL
;                  SNARK::WFF1*)
;         (SNARK::MAKE-RESOLVENTB SNARK::ROW1 (OR SNARK::WFF1* SNARK-LISP:FALSE)
;                                 SUBST SNARK::CONTEXT1)))
; --> BLOCK WHEN IF LET WHEN IF LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFINLINE HYPERRESOLUTION-ELECTRON-POLARITY ...)
; compiling (DEFINLINE HYPERRESOLUTION-NUCLEUS-POLARITY ...)
; compiling (DEFINLINE ROW-HYPERRESOLUTION-ELECTRON-P ...)
; compiling (DEFINLINE HYPERRESOLUTION-ORDERFUN ...)
; compiling (DEFUN HYPERRESOLVER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN HYPERRESOLVER
;     (MEMBER ATOM SNARK::ATOMS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (SNARK-LISP:PROG->
;       (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::CONTEXT)
;       (WHEN (SNARK::ROW-SUPPORTED SNARK:ROW)
;         (QUOTE NIL SNARK::-> SNARK::ATOM2*)
;         (DOLIST
;             (AND (SNARK:COMPOUND-P SNARK::ATOM2)
;                  (SNARK::FUNCTION-RESOLVE-CODE2 # SNARK::POLARITY2))
;          SNARK::->*
;          SNARK::FUN)
;         (FUNCALL SNARK::FUN
;                  (SNARK::SETQ-ONCE SNARK::ATOM2*
;                                    (SNARK::INSTANTIATE SNARK::ATOM2 1))
;                  NIL SNARK::->* SUBST &OPTIONAL SNARK::RESIDUE)
;         (SNARK::SELECTED-ATOMS-IN-ROW SNARK:ROW SNARK::ORDERFUN SNARK::->
;                                       SNARK::SELECTED-ATOMS-IN-ROW)
;         (WHEN
;             (SNARK::SELECTED-ATOM-P SNARK::ATOM2 SNARK::POLARITY2
;                                     SNARK::SELECTED-ATOMS-IN-ROW SNARK::ORDERFUN
;                                     SUBST 1 SNARK::ATOM2*)
;           (SNARK::MAKE-RESOLVENTA SNARK:ROW SNARK::ATOM2 SNARK::ATOM2*
;                                   SNARK::TRUTHVALUE2 SUBST SNARK::CONTEXT
;                                   SNARK::RESIDUE))))
; --> BLOCK LET WHEN IF WHEN IF LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN HYPERRESOLVER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN HYPERRESOLVER1
;     (MEMBER ATOM SNARK::ATOMS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN HYPERRESOLVER2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN HYPERRESOLVER2
;     (SNARK-LISP:PROG->
;       (DOLIST
;           (AND (SNARK:COMPOUND-P SNARK::ATOM*)
;                (SNARK::FUNCTION-RESOLVE-CODE2 (SNARK:HEAD SNARK::ATOM*)
;                                               (IF SNARK::*NEGATIVE-HYPERRESOLUTION*
;                                                   SNARK-LISP:FALSE
;                                                   SNARK-LISP:TRUE)))
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN SNARK::ATOM* SUBST SNARK::->* SUBST &OPTIONAL
;                SNARK::RESIDUE)
;       (CONS (SNARK::FUNCTION-CODE-NAME (SNARK:HEAD SNARK::ATOM*))
;             SNARK::*RESOLVE-FUNCTIONS-USED* SNARK::->
;             SNARK::*RESOLVE-FUNCTIONS-USED*)
;       (SNARK::HYPERRESOLVER2 SNARK::NUCLEUS SNARK::ELECTRONS (REST SNARK::ATOMS*)
;                              SNARK::N
;                              (SNARK-LISP:CONS-UNLESS-NIL SNARK::RESIDUE
;                                                          SNARK::RESIDUES)
;                              SUBST))
; --> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN UR-RESOLVER ...)
; compiling (DEFUN UR-RESOLVER1 ...)
; compiling (DEFUN UR-RESOLVE1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN UR-RESOLVE1
;     (SNARK-LISP:PROG->
;       (DOLIST
;           (AND (SNARK:COMPOUND-P SNARK::ATOM1)
;                (SNARK::FUNCTION-RESOLVE-CODE2 (SNARK::HEADA SNARK::ATOM1)
;                                               SNARK::POLARITY1))
;        SNARK::->*
;        SNARK::FUN)
;       (FUNCALL SNARK::FUN SNARK::ATOM1 SUBST SNARK::->* SUBST &OPTIONAL
;                SNARK::RESIDUE)
;       (UNLESS SNARK::RESIDUE
;         (CONS (SNARK::FUNCTION-CODE-NAME (SNARK:HEAD SNARK::ATOM1))
;               SNARK::*RESOLVE-FUNCTIONS-USED* SNARK::->
;               SNARK::*RESOLVE-FUNCTIONS-USED*)
;         (SNARK::UR-RESOLVE1 SNARK::NUCLEUS SNARK::ELECTRONS SNARK::TARGET-ATOM
;                             SNARK::TARGET-POLARITY SUBST (REST SNARK::L)
;                             SNARK::K)))
; --> BLOCK DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY 
; --> SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN BACKWARD-DEMODULATE-BY ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN BACKWARD-DEMODULATE-BY
;     (PUSHNEW SNARK::ROW2 SNARK::*HINTS-SUBSUMED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL COND SNARK::PATTERN* SNARK::VALUE* SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN COND)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PARAMODULATER-FROM ...)
; compiling (DEFUN PARAMODULATER-FROM1 ...)
; compiling (DEFUN PARAMODULATER-TO ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PARAMODULATER-TO
;     (MEMBER SNARK::TERM2 SNARK::DONE)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN PARAMODULATER-TO1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PARAMODULATER-TO1
;     (SNARK-LISP:PROG->
;       (SNARK::ROW-CONTEXT-LIVE? SNARK::ROW2 SNARK::->NONNIL SNARK::CONTEXT2)
;       (WHEN (SNARK::ROW-SUPPORTED SNARK::ROW2)
;         (DOLIST
;             (AND (SNARK:COMPOUND-P SNARK::TERM2*)
;                  (SNARK::FUNCTION-PARAMODULATE-CODE #))
;          SNARK::->*
;          SNARK::FUN)
;         (FUNCALL SNARK::FUN SNARK::TERM2* NIL SNARK::->* SNARK::VALUE1* SUBST)
;         (SNARK::MAKE-PARAMODULANTA SNARK::VALUE1* SNARK::ROW2 SNARK::TERM2* SUBST
;                                    SNARK::CONTEXT2))
;       (WHEN SNARK::CODE-ONLY (RETURN-FROM SNARK::PARAMODULATER-TO1))
;       (AND (SNARK::ROW-EMBEDDING-P SNARK::ROW2)
;            (OR (SNARK:EQUAL-P SNARK::TERM2 (FIRST #) NIL)
;                (SNARK:EQUAL-P SNARK::TERM2 (SECOND #) NIL))
;            (SNARK::EMBEDDING-VARIABLES SNARK::ROW2 2) SNARK::->
;            SNARK::EMBEDDING-VARIABLES2)
;       (SNARK::RETRIEVE-PARAMODULATABLE-ENTRIES SNARK::TERM2* NIL
;                                                #'SNARK::TME-ROWS-CONTAINING-PARAMODULATABLE-EQUALITY
;                                                SNARK::->* SNARK::PATTERN1-ENTRY
;                                                SNARK::WS)
;       (SNARK::TME-TERM SNARK::PATTERN1-ENTRY SNARK::-> SNARK::PATTERN1)
;       (SNARK::INSTANTIATE SNARK::PATTERN1 1 SNARK::-> SNARK::PATTERN1*)
;       (DOLIST SNARK::WS SNARK::->* SNARK::W)
;       (CAR SNARK::W SNARK::-> SNARK::ROW1)
;       (SNARK::ROW-CONTEXT-LIVE? SNARK::ROW1 SNARK::->NONNIL SNARK::CONTEXT1)
;       (WHEN
;           (AND (NOT (SNARK::ROW-HINT-P SNARK::ROW1))
;                (SNARK::MEETS-BINARY-RESTRICTIONS-P SNARK::ROW2 SNARK::ROW1))
;         (CDR SNARK::W SNARK::-> SNARK::VALUE1)
;         (UNLESS (EQ SNARK::PATTERN1 SNARK::VALUE1)
;           (SNARK:MAKE-COMPOUND SNARK::*=* SNARK::PATTERN1 SNARK::VALUE1 SNARK::->
;                                SNARK::EQUALITY1)
;           (WHEN
;               (IF #
;                   #
;                   #)
;             (SNARK::INSTANTIATE SNARK::VALUE1 1 SNARK::-> SNARK::VALUE1*)
;             (AND SNARK::EMBEDDING-VARIABLES2 # # SNARK::->
;                  SNARK::EMBEDDING-VARIABLES1)
;             (AND SNARK::EMBEDDING-VARIABLES1 # SNARK::->
;                  SNARK::*EMBEDDING-VARIABLES*)
;             (WHEN # # #)))))
; --> BLOCK LET WHEN IF PROGN WHEN IF DOLIST BLOCK LET TAGBODY UNLESS IF PROGN 
; --> LET TAGBODY SNARK-LISP::UNNAMED-PROG-> FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL (SNARK:ROW-NUMBER SNARK::ROW1) (SNARK:ROW-NUMBER SNARK::ROW2))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PARAMODULATION-ALLOWABLE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PARAMODULATION-ALLOWABLE-P
;     (DEFUN SNARK::PARAMODULATION-ALLOWABLE-P (SNARK::TERM SNARK:ROW)
;       (SNARK-LISP:PROG->
;         (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;         (SNARK::MAP-ATOMS-IN-WFF SNARK::WFF SNARK::->* ATOM SNARK::POLARITY)
;         (IDENTITY NIL SNARK::-> SNARK::ATOM-NOT-SELECTED)
;         (COND
;          ((AND # #) (SNARK:ARGS ATOM SNARK::-> SNARK:ARGS)
;           (SNARK::SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS ATOM NIL
;                                                                      SNARK::->
;                                                                      SNARK::DIR)
;           (UNLESS # #) (UNLESS SNARK::ATOM-NOT-SELECTED #))
;          ((SNARK::OCCURS-P SNARK::TERM ATOM NIL) (WHEN # #))))
;       NIL)
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::PARAMODULATION-ALLOWABLE-P
;     (SNARK-LISP:PROG->
;       (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;       (SNARK::MAP-ATOMS-IN-WFF SNARK::WFF SNARK::->* ATOM SNARK::POLARITY)
;       (IDENTITY NIL SNARK::-> SNARK::ATOM-NOT-SELECTED)
;       (COND
;        ((AND # #) (SNARK:ARGS ATOM SNARK::-> SNARK:ARGS)
;         (SNARK::SIMPLIFICATION-ORDERING-COMPARE-EQUALITY-ARGUMENTS ATOM NIL
;                                                                    SNARK::->
;                                                                    SNARK::DIR)
;         (UNLESS # #) (UNLESS SNARK::ATOM-NOT-SELECTED #))
;        ((SNARK::OCCURS-P SNARK::TERM ATOM NIL) (WHEN # #))))
;     NIL)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM PARAMODULATION-ALLOWABLE-P T). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

; compiling (DEFUN ROWS-CONTAINING-PARAMODULATABLE-TERM ...)
; compiling (DEFUN MAKE-EMBEDDINGS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-EMBEDDINGS
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::EMBEDDING
;       (LET ((SNARK::DIR
;              (SNARK::SIMPLIFICATION-ORDERING-COMPARE-TERMS SNARK::A SNARK::B)))
;         (COND ((EQ '> SNARK::DIR) (WHEN SNARK::EMBED-A #))
;               ((EQ '< SNARK::DIR) (WHEN SNARK::EMBED-B #))
;               ((AND SNARK::EMBED-A SNARK::EMBED-B #)
;                (SNARK::MAKE-EMBEDDINGS1 SNARK::CC SNARK:ROW SNARK::A SNARK::B))
;               (T (WHEN SNARK::EMBED-A #) (WHEN SNARK::EMBED-B #)))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%EMBEDDING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%EMBEDDING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-EMBEDDINGS1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-EMBEDDINGS1
;     (FUNCALL SNARK::CC (SNARK::MAKE-EMBEDDING SNARK:ROW SNARK::A* SNARK::B* T))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK::MAKE-EMBEDDING SNARK:ROW SNARK::A* SNARK::B* :L))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK::MAKE-EMBEDDING SNARK:ROW SNARK::A* SNARK::B* :R))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC (SNARK::MAKE-EMBEDDING SNARK:ROW SNARK::A* SNARK::B* :L&R))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-EMBEDDING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAKE-EMBEDDING
;     (SNARK::MAKE-ROW :WFF (SNARK::MAKE-EQUALITY SNARK::A1 SNARK::B1 NIL)
;                      :CONSTRAINTS (SNARK:ROW-CONSTRAINTS SNARK:ROW) :ANSWER
;                      (SNARK:ROW-ANSWER SNARK:ROW) :SUPPORTED
;                      (SNARK::ROW-SUPPORTED SNARK:ROW) :SEQUENTIAL
;                      (SNARK::ROW-SEQUENTIAL SNARK:ROW) :CONTEXT ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN EMBEDDING-VARIABLES ...)
; compiling (DEFUN ALLOWABLE-EMBEDDING-SUPERPOSITION ...)
; compiling (DEFUN DO-NOT-PARAMODULATE ...)
; compiling (DEFUN MEETS-BINARY-RESTRICTIONS-P ...)
; compiling (DEFUN IMPOSE-BINARY-RESTRICTIONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN IMPOSE-BINARY-RESTRICTIONS
;     (FUNCALL SNARK::KEY SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::KEY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PROCESS-NEW-ROW-MSG ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PROCESS-NEW-ROW-MSG
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (FORMAT T "~%; ")
;       (APPLY #'FORMAT T SNARK::CONTROL-STRING SNARK:ARGS))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAYBE-NEW-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN MAYBE-NEW-ROW
;     (SNARK::MAKE-ROW :WFF (SNARK:ROW-WFF SNARK:ROW) :CONSTRAINTS
;                      (SNARK:ROW-CONSTRAINTS SNARK:ROW) :ANSWER
;                      (SNARK:ROW-ANSWER SNARK:ROW) :REASON SNARK:ROW :CONTEXT
;                      (SNARK::ROW-CONTEXT SNARK:ROW) :SUPPORTED ...)
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::*NUMBER-OF-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::*NUMBER-OF-BACKWARD-ELIMINATED-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-BACKWARD-ELIMINATED-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PROCESS-NEW-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN PROCESS-NEW-ROW
;     (SETF (SNARK::FUNCTION-CREATED-P SNARK::FN) T)
; --> LET* 
; ==>
;   SNARK::FN
; 
; note: deleting unreachable code

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK:ANSWER NIL))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITE-CONSTRAINT-ALIST SNARK::CONSTRAINTS))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;       (LET ((SNARK::WFF* (SNARK::CONDENSER SNARK::WFF)))
;         (UNLESS (EQ SNARK::WFF SNARK::WFF*)
;           (SETF SNARK:ROW #)
;           (SETF # #)
;           (SETF # #))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%CONDENSING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SIMPLIFICATION
;       (SNARK::BACKWARD-DEMODULATE-BY SNARK:ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%BACKWARD-SIMPLIFICATION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::FUN SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PROCESS-NEW-ROW
;       (LET ((SNARK::*PROCESSING-ROW* SNARK:ROW)
;             (SNARK::WFF (SNARK:ROW-WFF SNARK:ROW))
;             (SNARK::*REWRITING-ROW-CONTEXT* (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW)))
;         (UNLESS SNARK::*REWRITING-ROW-CONTEXT*
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK:PRINT-ROWS-WHEN-PROCESSED?)
;           (SNARK::PRINT-PROCESSED-ROW SNARK:ROW))
;         (WHEN (EQ SNARK-LISP:TRUE SNARK::WFF)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff is true.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK::ROW-PURE SNARK:ROW)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row is pure.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN
;             (AND (EQ SNARK::AGENDA SNARK::*AGENDA-OF-ROWS-TO-PROCESS*)
;                  (LOOP SNARK::FOR SNARK::PARENT SNARK::IN #
;                        SNARK::THEREIS #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row parent is deleted.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (AND (SNARK:USE-CLAUSIFICATION?) (NOT #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;           (SNARK::CLAUSIFY SNARK::WFF (LAMBDA # #))
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (DOLIST (SNARK::FUN (SNARK:PRUNING-TESTS-BEFORE-SIMPLIFICATION?))
;           (WHEN (FUNCALL SNARK::FUN SNARK:ROW)
;             (SNARK::PROCESS-NEW-ROW-MSG
;              "Row is unacceptable before simplification.")
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL)))
;         (LET ((SNARK:ANSWER #)
;               SNARK::CONSTRAINT-ALIST
;               (SNARK::AND-SPLIT-THIS NIL))
;           (WHEN (AND # #)
;             (LET #
;               #
;               #))
;           (LET (#)
;             (WHEN # # #))
;           (SETF SNARK::CONSTRAINT-ALIST #)
;           (WHEN SNARK::CONSTRAINT-ALIST
;             (SNARK-LISP:WITH-CLOCK-OFF SNARK::CONSTRAINT-SIMPLIFICATION
;               #))
;           (DOLIST (SNARK::X SNARK::CONSTRAINT-ALIST) (WHEN # # #))
;           (WHEN (AND # #)
;             (LET* #
;               #))
;           (WHEN (OR SNARK::AND-SPLIT-THIS #)
;             (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;             (SNARK::CLAUSIFY SNARK::WFF #)
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;           (WHEN (AND # # # # #)
;             (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;               #))
;           (UNLESS (OR # # # #)
;             (LET #
;               #))
;           (DOLIST (SNARK::FUN #) (WHEN # # #))
;           ...)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PROCESS-NEW-ROW-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK::WFF NIL))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL SNARK::FUN SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::FUN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK:ANSWER NIL))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SIMPLIFICATION
;       (SNARK::BACKWARD-DEMODULATE-BY SNARK:ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK::WFF NIL))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITE-CONSTRAINT-ALIST SNARK::CONSTRAINTS))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PROCESS-NEW-ROW
;       (LET ((SNARK::*PROCESSING-ROW* SNARK:ROW)
;             (SNARK::WFF (SNARK:ROW-WFF SNARK:ROW))
;             (SNARK::*REWRITING-ROW-CONTEXT* (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW)))
;         (UNLESS SNARK::*REWRITING-ROW-CONTEXT*
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK:PRINT-ROWS-WHEN-PROCESSED?)
;           (SNARK::PRINT-PROCESSED-ROW SNARK:ROW))
;         (WHEN (EQ SNARK-LISP:TRUE SNARK::WFF)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff is true.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK::ROW-PURE SNARK:ROW)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row is pure.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN
;             (AND (EQ SNARK::AGENDA SNARK::*AGENDA-OF-ROWS-TO-PROCESS*)
;                  (LOOP SNARK::FOR SNARK::PARENT SNARK::IN #
;                        SNARK::THEREIS #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row parent is deleted.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (AND (SNARK:USE-CLAUSIFICATION?) (NOT #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;           (SNARK::CLAUSIFY SNARK::WFF (LAMBDA # #))
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (DOLIST (SNARK::FUN (SNARK:PRUNING-TESTS-BEFORE-SIMPLIFICATION?))
;           (WHEN (FUNCALL SNARK::FUN SNARK:ROW)
;             (SNARK::PROCESS-NEW-ROW-MSG
;              "Row is unacceptable before simplification.")
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL)))
;         (LET ((SNARK:ANSWER #)
;               SNARK::CONSTRAINT-ALIST
;               (SNARK::AND-SPLIT-THIS NIL))
;           (WHEN (AND # #)
;             (LET #
;               #
;               #))
;           (LET (#)
;             (WHEN # # #))
;           (SETF SNARK::CONSTRAINT-ALIST #)
;           (WHEN SNARK::CONSTRAINT-ALIST
;             (SNARK-LISP:WITH-CLOCK-OFF SNARK::CONSTRAINT-SIMPLIFICATION
;               #))
;           (DOLIST (SNARK::X SNARK::CONSTRAINT-ALIST) (WHEN # # #))
;           (WHEN (AND # #)
;             (LET* #
;               #))
;           (WHEN (OR SNARK::AND-SPLIT-THIS #)
;             (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;             (SNARK::CLAUSIFY SNARK::WFF #)
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;           (WHEN (AND # # # # #)
;             (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;               #))
;           (UNLESS (OR # # # #)
;             (LET #
;               #))
;           (DOLIST (SNARK::FUN #) (WHEN # # #))
;           ...)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PROCESS-NEW-ROW-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK::WFF NIL))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITER SNARK:ANSWER NIL))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SIMPLIFICATION
;       (SNARK::REWRITE-CONSTRAINT-ALIST SNARK::CONSTRAINTS))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SIMPLIFICATION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;       (LET ((SNARK::WFF* (SNARK::CONDENSER SNARK::WFF)))
;         (UNLESS (EQ SNARK::WFF SNARK::WFF*)
;           (SETF SNARK:ROW #)
;           (SETF # #)
;           (SETF # #))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%CONDENSING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK::*NUMBER-OF-ROWS* 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::*NUMBER-OF-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SIMPLIFICATION
;       (SNARK::BACKWARD-DEMODULATE-BY SNARK:ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%BACKWARD-SIMPLIFICATION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PROCESS-NEW-ROW
;       (LET ((SNARK::*PROCESSING-ROW* SNARK:ROW)
;             (SNARK::WFF (SNARK:ROW-WFF SNARK:ROW))
;             (SNARK::*REWRITING-ROW-CONTEXT* (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW)))
;         (UNLESS SNARK::*REWRITING-ROW-CONTEXT*
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK:PRINT-ROWS-WHEN-PROCESSED?)
;           (SNARK::PRINT-PROCESSED-ROW SNARK:ROW))
;         (WHEN (EQ SNARK-LISP:TRUE SNARK::WFF)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff is true.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (SNARK::ROW-PURE SNARK:ROW)
;           (SNARK::PROCESS-NEW-ROW-MSG "Row is pure.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN
;             (AND (EQ SNARK::AGENDA SNARK::*AGENDA-OF-ROWS-TO-PROCESS*)
;                  (LOOP SNARK::FOR SNARK::PARENT SNARK::IN #
;                        SNARK::THEREIS #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row parent is deleted.")
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (WHEN (AND (SNARK:USE-CLAUSIFICATION?) (NOT #))
;           (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;           (SNARK::CLAUSIFY SNARK::WFF (LAMBDA # #))
;           (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;         (DOLIST (SNARK::FUN (SNARK:PRUNING-TESTS-BEFORE-SIMPLIFICATION?))
;           (WHEN (FUNCALL SNARK::FUN SNARK:ROW)
;             (SNARK::PROCESS-NEW-ROW-MSG
;              "Row is unacceptable before simplification.")
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL)))
;         (LET ((SNARK:ANSWER #)
;               SNARK::CONSTRAINT-ALIST
;               (SNARK::AND-SPLIT-THIS NIL))
;           (WHEN (AND # #)
;             (LET #
;               #
;               #))
;           (LET (#)
;             (WHEN # # #))
;           (SETF SNARK::CONSTRAINT-ALIST #)
;           (WHEN SNARK::CONSTRAINT-ALIST
;             (SNARK-LISP:WITH-CLOCK-OFF SNARK::CONSTRAINT-SIMPLIFICATION
;               #))
;           (DOLIST (SNARK::X SNARK::CONSTRAINT-ALIST) (WHEN # # #))
;           (WHEN (AND # #)
;             (LET* #
;               #))
;           (WHEN (OR SNARK::AND-SPLIT-THIS #)
;             (SNARK::PROCESS-NEW-ROW-MSG "Row wff will be and-split.")
;             (SNARK::CLAUSIFY SNARK::WFF #)
;             (RETURN-FROM SNARK::PROCESS-NEW-ROW NIL))
;           (WHEN (AND # # # # #)
;             (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;               #))
;           (UNLESS (OR # # # #)
;             (LET #
;               #))
;           (DOLIST (SNARK::FUN #) (WHEN # # #))
;           ...)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::CONDENSING
;       (LET ((SNARK::WFF* (SNARK::CONDENSER SNARK::WFF)))
;         (UNLESS (EQ SNARK::WFF SNARK::WFF*)
;           (SETF SNARK:ROW #)
;           (SETF # #)
;           (SETF # #))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN ROW-PREF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN ROW-PREF
;     (FUNCALL (SNARK:AGENDA-ORDERING-FUNCTION?) SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (SNARK:AGENDA-ORDERING-FUNCTION?))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN AGENDA-ITEM-ROW ...)
; compiling (DEFUN AGENDA-ITEM-VAL ...)
; compiling (DEFUN SAME-AGENDA-ITEM-P ...)
; compiling (DEFUN UNSTORE-AGENDA-ITEM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN UNSTORE-AGENDA-ITEM
;     (DELETE SNARK::FORM (SNARK::ROW-AGENDA-ENTRIES SNARK:ROW))
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

;     (INCF SNARK::*NUMBER-OF-AGENDA-FULL-DELETED-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-AGENDA-FULL-DELETED-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INSERT-ROW-INTO-AGENDA ...)
; compiling (DEFUN DELETE-ROW-FROM-AGENDA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN DELETE-ROW-FROM-AGENDA
;     (FUNCALL SNARK::TEST SNARK::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::TEST)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN POP-FORM-FROM-AGENDA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN POP-FORM-FROM-AGENDA
;     (DELETE SNARK::FORM (SNARK::ROW-AGENDA-ENTRIES SNARK::X))
; 
; note: unable to convert to EQ test due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

; compiling (DEFUN RECORD-NEW-EMBEDDING ...)
; compiling (DEFUN RECORD-NEW-INPUT-WFF ...)
; compiling (DEFUN RECORD-BACKWARD-SIMPLIFIABLE-WFF ...)
; compiling (DEFUN RECORD-NEW-DERIVED-ROW ...)
; compiling (DEFUN RECORD-NEW-ROW-TO-GIVE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN RECORD-NEW-ROW-TO-GIVE
;     (<= (SNARK:ROW-LEVEL SNARK:ROW) SNARK::P)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN RECORD-NEW-ROW-TO-GIVE-AGAIN ...)
; compiling (DEFUN GIVER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN GIVER
;     (RETURN-FROM SNARK::GIVER NIL)
; 
; note: deleting unreachable code
; 
; note: deleting unreachable code

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* NIL))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* T))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::UR-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PARAMODULATION
;       (SNARK::PARAMODULATER-FROM SNARK::GIVEN-ROW)
;       (SNARK::PARAMODULATER-TO SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PARAMODULATION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::CODE-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FACTORING
;       (SNARK::FACTORER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FACTORING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* T))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FACTORING
;       (SNARK::FACTORER SNARK::GIVEN-ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PARAMODULATION
;       (SNARK::PARAMODULATER-FROM SNARK::GIVEN-ROW)
;       (SNARK::PARAMODULATER-TO SNARK::GIVEN-ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::UR-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::CODE-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* NIL))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK::*NUMBER-OF-GIVEN-ROWS*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::*NUMBER-OF-GIVEN-ROWS*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FACTORING
;       (SNARK::FACTORER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FACTORING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* NIL))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (LET ((SNARK::*NEGATIVE-HYPERRESOLUTION* T))
;         (SNARK::HYPERRESOLVER SNARK::GIVEN-ROW)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::UR-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PARAMODULATION
;       (SNARK::PARAMODULATER-FROM SNARK::GIVEN-ROW)
;       (SNARK::PARAMODULATER-TO SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PARAMODULATION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::RESOLUTION
;       (SNARK::CODE-RESOLVER SNARK::GIVEN-ROW))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%RESOLUTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN GIVE-CONSTRAINT-ROW ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN GIVE-CONSTRAINT-ROW
;     (INCF SNARK::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK::MAKE-ROW :WFF SNARK-LISP:FALSE :ANSWER
;                      (LET ((SNARK::N 0))
;                        (SNARK::DISJOIN*
;                         (SNARK:ROWS :COLLECT (LAMBDA # #) :ROWSET
;                                     SNARK::*CONSTRAINT-ROWS* :REVERSE T)))
;                      :CONTEXT (SNARK::ROW-CONTEXT SNARK::GIVEN-ROW) :REASON
;                      `(SNARK:COMBINE
;                        ,@(SNARK:ROWS :ROWSET SNARK::*CONSTRAINT-ROWS* :REVERSE
;                                      T)))
; --> PROG1 LET INCF SETQ THE 
; ==>
;   (+ 1 SNARK::*ROW-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN INITIALIZE-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS ...)
; compiling (DEFUN CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SATISFIABILITY-TESTING
;       (LET ((SNARK::CLAUSE-SET SNARK::*PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*))
;         (SNARK-LISP:PROG->
;           (SNARK-AGENDA:MAPNCONC-AGENDA SNARK::*AGENDA-OF-INPUT-ROWS-TO-PROCESS*
;                                         SNARK::->* SNARK::X)
;           (SECOND SNARK::X SNARK::-> SNARK:ROW)
;           (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;           (QUOTE T SNARK::-> SNARK::*PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP*)
;           (SNARK:TERM-TO-LISP SNARK::WFF SNARK::-> SNARK::WFF*)
;           (COND (# #) (# #))
;           NIL)
;         (SNARK-DPLL:DP-SATISFIABLE-P SNARK::CLAUSE-SET :FIND-ALL-MODELS 1
;                                      :PRINT-SUMMARY NIL :PRINT-WARNINGS NIL
;                                      :TRACE NIL :TRACE-CHOICES NIL ...)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SATISFIABILITY-TESTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (DEFUN SNARK::CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS ()
;       (SNARK-LISP:WITH-CLOCK-ON SNARK::SATISFIABILITY-TESTING
;         (LET ((SNARK::CLAUSE-SET
;                SNARK::*PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*))
;           (SNARK-LISP:PROG->
;             (SNARK-AGENDA:MAPNCONC-AGENDA
;              SNARK::*AGENDA-OF-INPUT-ROWS-TO-PROCESS* SNARK::->* SNARK::X)
;             (SECOND SNARK::X SNARK::-> SNARK:ROW)
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (QUOTE T SNARK::-> SNARK::*PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP*)
;             (SNARK:TERM-TO-LISP SNARK::WFF SNARK::-> SNARK::WFF*)
;             (COND # #)
;             NIL)
;           (SNARK-DPLL:DP-SATISFIABLE-P SNARK::CLAUSE-SET :FIND-ALL-MODELS 1
;                                        :PRINT-SUMMARY NIL :PRINT-WARNINGS NIL
;                                        :TRACE NIL :TRACE-CHOICES NIL ...))))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK::CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SATISFIABILITY-TESTING
;       (LET ((SNARK::CLAUSE-SET
;              SNARK::*PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*))
;         (SNARK-LISP:PROG->
;           (SNARK-AGENDA:MAPNCONC-AGENDA
;            SNARK::*AGENDA-OF-INPUT-ROWS-TO-PROCESS* SNARK::->* SNARK::X)
;           (SECOND SNARK::X SNARK::-> SNARK:ROW)
;           (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;           (QUOTE T SNARK::-> SNARK::*PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP*)
;           (SNARK:TERM-TO-LISP SNARK::WFF SNARK::-> SNARK::WFF*)
;           (COND # #)
;           NIL)
;         (SNARK-DPLL:DP-SATISFIABLE-P SNARK::CLAUSE-SET :FIND-ALL-MODELS 1
;                                      :PRINT-SUMMARY NIL :PRINT-WARNINGS NIL
;                                      :TRACE NIL :TRACE-CHOICES NIL ...))))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM CHECK-PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS NIL). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::SATISFIABILITY-TESTING
;       (LET ((SNARK::CLAUSE-SET SNARK::*PROPOSITIONAL-ABSTRACTION-OF-INPUT-WFFS*))
;         (SNARK-LISP:PROG->
;           (SNARK-AGENDA:MAPNCONC-AGENDA SNARK::*AGENDA-OF-INPUT-ROWS-TO-PROCESS*
;                                         SNARK::->* SNARK::X)
;           (SECOND SNARK::X SNARK::-> SNARK:ROW)
;           (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;           (QUOTE T SNARK::-> SNARK::*PROPOSITIONAL-ABSTRACTION-TERM-TO-LISP*)
;           (SNARK:TERM-TO-LISP SNARK::WFF SNARK::-> SNARK::WFF*)
;           (COND (# #) (# #))
;           NIL)
;         (SNARK-DPLL:DP-SATISFIABLE-P SNARK::CLAUSE-SET :FIND-ALL-MODELS 1
;                                      :PRINT-SUMMARY NIL :PRINT-WARNINGS NIL
;                                      :TRACE NIL :TRACE-CHOICES NIL ...)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%SATISFIABILITY-TESTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN CLOSURE-INIT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN CLOSURE-INIT
;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WARN "Propositional abstraction of input is satisfiable with model ~S."
;             (FIRST SNARK::V)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PURITY-TESTING
;       (SNARK::PURITY-TEST
;        #'(LAMBDA (SNARK::CC)
;            (SNARK-LISP:PROG->
;              (DOLIST SNARK-AGENDA:*AGENDA* SNARK::->* SNARK::AGENDA)
;              (SNARK-AGENDA:MAPNCONC-AGENDA SNARK::AGENDA SNARK::->* SNARK::FORM)
;              (FUNCALL SNARK::CC #)
;              NIL))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PURITY-TESTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::CRITIQUE-OPTIONS))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PURITY-TESTING
;       (SNARK::PURITY-TEST
;        #'(LAMBDA (SNARK::CC)
;            (SNARK-LISP:PROG->
;              (DOLIST SNARK-AGENDA:*AGENDA* SNARK::->* SNARK::AGENDA)
;              (SNARK-AGENDA:MAPNCONC-AGENDA SNARK::AGENDA SNARK::->* SNARK::FORM)
;              (FUNCALL SNARK::CC #)
;              NIL))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WARN "Propositional abstraction of input is satisfiable with model ~S."
;             (FIRST SNARK::V)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::CRITIQUE-OPTIONS))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (WARN "Propositional abstraction of input is satisfiable with model ~S."
;             (FIRST SNARK::V)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PRINTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PURITY-TESTING
;       (SNARK::PURITY-TEST
;        #'(LAMBDA (SNARK::CC)
;            (SNARK-LISP:PROG->
;              (DOLIST SNARK-AGENDA:*AGENDA* SNARK::->* SNARK::AGENDA)
;              (SNARK-AGENDA:MAPNCONC-AGENDA SNARK::AGENDA SNARK::->* SNARK::FORM)
;              (FUNCALL SNARK::CC #)
;              NIL))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%PURITY-TESTING-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::PRINTING
;       (SNARK::CRITIQUE-OPTIONS))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (FUNCALL SNARK::CC (SECOND SNARK::FORM))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN GIVE-IS-NEXT-IN-AGENDA ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN GIVE-IS-NEXT-IN-AGENDA
;     (< 0 (SNARK-AGENDA:AGENDA-LENGTH SNARK::AGENDA))
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (STRING= SNARK::NAME "rows to give")
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (STRING= SNARK::NAME "input rows to give")
; ==>
;   (SB-KERNEL:STRING=* SB-C::STRING1 SB-C::STRING2 SB-C::START1 SB-C::END1
;                       SB-C::START2 SB-C::END2)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a STRING.

;     (< 0 (SNARK-AGENDA:AGENDA-LENGTH SNARK::AGENDA))
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN CLOSURE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.lisp
; in: DEFUN CLOSURE
;     (APPLY (CAR SNARK::FORM) (CDR SNARK::FORM))
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (CAR SNARK::FORM))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (BREAK "Break in closure at user request."))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%HALTED-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (WHEN (YES-OR-NO-P "Stop now? ") (RETURN :USER-QUIT)))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%HALTED-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (<= SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT SNARK::*NUMBER-OF-GIVEN-ROWS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK:NUMBER-OF-ROWS-LIMIT SNARK::*NUMBER-OF-ROWS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (<= SNARK:RUN-TIME-LIMIT (SNARK-LISP:TOTAL-RUN-TIME))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (BREAK "Break in closure at user request."))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (WHEN (YES-OR-NO-P "Stop now? ") (RETURN :USER-QUIT)))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT SNARK::*NUMBER-OF-GIVEN-ROWS*)
; --> SETQ THE 
; ==>
;   (+ SNARK::*NUMBER-OF-GIVEN-ROWS* SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK:NUMBER-OF-ROWS-LIMIT SNARK::*NUMBER-OF-ROWS*)
; --> SETQ THE 
; ==>
;   (+ SNARK::*NUMBER-OF-ROWS* SNARK:NUMBER-OF-ROWS-LIMIT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (INCF SNARK:RUN-TIME-LIMIT (SNARK-LISP:TOTAL-RUN-TIME))
; --> SETQ THE 
; ==>
;   (+ (SNARK-LISP:TOTAL-RUN-TIME) SNARK:RUN-TIME-LIMIT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (<= SNARK:NUMBER-OF-GIVEN-ROWS-LIMIT SNARK::*NUMBER-OF-GIVEN-ROWS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (<= SNARK:NUMBER-OF-ROWS-LIMIT SNARK::*NUMBER-OF-ROWS*)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (<= SNARK:RUN-TIME-LIMIT (SNARK-LISP:TOTAL-RUN-TIME))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (WHEN (YES-OR-NO-P "Stop now? ") (RETURN :USER-QUIT)))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%HALTED-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::HALTED
;       (CLEAR-INPUT)
;       (BREAK "Break in closure at user request."))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%HALTED-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PROOF ...)
; compiling (DEFUN PROOFS ...)
; compiling (DEFUN ANSWER ...)
; compiling (DEFUN ANSWERS ...)
; compiling (DEFUN MAKE-SNARK-SYSTEM ...)
; compiling (DEFUN SAVE-SNARK-SYSTEM ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/main.fasl written
; compilation finished in 0:00:01.250
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DECLAIM (SPECIAL *FALSE-ROWS* ...))
; compiling (DEFVAR *SUBSUMING* ...)
; compiling (DEFUN MAKE-AND-FREEZE-VARIABLE ...)
; compiling (DEFUN SUBSUME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN SUBSUME
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN SUBSUMES-P ...)
; compiling (DEFUN SUBSUMES-P1 ...)
; compiling (DEFUN SUBSUMED-P ...)
; compiling (DEFUN SUBSUMED-P1 ...)
; compiling (DEFUN SUBSUMERS ...)
; compiling (DEFUN SUBSUMERS1 ...)
; compiling (DEFVAR CLAUSE-SUBSUMPTION ...)
; compiling (DEFVAR SUBSUMPTION-MARK)
; compiling (DEFUN FORWARD-SUBSUMED ...)
; compiling (DEFUN FORWARD-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN FORWARD-SUBSUMPTION
;     (FUNCALL SNARK::CC SNARK::ROW2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::FSUBSUME #
;                  #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (WHEN # # #)
;             (COND # # #)))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SUBSUMPTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::SUBSUMPTION-MARK)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::SUBSUMPTION-MARK)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::FSUBSUME #
;                  #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (WHEN # # #)
;             (COND # # #)))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%FORWARD-SUBSUMPTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::SUBSUMPTION-MARK)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::SUBSUMPTION-MARK)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::FORWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::FSUBSUME #
;                  #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (WHEN # # #)
;             (COND # # #)))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN BACKWARD-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN BACKWARD-SUBSUMPTION
;     (PUSHNEW SNARK::ROW2 SNARK::*HINTS-SUBSUMED*)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL SNARK::CC SNARK::ROW2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::BSUBSUME #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (COND # # #)))))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%BACKWARD-SUBSUMPTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::SUBSUMPTION-MARK)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::SUBSUMPTION-MARK)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::BSUBSUME #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (COND # # #)))))
; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%BACKWARD-SUBSUMPTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::SUBSUMPTION-MARK)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::SUBSUMPTION-MARK)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::BACKWARD-SUBSUMPTION
;       (SNARK-LISP:PROG->
;         (SNARK::ROW-CONTEXT-LIVE? SNARK:ROW SNARK::->NONNIL SNARK::ROW-CONTEXT)
;         (FLET ((SNARK::BSUBSUME #
;                  #))
;           (SNARK-LISP:PROG->
;             (SNARK:ROW-WFF SNARK:ROW SNARK::-> SNARK::WFF)
;             (COND # # #)))))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN FORWARD-CLAUSE-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN FORWARD-CLAUSE-SUBSUMPTION
;     (FUNCALL SNARK::CC SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN BACKWARD-CLAUSE-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN BACKWARD-CLAUSE-SUBSUMPTION
;     (FUNCALL SNARK::CC SNARK:ROW)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN CLAUSE-SUBSUMPTION ...)
; compiling (DEFUN CLAUSE-SUBSUMPTION1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN CLAUSE-SUBSUMPTION1
;     (SNARK::CLAUSE-P SNARK::SUBSUMING-ANSWER)
; ==>
;   SNARK::SUBSUMING-ANSWER
; 
; note: deleting unreachable code

;     (SNARK::CLAUSE-P SNARK::SUBSUMED-ANSWER)
; ==>
;   SNARK::SUBSUMED-ANSWER
; 
; note: deleting unreachable code

;     (SNARK-LISP:PROG->
;       (COND
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMING-ANSWER)
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;                                  SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        ((EQ SNARK-LISP:FALSE SNARK::SUBSUMED-ANSWER))
;        ((AND NIL (SNARK::CLAUSE-P SNARK::SUBSUMING-ANSWER)
;              (SNARK::CLAUSE-P SNARK::SUBSUMED-ANSWER))
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMING-ANSWER SNARK::-> SNARK::ANS1)
;         (SNARK::ATOMS-IN-CLAUSE2 SNARK::SUBSUMED-ANSWER SNARK::-> SNARK::ANS2)
;         (ASSERT
;          (SNARK::DISJOINT-ANSWER-RELATIONS-P SNARK::L1 SNARK::L2 SNARK::ANS1
;                                              SNARK::ANS2))
;         (SNARK::CLAUSE-SUBSUMES1 (APPEND SNARK::ANS1 SNARK::L1)
;                                  (APPEND SNARK::ANS2 SNARK::L2)
;                                  SNARK::*FROZEN-VARIABLES* SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))
;        (T
;         (SNARK::CLAUSE-SUBSUMES1 SNARK::L1 SNARK::L2 SNARK::*FROZEN-VARIABLES*
;                                  SNARK::->* SUBST)
;         (SNARK::SUBSUME-ANSWERS SNARK::SUBSUMING-ANSWER SNARK::SUBSUMED-ANSWER
;                                 SUBST SNARK::->* SUBST)
;         (FUNCALL SNARK::CC SUBST))))
; --> BLOCK COND IF COND LET IF COND IF PROGN LET SNARK::ATOMS-IN-CLAUSE2 
; ==>
;   SNARK::SUBSUMING-ANSWER
; 
; note: deleting unreachable code

; --> BLOCK COND IF COND LET IF COND IF PROGN LET LET SNARK::CLAUSE-SUBSUMES1 
; ==>
;   SNARK::CC
; 
; note: deleting unreachable code

; --> BLOCK COND IF COND LET IF COND IF PROGN LET LET SNARK::ATOMS-IN-CLAUSE2 
; ==>
;   SNARK::SUBSUMED-ANSWER
; 
; note: deleting unreachable code

;     (ASSERT
;      (SNARK::DISJOINT-ANSWER-RELATIONS-P SNARK::L1 SNARK::L2 SNARK::ANS1
;                                          SNARK::ANS2))
; --> TAGBODY LET 
; ==>
;   SNARK::L1
; 
; note: deleting unreachable code

; compiling (DEFUN DISJOINT-ANSWER-RELATIONS-P ...)
; compiling (DEFUN FORWARD-OR-BACKWARD-WFF-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN FORWARD-OR-BACKWARD-WFF-SUBSUMPTION
;     (INCF SNARK::SUBSUMPTION-MARK)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::SUBSUMPTION-MARK)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN FORWARD-OR-BACKWARD-ATOM-SUBSUMPTION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN FORWARD-OR-BACKWARD-ATOM-SUBSUMPTION
;     (FUNCALL SNARK::CC SNARK::ROW2)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (EQL (SNARK::ROW-SUBSUMPTION-MARK SNARK::ROW2) SNARK::OLD-MARK)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN WFF-SUBSUMPTION ...)
; compiling (DEFUN WFF-SUBSUMPTION* ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN WFF-SUBSUMPTION*
;     (SORT SNARK::W #'< :KEY #'CAR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

; compiling (DEFUN WFF-SUBSUMPTION*1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN WFF-SUBSUMPTION*1
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN NMATCHES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN NMATCHES
;     (INCF SNARK::N)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN SUBSUME-ANSWERS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.lisp
; in: DEFUN SUBSUME-ANSWERS
;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume.fasl written
; compilation finished in 0:00:00.131
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN CLAUSE-SUBSUMES-P ...)
; compiling (DEFUN CLAUSE-SUBSUMES-P1 ...)
; compiling (DEFUN CLAUSE-SUBSUMES1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp
; in: DEFUN CLAUSE-SUBSUMES1
;     (FUNCALL SNARK::CC NIL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK::CLAUSE-CLAUSE-SUBSUMPTION
;       (SNARK::CLAUSE-SUBSUMES2 SNARK::CC SNARK::L1 SNARK::L2
;                                SNARK::FROZEN-VARIABLES))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%CLAUSE-CLAUSE-SUBSUMPTION-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%CLAUSE-CLAUSE-SUBSUMPTION-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN CLAUSE-SUBSUMES2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp
; in: DEFUN CLAUSE-SUBSUMES2
;     (FUNCALL SNARK::CC SNARK::SUBST0)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (FUNCALL SNARK::CC SUBST)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK::CC)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN MAKE-SUBSUMPTION-TEST-DP-CLAUSE-SET ...)
; compiling (DEFUN REORDER-ATOMS2 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp
; in: DEFUN REORDER-ATOMS2
;     (INCF (CDDR SNARK::Y)
;           (IF (EQ SNARK::*=* SNARK:HEAD)
;               2
;               1))
; --> LET* 
; ==>
;   (+
;    (IF (EQ SNARK::*=* SNARK:HEAD)
;        2
;        1)
;    (CDR #:LIST))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (EQL SNARK::N (CDDR SNARK::Y))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

;     (EQL SNARK::N (FIRST SNARK::X))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN REFINE-SUBSTS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp
; in: DEFUN REFINE-SUBSTS
;     (DELETE-IF
;      (LAMBDA (SNARK::X)
;        (LET* ((SNARK::SUBST1 #) (SNARK::SUBST1* #))
;          (COND (# #) (T # NIL))))
;      (FIRST SNARK::L))
; 
; note: unable to open code due to type uncertainty: The second argument is a SEQUENCE, not a LIST.

; compiling (DEFUN MAKE-SUBSUMPTION-TEST-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.lisp
; in: DEFUN MAKE-SUBSUMPTION-TEST-CLAUSES
;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (INCF SNARK::J)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::J)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (<= (SNARK:TEST-OPTION36?) SNARK::K)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (INCF SNARK::K)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::K)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (<= (SNARK:TEST-OPTION36?) SNARK::K)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

;     (INCF SNARK::I)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::I)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK::J)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK::J)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MAKE-SUBSUMPTION-TEST-DP-CLAUSE-SET1 ...)
; compiling (DEFUN CONDENSER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/subsume-clause.fasl written
; compilation finished in 0:00:00.099
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-file.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFMACRO IN-LANGUAGE ...)
; compiling (DEFMACRO IN-KB ...)
; compiling (DEFMACRO HAS-AUTHOR ...)
; compiling (DEFMACRO HAS-DOCUMENTATION ...)
; compiling (DEFMACRO HAS-NAME ...)
; compiling (DEFMACRO HAS-SOURCE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-COMMANDS ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-KEYWORDS ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-FORMAT ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-IF-DOES-NOT-EXIST ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-VERBOSE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-PACKAGE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-READTABLE ...)
; compiling (DECLARE-SNARK-OPTION ASSERTION-FILE-NEGATE-CONJECTURES ...)
; compiling (DEFUN READ-ASSERTION-FILE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-file.lisp
; in: DEFUN READ-ASSERTION-FILE
;     (SNARK-LISP:WITH-CLOCK-ON SNARK:READ-ASSERTION-FILE
;       (SNARK::RAF))
; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%READ-ASSERTION-FILE-COUNT%*))
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH SNARK::KEYWORDS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (SNARK-LISP:PROG->
;       (IDENTITY READTABLE SNARK::-> *READTABLE*)
;       (IDENTITY (SNARK:ASSERTION-FILE-COMMANDS?) SNARK::-> SNARK::COMMANDS)
;       (IDENTITY (SNARK:ASSERTION-FILE-KEYWORDS?) SNARK::-> SNARK::KEYWORDS)
;       (PROGV
;           (MAPCAR #'SECOND SNARK::KEYWORDS)
;           (SNARK-LISP:CONSN NIL NIL (LENGTH SNARK::KEYWORDS))
;         (FUNCALL
;          (LET (#)
;            (COND # # # #))
;          SNARK::FILESPEC :IF-DOES-NOT-EXIST SNARK::IF-DOES-NOT-EXIST :PACKAGE
;          PACKAGE SNARK::->* SNARK::FORM)
;         (WHEN SNARK::FORM
;           (AND (CONSP SNARK::FORM) (SYMBOLP #) (FIRST #) SNARK::->
;                SNARK::COMMAND)
;           (CASE SNARK::COMMAND
;             (# #)
;             (SNARK:ASSERTION # #)
;             (# # #)
;             (SNARK:DECLARE-SUBSORT # #)
;             (# # #)
;             (OTHERWISE #))
;           (UNLESS SNARK::COMMAND (CASE # # #)))))
; --> BLOCK LET SNARK-LISP::UNNAMED-PROG-> LET SNARK-LISP::UNNAMED-PROG-> LET 
; --> SNARK-LISP::UNNAMED-PROG-> PROGV LET UNWIND-PROTECT FLET BLOCK 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK SB-C::%WITHIN-CLEANUP 
; --> RETURN-FROM PROGN FLET FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (LET ((TYPE (PATHNAME-TYPE SNARK::FILESPEC)))
;      (COND ((OR # # #) 'SNARK::MAPNCONC-TPTP-FILE-FORMS)
;            ((OR # #) 'SNARK-LISP:MAPNCONC-FILE-FORMS)
;            ((EQ :TPTP FORMAT) 'SNARK::MAPNCONC-TPTP-FILE-FORMS)
;            (T 'SNARK-LISP:MAPNCONC-FILE-FORMS))))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (SNARK-LISP:WITH-CLOCK-ON SNARK:READ-ASSERTION-FILE
;       (SNARK::RAF))
; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNWIND-PROTECT FLET BLOCK UNLESS IF PROGN DECF LET* 
; --> SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT 
; ==>
;   (- SNARK-LISP::*LAST-RUN-TIME-VALUE*
;      (SETF SNARK-LISP::*LAST-RUN-TIME-VALUE* (GET-INTERNAL-RUN-TIME)))
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN IF DECF LET* SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a INTEGER, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; --> LET* UNLESS IF PROGN INCF LET* 
; ==>
;   (+ 1 (SYMBOL-VALUE 'SNARK-LISP::*%READ-ASSERTION-FILE-COUNT%*))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MUST-PRECEDE-IN-ASSERTION-FILE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-INITIALIZE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-CLOSURE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-OPTIONS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-ACTIONS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-IGNORE-ERRORS ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-VERBOSE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-OUTPUT-FILE ...)
; compiling (DECLARE-SNARK-OPTION REFUTE-FILE-IF-EXISTS ...)
; compiling (DEFUN REFUTE-FILE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/assertion-file.fasl written
; compilation finished in 0:00:00.151
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN PRINT-ROW-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFF-IN-TPTP-FORMAT1 ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-ROW-NAME-OR-NUMBER-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT2 ...)
; compiling (DEFUN PRINT-ROW-REASON-IN-TPTP-FORMAT3 ...)
; compiling (DEFUN PRINT-ROW-SOURCE-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFF-IN-TPTP-FORMAT ...)
; compiling (DEFUN PRINT-WFFS-IN-TPTP-FORMAT ...)
; compiling (DEFUN TPTP-FUNCTION-NAME ...)
; compiling (DEFUN PRINT-TERM-IN-TPTP-FORMAT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN PRINT-TERM-IN-TPTP-FORMAT
;     (FLOOR (SNARK::VARIABLE-NUMBER SNARK::TERM) 6)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to convert integer division to multiplication due to type uncertainty: The first argument is a REAL, not a (UNSIGNED-BYTE 64).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a RATIONAL.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF 
; --> MINUSP 
; ==>
;   (< NUMBER 0)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 1- 
; ==>
;   (- SB-C::TRU 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION IF VALUES 
; ==>
;   (+ REM SB-C::DIVISOR)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12.0d0) (SINGLE-FLOAT (0.0) 12.0) (RATIONAL (0) (12))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (OR (RATIONAL (-6) (6)) (DOUBLE-FLOAT -6.0d0 6.0d0) (SINGLE-FLOAT -6.0 6.0)), not a FIXNUM.
;       The result is a (VALUES (OR (MEMBER 0.0 0.0d0) (DOUBLE-FLOAT (0.0d0) 12.0d0) (SINGLE-FLOAT (0.0) 12.0) (RATIONAL (0) (12))) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN PRINT-VARSPECS ...)
; compiling (DEFUN PRINT-LIST-IN-TPTP-FORMAT ...)
; compiling (DEFUN QUOTE-TPTP-SYMBOL? ...)
; compiling (DEFUN PRINT-SYMBOL-IN-TPTP-FORMAT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN PRINT-SYMBOL-IN-TPTP-FORMAT
;     (READTABLE-CASE *READTABLE*)
; 
; note: deleting unreachable code

;     (SOME #'UPPER-CASE-P STRING)
; --> BLOCK SB-INT:DX-FLET FLET SB-KERNEL:%MAP 
; ==>
;   STRING
; 
; note: deleting unreachable code

;     (SOME #'LOWER-CASE-P STRING)
; --> BLOCK SB-INT:DX-FLET FLET SB-KERNEL:%MAP 
; ==>
;   STRING
; 
; note: deleting unreachable code

;     (PRINC SNARK::X)
; ==>
;   SNARK::X
; 
; note: deleting unreachable code

;     (SNARK-LISP:CHAR-INVERT-CASE SNARK::CH)
; ==>
;   SNARK::CH
; 
; note: deleting unreachable code

; compiling (DEFUN TPTP-SORT-NAME ...)
; compiling (DEFVAR *TPTP-ENVIRONMENT-VARIABLE* ...)
; compiling (DEFUN TPTP-INCLUDE-FILE-NAME ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN TPTP-INCLUDE-FILE-NAME
;     (STRING SNARK::FILENAME)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (POSITION-IF
;      #'(LAMBDA (SNARK::CH) (OR (EQ '#\/ SNARK::CH) (EQ '#\: SNARK::CH)))
;      SNARK::FILENAME)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (SUBSEQ SNARK::FILENAME 0 SNARK::POS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (SUBSEQ SNARK::FILENAME (+ SNARK::POS 1))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

; compiling (DEFUN TPTP-FILE-SOURCE-STRING ...)
; compiling (DEFUN MAPNCONC-TPTP-FILE-FORMS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN MAPNCONC-TPTP-FILE-FORMS
;     (MEMBER (SECOND SNARK::FORM) SNARK::FORMULA-SELECTION)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FUNCALL FUNCTION
;              (COND
;               ((EQ 'SNARK:|type| (THIRD SNARK::FORM))
;                (SNARK::INPUT-TPTP-TYPE-DECLARATION (FOURTH SNARK::FORM)))
;               (T
;                (LET (# #)
;                  (LET #
;                    #
;                    #
;                    #
;                    #
;                    #)))))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN TPTP-TO-SNARK-REASON ...)
; compiling (DEFUN INPUT-TPTP-TYPE-DECLARATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN INPUT-TPTP-TYPE-DECLARATION
;     (LENGTH SNARK::ARGSORTS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN TPTP-TYPE-PRODUCT-P ...)
; compiling (DEFUN TPTP-TYPE-PRODUCT-LIST ...)
; compiling (DEFUN NUMBER-LIST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN NUMBER-LIST
;     (+ 1 SNARK::N)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFVAR *TPTP-FORMAT* ...)
; compiling (DEFVAR *TPTP-INPUT-DIRECTORY* ...)
; compiling (DEFVAR *TPTP-INPUT-DIRECTORY-HAS-DOMAIN-SUBDIRECTORIES* ...)
; compiling (DEFVAR *TPTP-INPUT-FILE-TYPE* ...)
; compiling (DEFVAR *TPTP-OUTPUT-DIRECTORY* ...)
; compiling (DEFVAR *TPTP-OUTPUT-DIRECTORY-HAS-DOMAIN-SUBDIRECTORIES* ...)
; compiling (DEFVAR *TPTP-OUTPUT-FILE-TYPE* ...)
; compiling (DEFUN TPTP-PROBLEM-PATHNAME0 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN TPTP-PROBLEM-PATHNAME0
;     (SUBSEQ (PATHNAME-NAME SNARK::PN) 0 3)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR NULL (SIMPLE-ARRAY CHARACTER (*)) (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING), not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR NULL (SIMPLE-ARRAY CHARACTER (*)) (SIMPLE-ARRAY NIL (*)) SIMPLE-BASE-STRING), not a LIST.

; compiling (DEFUN TPTP-PROBLEM-INPUT-PATHNAME ...)
; compiling (DEFUN TPTP-PROBLEM-OUTPUT-PATHNAME ...)
; compiling (DEFUN DO-TPTP-PROBLEM ...)
; compiling (DEFUN DO-TPTP-PROBLEM0 ...)
; compiling (DEFUN DO-TPTP-PROBLEM1 ...)
; compiling (DEFUN TRANSLATE-ASSERTION-FILE-TO-TPTP-FORMAT ...)
; compiling (DEFUN DECLARE-TPTP-OPERATORS ...)
; compiling (DEFUN TPTP-TO-SNARK-INPUT ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN TPTP-TO-SNARK-INPUT
;     (SNARK-LISP:LCONS (SNARK::FIX-TPTP-SYMBOL (FIRST SNARK::X))
;                       (SNARK::TPTP-TO-SNARK-INPUT-ARGS (REST SNARK::X)) SNARK::X)
; --> IF LET* IF LET IF AND IF 
; ==>
;   (EQL #:G1082 #:G1084)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G1081 #:G1083)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G1081 #:G1083)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN FIX-TPTP-SYMBOL ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN FIX-TPTP-SYMBOL
;     (LENGTH (SETF SNARK::NAME (SUBSEQ SNARK::NAME 1)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

; compiling (DEFUN TPTP-TO-SNARK-INPUT-ARGS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN TPTP-TO-SNARK-INPUT-ARGS
;     (SNARK-LISP:LCONS (SNARK::TPTP-TO-SNARK-INPUT (FIRST SNARK::L))
;                       (SNARK::TPTP-TO-SNARK-INPUT-ARGS (REST SNARK::L)) SNARK::L)
; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G1169 #:G1171)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF IF 
; ==>
;   (EQL #:G1169 #:G1171)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN STRIP-COLONS ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.lisp
; in: DEFUN STRIP-COLONS
;     (SNARK-LISP:LCONS
;      (IF (AND (CONSP (FIRST SNARK::L)) (EQ 'SNARK::TPTP-COLON (FIRST #))
;               (SYMBOLP (SECOND #)) (SYMBOLP (THIRD #)))
;          (REST (FIRST SNARK::L))
;          (FIRST SNARK::L))
;      (SNARK::STRIP-COLONS (REST SNARK::L)) SNARK::L)
; --> IF LET* IF IF 
; ==>
;   (EQL #:G1178 #:G1180)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; --> IF LET* IF LET IF AND IF AND THE 
; ==>
;   (EQL #:G1178 #:G1180)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN READ-TPTP-TERM1 ...)
; compiling (DEFUN READ-TPTP-TERM ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp.fasl written
; compilation finished in 0:00:00.303
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp-symbols.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN DECLARE-TPTP-SORT ...)
; compiling (DEFUN DECLARE-TPTP-SYMBOLS1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp-symbols.lisp
; in: DEFUN DECLARE-TPTP-SYMBOLS1
;     (FUNCALL SNARK-USER::FN SNARK-USER::NAME SNARK-USER::ARITY
;              (IF SNARK-USER::NEW-NAME
;                  :NEW-NAME
;                  :ALIAS)
;              SNARK-USER::TPTP-NAME)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-USER::FN)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (LABELS ((SNARK-USER::DECLARE-TPTP-SYMBOL (SNARK-USER::FN SNARK-USER::X)
;                (SNARK-LISP:MVLET (#)
;                  (FUNCALL SNARK-USER::FN SNARK-USER::NAME SNARK-USER::ARITY #
;                           SNARK-USER::TPTP-NAME))))
;       (MAPC
;        #'(LAMBDA (SNARK-USER::X)
;            (SNARK-USER::DECLARE-TPTP-SYMBOL 'SNARK:DECLARE-RELATION
;             SNARK-USER::X))
;        '((SNARK-USER::|$less| SNARK:$$LESS 2)
;          (SNARK-USER::|$lesseq| SNARK:$$LESSEQ 2)
;          (SNARK-USER::|$greater| SNARK:$$GREATER 2)
;          (SNARK-USER::|$greatereq| SNARK:$$GREATEREQ 2)
;          (SNARK-USER::|$is_int| SNARK:$$INTEGERP 1)
;          (SNARK-USER::|$is_rat| SNARK:$$RATIONALP 1)
;          (SNARK-USER::|$is_real| SNARK:$$REALP 1)))
;       (MAPC
;        #'(LAMBDA (SNARK-USER::X)
;            (SNARK-USER::DECLARE-TPTP-SYMBOL 'SNARK:DECLARE-FUNCTION
;             SNARK-USER::X))
;        '((SNARK-USER::|$uminus| SNARK:$$UMINUS 1)
;          (SNARK-USER::|$sum| SNARK:$$SUM 2)
;          (SNARK-USER::|$difference| SNARK:$$DIFFERENCE 2)
;          (SNARK-USER::|$product| SNARK:$$PRODUCT 2)
;          (SNARK-USER::|$quotient| SNARK:$$QUOTIENT 2)
;          (SNARK-USER::|$quotient_e| SNARK:$$QUOTIENT_E 2)
;          (SNARK-USER::|$quotient_f| SNARK:$$QUOTIENT_F 2)
;          (SNARK-USER::|$quotient_t| SNARK:$$QUOTIENT_T 2)
;          (SNARK-USER::|$remainder_e| SNARK:$$REMAINDER_E 2)
;          (SNARK-USER::|$remainder_f| SNARK:$$REMAINDER_F 2)
;          (SNARK-USER::|$remainder_t| SNARK:$$REMAINDER_T 2)
;          (SNARK-USER::|$floor| SNARK:$$FLOOR 1) ...))
;       (SNARK::DECLARE-ARITHMETIC-FUNCTION 'SNARK-USER::|$to_rat| 1 :SORT
;                                           'RATIONAL :REWRITE-CODE
;                                           'SNARK-USER::TO_RAT-TERM-REWRITER)
;       (SNARK::DECLARE-ARITHMETIC-FUNCTION 'SNARK-USER::|$to_real| 1 :SORT 'REAL
;                                           :REWRITE-CODE
;                                           'SNARK-USER::TO_REAL-TERM-REWRITER)
;       NIL)
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN DECLARE-TPTP-SYMBOLS2 ...)
; compiling (DEFUN TO_RAT-TERM-REWRITER ...)
; compiling (DEFUN TO_REAL-TERM-REWRITER ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/tptp-symbols.fasl written
; compilation finished in 0:00:00.029
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFSTRUCT (PROOF-LINE # ...) ...)
; compiling (DEFVAR *CODER-START-TIME*)
; compiling (DEFVAR *CODER-RUN-TIME-LIMIT*)
; compiling (DEFVAR *CODER-STEP-COUNT*)
; compiling (DEFVAR *CODER-DERIVATION-COUNT*)
; compiling (DEFVAR *CODER-PRINT-STATE-INTERVAL* ...)
; compiling (DEFVAR *CODER-MAXIMUM-TERM-SIZE-FOUND*)
; compiling (DEFVAR *CODER-MAXIMUM-TARGET-SIZE*)
; compiling (DEFVAR *CODER-TERM-SIZE-LIMIT*)
; compiling (DEFVAR *CODER-TERM-VARS-LIMIT*)
; compiling (DEFVAR *CODER-ORDERING* ...)
; compiling (DEFVAR *CODER-DO-REVERSE-CD*)
; compiling (DEFVAR *TEST1* ...)
; compiling (DEFVAR *TEST2* ...)
; compiling (DEFUN CODER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN CODER
;     (RASSOC SNARK-USER::X SNARK-USER::TARGET-ALIST)
; ==>
;   (SB-KERNEL:%RASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (LOOP SNARK-USER::FOR SNARK-USER::NSTEPS SNARK-USER::FROM MIN SNARK-USER::TO MAX
;           DO (LET (SNARK-USER::TARGETS-FOUND)
;                (FORMAT T "~2%Search for ~D-step proof... " SNARK-USER::NSTEPS)
;                (FORCE-OUTPUT)
;                (SETF SNARK-USER::TARGETS-FOUND
;                        (SNARK-USER::CODER1 SNARK-USER::AXIOMS SNARK-USER::TARGET
;                                            SNARK-USER::NSTEPS SNARK-USER::CD
;                                            SNARK-USER::OP SNARK-USER::KILL
;                                            SNARK-USER::AVOID
;                                            SNARK-USER::ALL-PROOFS
;                                            SNARK-USER::MUST-USE
;                                            SNARK-USER::RESUME SNARK-USER::HINTS
;                                            ...))
;                (SETF SNARK-USER::RESUME NIL)
;                (LET ((SNARK-USER::RUN-TIME #))
;                  (FORMAT T "~%~D steps in ~D seconds"
;                          SNARK-USER::*CODER-STEP-COUNT* SNARK-USER::RUN-TIME)
;                  (WHEN (AND SNARK-USER::*CODER-RUN-TIME-LIMIT* #)
;                    (FORMAT T "; time limit exceeded")
;                    (RETURN)))
;                (WHEN SNARK-USER::TARGETS-FOUND
;                  (SETF SNARK-USER::TARGET #)
;                  (SETF SNARK-USER::ALL-TARGETS-FOUND #)
;                  (WHEN (NULL SNARK-USER::TARGET) (RETURN)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-USER::NSTEPS #:LOOP-LIMIT-114)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (ASSERT
;      (>= (LENGTH SNARK-USER::STEPS-TO-USE) SNARK-USER::STEPS-TO-USE-COUNT 0))
; --> TAGBODY LET WHEN IF >= 
; --> (LAMBDA (#:G87 #:G86 #:G85) (DECLARE (TYPE REAL #:G87 #:G86 #:G85)) (IF (>= #:G87 #:G86) (IF (>= #:G86 #:G85) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

; --> TAGBODY LET WHEN IF >= 
; --> (LAMBDA (#:G87 #:G86 #:G85) (DECLARE (TYPE REAL #:G87 #:G86 #:G85)) (IF (>= #:G87 #:G86) (IF (>= #:G86 #:G85) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT* SNARK-USER::RUN-TIME)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (ASSERT
;      (>= (LENGTH SNARK-USER::STEPS-TO-USE) SNARK-USER::STEPS-TO-USE-COUNT 0))
; --> TAGBODY LET WHEN IF >= 
; --> (LAMBDA (#:G87 #:G86 #:G85) (DECLARE (TYPE REAL #:G87 #:G86 #:G85)) (IF (>= #:G87 #:G86) (IF (>= #:G86 #:G85) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open code because: The operands might not be the same type.

;     (LOOP SNARK-USER::FOR SNARK-USER::NSTEPS SNARK-USER::FROM MIN SNARK-USER::TO MAX
;           DO (LET (SNARK-USER::TARGETS-FOUND)
;                (FORMAT T "~2%Search for ~D-step proof... " SNARK-USER::NSTEPS)
;                (FORCE-OUTPUT)
;                (SETF SNARK-USER::TARGETS-FOUND
;                        (SNARK-USER::CODER1 SNARK-USER::AXIOMS SNARK-USER::TARGET
;                                            SNARK-USER::NSTEPS SNARK-USER::CD
;                                            SNARK-USER::OP SNARK-USER::KILL
;                                            SNARK-USER::AVOID
;                                            SNARK-USER::ALL-PROOFS
;                                            SNARK-USER::MUST-USE
;                                            SNARK-USER::RESUME SNARK-USER::HINTS
;                                            ...))
;                (SETF SNARK-USER::RESUME NIL)
;                (LET ((SNARK-USER::RUN-TIME #))
;                  (FORMAT T "~%~D steps in ~D seconds"
;                          SNARK-USER::*CODER-STEP-COUNT* SNARK-USER::RUN-TIME)
;                  (WHEN (AND SNARK-USER::*CODER-RUN-TIME-LIMIT* #)
;                    (FORMAT T "; time limit exceeded")
;                    (RETURN)))
;                (WHEN SNARK-USER::TARGETS-FOUND
;                  (SETF SNARK-USER::TARGET #)
;                  (SETF SNARK-USER::ALL-TARGETS-FOUND #)
;                  (WHEN (NULL SNARK-USER::TARGET) (RETURN)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-USER::NSTEPS 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (LENGTH SNARK-USER::STEPS-TO-USE)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (= 0 SNARK-USER::STEPS-TO-USE-COUNT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (LENGTH (SNARK:ARGS SNARK-USER::X))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (ASSERT
;      (>= (LENGTH SNARK-USER::STEPS-TO-USE) SNARK-USER::STEPS-TO-USE-COUNT 0))
; --> TAGBODY LET WHEN IF >= 
; --> (LAMBDA (#:G87 #:G86 #:G85) (DECLARE (TYPE REAL #:G87 #:G86 #:G85)) (IF (>= #:G87 #:G86) (IF (>= #:G86 #:G85) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

; --> TAGBODY LET WHEN IF >= 
; --> (LAMBDA (#:G87 #:G86 #:G85) (DECLARE (TYPE REAL #:G87 #:G86 #:G85)) (IF (>= #:G87 #:G86) (IF (>= #:G86 #:G85) T NIL) NIL)) 
; --> SB-C::%FUNCALL IF IF >= OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

;     (LOOP SNARK-USER::FOR SNARK-USER::NSTEPS SNARK-USER::FROM MIN SNARK-USER::TO MAX
;           DO (LET (SNARK-USER::TARGETS-FOUND)
;                (FORMAT T "~2%Search for ~D-step proof... " SNARK-USER::NSTEPS)
;                (FORCE-OUTPUT)
;                (SETF SNARK-USER::TARGETS-FOUND
;                        (SNARK-USER::CODER1 SNARK-USER::AXIOMS SNARK-USER::TARGET
;                                            SNARK-USER::NSTEPS SNARK-USER::CD
;                                            SNARK-USER::OP SNARK-USER::KILL
;                                            SNARK-USER::AVOID
;                                            SNARK-USER::ALL-PROOFS
;                                            SNARK-USER::MUST-USE
;                                            SNARK-USER::RESUME SNARK-USER::HINTS
;                                            ...))
;                (SETF SNARK-USER::RESUME NIL)
;                (LET ((SNARK-USER::RUN-TIME #))
;                  (FORMAT T "~%~D steps in ~D seconds"
;                          SNARK-USER::*CODER-STEP-COUNT* SNARK-USER::RUN-TIME)
;                  (WHEN (AND SNARK-USER::*CODER-RUN-TIME-LIMIT* #)
;                    (FORMAT T "; time limit exceeded")
;                    (RETURN)))
;                (WHEN SNARK-USER::TARGETS-FOUND
;                  (SETF SNARK-USER::TARGET #)
;                  (SETF SNARK-USER::ALL-TARGETS-FOUND #)
;                  (WHEN (NULL SNARK-USER::TARGET) (RETURN)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF 
; ==>
;   (> SNARK-USER::NSTEPS #:LOOP-LIMIT-114)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (- (GET-INTERNAL-RUN-TIME) SNARK-USER::*CODER-START-TIME*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT* SNARK-USER::RUN-TIME)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (LOOP SNARK-USER::FOR SNARK-USER::NSTEPS SNARK-USER::FROM MIN SNARK-USER::TO MAX
;           DO (LET (SNARK-USER::TARGETS-FOUND)
;                (FORMAT T "~2%Search for ~D-step proof... " SNARK-USER::NSTEPS)
;                (FORCE-OUTPUT)
;                (SETF SNARK-USER::TARGETS-FOUND
;                        (SNARK-USER::CODER1 SNARK-USER::AXIOMS SNARK-USER::TARGET
;                                            SNARK-USER::NSTEPS SNARK-USER::CD
;                                            SNARK-USER::OP SNARK-USER::KILL
;                                            SNARK-USER::AVOID
;                                            SNARK-USER::ALL-PROOFS
;                                            SNARK-USER::MUST-USE
;                                            SNARK-USER::RESUME SNARK-USER::HINTS
;                                            ...))
;                (SETF SNARK-USER::RESUME NIL)
;                (LET ((SNARK-USER::RUN-TIME #))
;                  (FORMAT T "~%~D steps in ~D seconds"
;                          SNARK-USER::*CODER-STEP-COUNT* SNARK-USER::RUN-TIME)
;                  (WHEN (AND SNARK-USER::*CODER-RUN-TIME-LIMIT* #)
;                    (FORMAT T "; time limit exceeded")
;                    (RETURN)))
;                (WHEN SNARK-USER::TARGETS-FOUND
;                  (SETF SNARK-USER::TARGET #)
;                  (SETF SNARK-USER::ALL-TARGETS-FOUND #)
;                  (WHEN (NULL SNARK-USER::TARGET) (RETURN)))))
; --> BLOCK LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; --> 1+ 
; ==>
;   (+ SNARK-USER::NSTEPS 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-USER::NAXIOMS)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::NAXIOMS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN CODER1 ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN CODER1
;     (FUNCALL SNARK-USER::KILL SNARK-USER::NEW-LINE)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN SNARK-USER::KILL)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF SNARK-USER::*CODER-STEP-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-STEP-COUNT*)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (REM (INCF SNARK-USER::*CODER-STEP-COUNT*)
;          SNARK-USER::*CODER-PRINT-STATE-INTERVAL*)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT*
;        (ROUND SNARK-USER::RUN-TIME INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< 0 SNARK-USER::STEPS-TO-USE-COUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (= 1 SNARK-USER::NSTEPS)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (= 0 SNARK-USER::STEPS-TO-USE-COUNT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (> (- SNARK-USER::NSTEPS 1) SNARK-USER::NEW-STEPS-TO-USE-COUNT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (INCF SNARK-USER::*CODER-STEP-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-STEP-COUNT*)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (REM (INCF SNARK-USER::*CODER-STEP-COUNT*)
;          SNARK-USER::*CODER-PRINT-STATE-INTERVAL*)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; ==>
;   (TRUNCATE NUMBER SB-C::DIVISOR)
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a SINGLE-FLOAT.The second argument is a REAL, not a (OR SINGLE-FLOAT INTEGER).
; 
; note: unable to optimize due to type uncertainty: The first argument is a REAL, not a DOUBLE-FLOAT.The second argument is a REAL, not a (OR DOUBLE-FLOAT SINGLE-FLOAT INTEGER).
; 
; note: unable to convert division by 2^k to shift due to type uncertainty: The first argument is a REAL, not a INTEGER.The second argument is a REAL, not a INTEGER.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT*
;        (ROUND SNARK-USER::RUN-TIME INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (INCF SNARK-USER::*CODER-DERIVATION-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-DERIVATION-COUNT*)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (PUSHNEW SNARK-USER::V SNARK-USER::TARGETS-FOUND)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (+ (SNARK-USER::PROOF-LINE-NUMBER (FIRST SNARK-USER::LINES)) 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH SNARK-USER::UNUSED)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (MEMBER SNARK-USER::X SNARK-USER::UNUSED)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (MEMBER SNARK-USER::Y SNARK-USER::UNUSED)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS -1)
; ==>
;   (+ (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS) -1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH (REST SNARK-USER::TARGET))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (> (+ SNARK-USER::NTARGETS SNARK-USER::STEPS-TO-USE-COUNT) SNARK-USER::NSTEPS)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (>= (- SNARK-USER::NSTEPS 1)
;         (+ SNARK-USER::NTARGETS SNARK-USER::NEW-STEPS-TO-USE-COUNT))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

;     (DOLIST (SNARK-USER::Y SNARK-USER::REVLINES)
;       (LET ((SNARK-USER::YUNUSED? (AND # #)))
;         (UNLESS
;             (>
;              (IF SNARK-USER::XUNUSED?
;                  #
;                  #)
;              (IF #
;                  SNARK-USER::NSTEPS
;                  #))
;           (LET (#)
;             (WHEN # #)))))
; ==>
;   (BLOCK NIL
;     (LET ((#:N-LIST325 SNARK-USER::REVLINES))
;       (TAGBODY
;        #:START326
;         (UNLESS (ENDP #:N-LIST325)
;           (LET #
;             #
;             #)
;           (GO #:START326))))
;     NIL)
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM NIL NIL). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (DEFUN SNARK-USER::CODER1
;            (SNARK-USER::AXIOMS SNARK-USER::TARGET SNARK-USER::NSTEPS
;             SNARK-USER::CD SNARK-USER::OP SNARK-USER::KILL SNARK-USER::AVOID
;             SNARK-USER::ALL-PROOFS SNARK-USER::MUST-USE SNARK-USER::RESUME
;             SNARK-USER::HINTS SNARK-USER::STEPS-TO-USE ...)
;       (LET ((SNARK-USER::TOGETHER-TARGET?
;              (SNARK-USER::TOGETHER-TARGET? SNARK-USER::TARGET))
;             (SNARK-USER::TARGETS-FOUND NIL))
;         (LABELS ((SNARK-USER::CODER2 #
;                    #))
;           (LET (#)
;             (UNLESS # #))
;           SNARK-USER::TARGETS-FOUND)))
; --> PROGN SB-IMPL::%DEFUN SB-IMPL::%DEFUN SB-INT:NAMED-LAMBDA FUNCTION 
; ==>
;   (BLOCK SNARK-USER::CODER1
;     (LET ((SNARK-USER::TOGETHER-TARGET?
;            (SNARK-USER::TOGETHER-TARGET? SNARK-USER::TARGET))
;           (SNARK-USER::TARGETS-FOUND NIL))
;       (LABELS ((SNARK-USER::CODER2 #
;                  #))
;         (LET (#)
;           (UNLESS # #))
;         SNARK-USER::TARGETS-FOUND)))
; 
; note: Allocating a value-cell at runtime for checking possibly out of extent exit via (RETURN-FROM CODER1 TARGETS-FOUND). Use GO/RETURN-FROM with SAFETY 0, or declare the exit function DYNAMIC-EXTENT to avoid.

;     (+ SNARK-USER::NTARGETS SNARK-USER::STEPS-TO-USE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (> (+ SNARK-USER::NTARGETS SNARK-USER::STEPS-TO-USE-COUNT) SNARK-USER::NSTEPS)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< 0 SNARK-USER::STEPS-TO-USE-COUNT)
; --> > IF 
; ==>
;   (> SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (DECF SNARK-USER::NEW-STEPS-TO-USE-COUNT)
; --> SETQ THE SB-IMPL::XSUBTRACT BLOCK 
; ==>
;   (- SB-IMPL::B SB-IMPL::A)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-USER::NSTEPS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK-USER::NTARGETS SNARK-USER::NEW-STEPS-TO-USE-COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (>= (- SNARK-USER::NSTEPS 1)
;         (+ SNARK-USER::NTARGETS SNARK-USER::NEW-STEPS-TO-USE-COUNT))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

;     (- SNARK-USER::NSTEPS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (> (- SNARK-USER::NSTEPS 1) SNARK-USER::NEW-STEPS-TO-USE-COUNT)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (INCF SNARK-USER::*CODER-STEP-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-STEP-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- (GET-INTERNAL-RUN-TIME) SNARK-USER::*CODER-START-TIME*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT*
;        (ROUND SNARK-USER::RUN-TIME INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (- SNARK-USER::NSTEPS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-USER::*CODER-STEP-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-STEP-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- (GET-INTERNAL-RUN-TIME) SNARK-USER::*CODER-START-TIME*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (< SNARK-USER::*CODER-RUN-TIME-LIMIT*
;        (ROUND SNARK-USER::RUN-TIME INTERNAL-TIME-UNITS-PER-SECOND))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (- SNARK-USER::NSTEPS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-USER::NTARGETS 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ (SNARK-USER::PROOF-LINE-NUMBER (FIRST SNARK-USER::LINES)) 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (INCF SNARK-USER::*CODER-DERIVATION-COUNT*)
; --> SETQ THE 
; ==>
;   (+ 1 SNARK-USER::*CODER-DERIVATION-COUNT*)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS -1)
; --> + 
; ==>
;   (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; ==>
;   (+ (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS) -1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (>
;      (IF SNARK-USER::XUNUSED?
;          (IF SNARK-USER::YUNUSED?
;              (- SNARK-USER::NUNUSED 1)
;              SNARK-USER::NUNUSED)
;          (IF SNARK-USER::YUNUSED?
;              SNARK-USER::NUNUSED
;              (+ SNARK-USER::NUNUSED 1)))
;      (IF (EQL 1 SNARK-USER::NTARGETS)
;          SNARK-USER::NSTEPS
;          (+ SNARK-USER::NSTEPS SNARK-USER::NTARGETS -1)))
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The second argument is a REAL, not a FIXNUM.

;     (EQL SNARK-USER::NTARGETS SNARK-USER::NSTEPS)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN SORT-NEW-LINES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN SORT-NEW-LINES
;     (STABLE-SORT (NREVERSE SNARK-USER::NEW-LINES)
;                  (LAMBDA (SNARK-USER::X SNARK-USER::Y)
;                    (AND (SNARK-USER::PROOF-LINE-HINT (FIFTH SNARK-USER::X))
;                         (NOT (SNARK-USER::PROOF-LINE-HINT #)))))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (OR VECTOR CONS NULL).

; compiling (DEFUN SELECTED-LINES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN SELECTED-LINES
;     (MEMBER (SNARK-USER::PROOF-LINE-NUMBER SNARK-USER::LINE) SNARK-USER::NUMS)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN CODER-DEFAULT-SYMBOL-ORDERING ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN CODER-DEFAULT-SYMBOL-ORDERING
;     (> SNARK-USER::X SNARK-USER::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN FORWARD-SUBSUMED? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN FORWARD-SUBSUMED?
;     (>= SNARK-USER::NEW-WFF-SIZE (SNARK-USER::PROOF-LINE-WFF-SIZE SNARK-USER::L))
; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET > IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN BACKWARD-SUBSUMES? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN BACKWARD-SUBSUMES?
;     (<= SNARK-USER::NEW-WFF-SIZE (SNARK-USER::PROOF-LINE-WFF-SIZE SNARK-USER::L))
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: unable to open code because: The operands might not be the same type.

; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-= (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a REAL, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.

; compiling (DEFUN DO-CD ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN DO-CD
;     (< SNARK-USER::*CODER-MAXIMUM-TARGET-SIZE* SNARK-USER::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (< SNARK-USER::*CODER-TERM-SIZE-LIMIT* SNARK-USER::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (LENGTH (SNARK::VARIABLES SNARK-USER::X2 SUBST))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (< SNARK-USER::*CODER-TERM-VARS-LIMIT*
;        (LENGTH (SNARK::VARIABLES SNARK-USER::X2 SUBST)))
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (< SNARK-USER::*CODER-MAXIMUM-TERM-SIZE-FOUND* SNARK-USER::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.

;     (FUNCALL FUNCTION SNARK-USER::X2* SNARK-USER::N SNARK-USER::CUT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN FUNCTION)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (< SNARK-USER::*CODER-MAXIMUM-TARGET-SIZE* SNARK-USER::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK-USER::*CODER-TERM-SIZE-LIMIT* SNARK-USER::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

;     (< SNARK-USER::*CODER-TERM-VARS-LIMIT*
;        (LENGTH (SNARK::VARIABLES SNARK-USER::X2 SUBST)))
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.

;     (< SNARK-USER::*CODER-MAXIMUM-TERM-SIZE-FOUND* SNARK-USER::N)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       etc.

; compiling (DEFUN JUST-LINE-NUMBER ...)
; compiling (DEFUN JUST-LIST ...)
; compiling (DEFUN PRINT-PROOF-LINE-JUST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN PRINT-PROOF-LINE-JUST
;     (EQL SNARK-USER::N SNARK-USER::J)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       unable to do inline float comparison (cost 4) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       etc.

; compiling (DEFUN PRINT-PROOF-LINE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN PRINT-PROOF-LINE
;     (LENGTH (SNARK::VARIABLES (SNARK-USER::PROOF-LINE-WFF SNARK-USER::LINE)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN PRINT-PROOF-LINES ...)
; compiling (DEFUN PRINT-PROOF ...)
; compiling (DEFUN CODER-STATE ...)
; compiling (DEFUN PRINT-CODER-STATE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN PRINT-CODER-STATE
;     (SUBSEQ (SNARK-LISP:PRINT-CURRENT-TIME NIL T) 4 13)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a SB-KERNEL:EXTENDED-SEQUENCE.

;     (- (GET-INTERNAL-RUN-TIME) SNARK-USER::*CODER-START-TIME*)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFVAR *INPUT-TARGET-ALIST*)
; compiling (DEFUN INPUT-TARGET ...)
; compiling (DEFUN TOGETHER-TARGET? ...)
; compiling (DEFUN CONTAINS-TEST-TARGET? ...)
; compiling (DEFUN WRAP2 ...)
; compiling (DEFUN CODER-INPUT-TERM ...)
; compiling (DEFUN INPUT-TOGETHER-TARGET ...)
; compiling (DEFUN INPUT-NORMAL-TARGET ...)
; compiling (DEFUN INPUT-SINGLE-TARGET ...)
; compiling (DEFUN TARGET? ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN TARGET?
;     (FUNCALL (SECOND SNARK-USER::TARGET) SNARK-USER::X)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (SECOND SNARK-USER::TARGET))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (ADJOIN SNARK-USER::TARGET SNARK-USER::L)
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN REMOVE-TARGET ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN REMOVE-TARGET
;     (MEMBER SNARK-USER::TARGET SNARK-USER::L)
; ==>
;   (SB-KERNEL:%MEMBER SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN REMOVE-STEP-TO-USE ...)
; compiling (DEFUN PRINT-PROOF-FOR-OTTER-VERIFICATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN PRINT-PROOF-FOR-OTTER-VERIFICATION
;     (STRING SNARK-USER::OP)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

; compiling (DEFUN PRINT-TERM-FOR-OTTER2 ...)
; compiling (DEFUN PRINT-TERM-FOR-OTTER ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN PRINT-TERM-FOR-OTTER
;     (STRING (SNARK:FUNCTION-NAME (SNARK:HEAD SNARK-USER::TERM)))
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (> 6 SNARK-USER::N)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (STRING SNARK-USER::TERM)
; 
; note: unable to optimize due to type uncertainty: The first argument is a (OR (VECTOR CHARACTER) (VECTOR NIL) BASE-STRING SYMBOL CHARACTER), not a SYMBOL.

;     (> 6 SNARK-USER::N)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

; compiling (DEFUN COMB ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN COMB
;     (/
;      (LET ((SNARK-USER::V 1))
;        (DOTIMES (SNARK-USER::I SNARK-USER::M) (SETF SNARK-USER::V #))
;        SNARK-USER::V)
;      (LET ((SNARK-USER::V 1))
;        (DOTIMES (SNARK-USER::I (- SNARK-USER::M 1)) (SETF SNARK-USER::V #))
;        SNARK-USER::V))
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a SINGLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to optimize due to type uncertainty: The first argument is a NUMBER, not a DOUBLE-FLOAT.The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to convert x/2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (* SNARK-USER::V (+ SNARK-USER::I 2))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.

;     (* SNARK-USER::V (- SNARK-USER::N SNARK-USER::I))
; 
; note: unable to convert x*2^k to shift due to type uncertainty: The first argument is a NUMBER, not a INTEGER.The second argument is a NUMBER, not a INTEGER.

;     (DOTIMES (SNARK-USER::I SNARK-USER::M)
;       (SETF SNARK-USER::V (* SNARK-USER::V (- SNARK-USER::N SNARK-USER::I))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (- SNARK-USER::N SNARK-USER::I)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a T, not a (SIGNED-BYTE 64).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (* SNARK-USER::V (- SNARK-USER::N SNARK-USER::I))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (DOTIMES (SNARK-USER::I SNARK-USER::M)
;       (SETF SNARK-USER::V (* SNARK-USER::V (- SNARK-USER::N SNARK-USER::I))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-USER::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-USER::M 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (DOTIMES (SNARK-USER::I (- SNARK-USER::M 1))
;       (SETF SNARK-USER::V (* SNARK-USER::V (+ SNARK-USER::I 2))))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

;     (+ SNARK-USER::I 2)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (* SNARK-USER::V (+ SNARK-USER::I 2))
; 
; note: forced to do GENERIC-* (cost 30)
;       unable to do inline fixnum arithmetic (cost 4) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The second argument is a (INTEGER 2), not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 64).
;       The second argument is a (INTEGER 2), not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DOTIMES (SNARK-USER::I (- SNARK-USER::M 1))
;       (SETF SNARK-USER::V (* SNARK-USER::V (+ SNARK-USER::I 2))))
; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-USER::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (/
;      (LET ((SNARK-USER::V 1))
;        (DOTIMES (SNARK-USER::I SNARK-USER::M) (SETF SNARK-USER::V #))
;        SNARK-USER::V)
;      (LET ((SNARK-USER::V 1))
;        (DOTIMES (SNARK-USER::I (- SNARK-USER::M 1)) (SETF SNARK-USER::V #))
;        SNARK-USER::V))
; 
; note: forced to do static-fun Two-arg-/ (cost 53)
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (COMPLEX SINGLE-FLOAT) &REST T).
;       unable to do inline float arithmetic (cost 12) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

; compiling (DEFUN SHORTEN-PROOF ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN SHORTEN-PROOF
;     (< SNARK-USER::TO COUNT)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (<= SNARK-USER::FROM COUNT)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (+ SNARK-USER::SKIP 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a NUMBER, not a RATIONAL.

;     (LENGTH SNARK:PROOF)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (> 0 SNARK-USER::I)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.

;     (<= SNARK-USER::FROM COUNT)
; --> OR LET IF OR THE = IF 
; ==>
;   (= SB-C::X SB-C::Y)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.
; 
; note: unable to open code because: The operands might not be the same type.

;     (INCF COUNT)
; --> SETQ THE 
; ==>
;   (+ 1 COUNT)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (< SNARK-USER::TO COUNT)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

;     (<= SNARK-USER::FROM COUNT)
; --> OR LET < IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.

;     (- SNARK-USER::NSTEPS SNARK-USER::DROP)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (- SNARK-USER::NSTEPS SNARK-USER::SHORTEN-BY)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The second argument is a T, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The second argument is a T, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (+ SNARK-USER::SKIP 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-USER::PROOF-LENGTH SNARK-USER::NAXIOMS)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (> 0 SNARK-USER::I)
; --> < IF 
; ==>
;   (< SB-C::Y SB-C::X)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a T, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       etc.

;     (+ SNARK-USER::PROOF-LENGTH SNARK-USER::I)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a REAL, not a (SIGNED-BYTE 64).
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

;     (DOTIMES (SNARK-USER::I SNARK-USER::NAXIOMS)
;       (DECLARE (IGNORABLE SNARK-USER::I))
;       (PUSH (POP SNARK-USER::L) SNARK-USER::SOURCE))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-USER::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

;     (- SNARK-USER::LEN SNARK-USER::DROP)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The second argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 64) arithmetic (cost 5) because:
;       The second argument is a T, not a (SIGNED-BYTE 64).
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       etc.

; compiling (DEFUN STRIP-ORS ...)
; compiling (DEFUN CONDENSED-DETACHMENT-RULE-P ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.lisp
; in: DEFUN CONDENSED-DETACHMENT-RULE-P
;     (LENGTH SNARK-USER::L)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

; compiling (DEFUN CONDENSED-DETACHMENT-PROBLEM-P ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/coder.fasl written
; compilation finished in 0:00:00.358
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/overbeek-test.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN OVERBEEK-TEST ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/overbeek-test.lisp
; in: DEFUN OVERBEEK-TEST
;     (FUNCALL (PRINT (FOURTH SNARK-USER::X)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (PRINT (FOURTH SNARK-USER::X)))
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

;     (INCF SNARK-USER::TOTAL-SECONDS SNARK-LISP::*TOTAL-SECONDS*)
; --> SETQ THE 
; ==>
;   (+ SNARK-LISP::*TOTAL-SECONDS* SNARK-USER::TOTAL-SECONDS)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES DOUBLE-FLOAT &REST T).
;       unable to do inline float arithmetic (cost 2) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES SINGLE-FLOAT &REST T).
;       etc.

;     (ROUND SNARK-USER::TOTAL-SECONDS)
; --> ROUND LET 
; ==>
;   (SB-KERNEL:%UNARY-ROUND SB-C::X)
; 
; note: forced to do full call
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a NUMBER, not a SINGLE-FLOAT.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).
;       unable to do inline float truncate (cost 5) because:
;       The first argument is a NUMBER, not a DOUBLE-FLOAT.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES (SIGNED-BYTE 64) &REST T).

; compiling (DEFUN REFUTE-SNARK-EXAMPLE-FILE ...)
; compiling (DEFUN OVERBEEK1 ...)
; compiling (DEFUN OVERBEEK2 ...)
; compiling (DEFUN OVERBEEK3 ...)
; compiling (DEFUN OVERBEEK4 ...)
; compiling (DEFUN OVERBEEK5 ...)
; compiling (DEFUN OVERBEEK6 ...)
; compiling (DEFUN OVERBEEK7 ...)
; compiling (DEFUN OVERBEEK4-1 ...)
; compiling (DEFUN OVERBEEK5-1 ...)
; compiling (DEFUN OVERBEEK6-1 ...)
; compiling (DEFUN OVERBEEK7-1 ...)
; compiling (DEFUN OVERBEEK1E ...)
; compiling (DEFUN OVERBEEK2E ...)
; compiling (DEFUN OVERBEEK3E ...)
; compiling (DEFUN OVERBEEK4E ...)
; compiling (DEFUN OVERBEEK5E ...)
; compiling (DEFUN OVERBEEK6E ...)
; compiling (DEFUN OVERBEEK7E ...)
; compiling (DEFUN OVERBEEK7E-1 ...)
; compiling (DEFUN OVERBEEK8E ...)
; compiling (DEFUN OVERBEEK9E ...)
; compiling (DEFUN OVERBEEK10E ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/overbeek-test.fasl written
; compilation finished in 0:00:00.048
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/front-last-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN FRONT-LAST-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/front-last-example.fasl written
; compilation finished in 0:00:00.004
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/steamroller-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN STEAMROLLER-EXAMPLE0 ...)
; compiling (DEFUN STEAMROLLER-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/steamroller-example.fasl written
; compilation finished in 0:00:00.003
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/reverse-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN REVERSE-EXAMPLE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/reverse-example.lisp
; in: DEFUN REVERSE-EXAMPLE
;     (DOTIMES (SNARK-USER::I LENGTH) (PUSH SNARK-USER::I SNARK-USER::L))
; --> DO BLOCK LET TAGBODY UNLESS IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The second argument is a INTEGER, not a FIXNUM.

; --> DO BLOCK LET TAGBODY PSETQ PROGN SETQ THE 1+ 
; ==>
;   (+ SNARK-USER::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/reverse-example.fasl written
; compilation finished in 0:00:00.007
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN ROW-PREDICATE-NAMES ...)
; compiling (DEFUN ROW-RELATION-NAMES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.lisp
; in: DEFUN ROW-RELATION-NAMES
;     (PUSHNEW (SNARK:FUNCTION-NAME (SNARK:HEAD ATOM)) SNARK-USER::NAMES)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (PUSHNEW (SNARK:CONSTANT-NAME ATOM) SNARK-USER::NAMES)
; --> LET* SETQ THE ADJOIN 
; ==>
;   (SB-KERNEL:%ADJOIN SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

; compiling (DEFUN PARTITION-COMMUNICATION ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.lisp
; in: DEFUN PARTITION-COMMUNICATION
;     (ASSOC SNARK-USER::PART2 SNARK-USER::CONTEXT)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (ASSOC SNARK-USER::PART2 SNARK-USER::MORE-CONTEXT)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to optimize due to type uncertainty: can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (FLET ((SNARK-USER::MESSAGE-PASSING-FROM (SNARK-USER::X)
;              (SNARK-LISP:PROG->
;                (CAR SNARK-USER::X SNARK-USER::-> SNARK-USER::PART1)
;                (SNARK-SPARSE-ARRAY:SPARSE-MATRIX-ROW SNARK-USER::TABLE
;                                                      SNARK-USER::PART1
;                                                      SNARK-USER::->NONNIL
;                                                      SNARK:ROW)
;                (CDR SNARK-USER::X SNARK-USER::-> SNARK-USER::CTXT1)
;                (SNARK-SPARSE-ARRAY:MAP-SPARSE-VECTOR-WITH-INDEXES SNARK:ROW
;                                                                   SNARK-USER::->*
;                                                                   SNARK-USER::PREDS2
;                                                                   SNARK-USER::PART2)
;                (WHEN # # NIL))))
;       (MAPC #'SNARK-USER::MESSAGE-PASSING-FROM SNARK-USER::CONTEXT)
;       (DO ()
;           ((NULL SNARK-USER::MORE-CONTEXT))
;         (PUSH (POP SNARK-USER::MORE-CONTEXT) SNARK-USER::CONTEXT)
;         (SNARK-USER::MESSAGE-PASSING-FROM (FIRST SNARK-USER::CONTEXT)))
;       (SETF (SNARK::ROW-CONTEXT SNARK:ROW) SNARK-USER::CONTEXT))
; 
; note: Return type not fixed values, so can't use known return convention:
;   *

; compiling (DEFUN HOT-DRINK-EXAMPLE ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/hot-drink-example.fasl written
; compilation finished in 0:00:00.023
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/coder-examples.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN CODER-TEST ...)
; compiling (DEFUN CODER-XCB-REFLEX ...)
; compiling (DEFUN CODER-OVERBEEK6 ...)
; compiling (DEFUN CODER-OVERBEEK4 ...)
; compiling (DEFUN CODER-YCL-RST ...)
; compiling (DEFUN CODER-YCL-RST-TOGETHER ...)
; compiling (DEFUN CODER-VEROFF-5-2 ...)
; compiling (DEFUN CODER-VEROFF-4-1 ...)
; compiling (DEFUN II-SCHEMA ...)
; compiling (DEFUN ID-SCHEMA ...)
; compiling (DEFUN CR-SCHEMA1 ...)
; compiling (DEFUN CR-SCHEMA2 ...)
; compiling (DEFUN EQ-SCHEMA1 ...)
; compiling (DEFUN EQ-SCHEMA2 ...)
; compiling (DEFUN EQ-SCHEMA3 ...)
; compiling (DEFUN OR-SCHEMA ...)
; compiling (DEFUN AND-SCHEMA ...)
; compiling (DEFUN ALT-AND-SCHEMA ...)
; compiling (DEFUN CODER-EX1 ...)
; compiling (DEFUN CODER-EX2 ...)
; compiling (DEFUN CODER-EX3 ...)
; compiling (DEFUN CODER-EX4 ...)
; compiling (DEFUN CODER-EX5 ...)
; compiling (DEFUN CODER-EX6 ...)
; compiling (DEFUN CODER-EX6A ...)
; compiling (DEFUN CODER-EX6B ...)
; compiling (DEFUN CODER-EX7A ...)
; compiling (DEFUN CODER-EX7B ...)
; compiling (DEFUN CODER-EX8 ...)
; compiling (DEFUN CODER-EX9 ...)
; compiling (DEFUN CODER-EX10 ...)
; compiling (DEFUN CODER-EX11 ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/coder-examples.fasl written
; compilation finished in 0:00:00.054
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK-USER)
; compiling (DEFUN LATIN-SQUARE-CLAUSES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp
; in: DEFUN LATIN-SQUARE-CLAUSES
;     (- SNARK-USER::ORDER 1)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a T, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN MODEL-TO-LATIN-SQUARE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp
; in: DEFUN MODEL-TO-LATIN-SQUARE
;     (+ SNARK-USER::N 1)
; 
; note: unable to associate +/+ of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.
; 
; note: unable to associate +/- of constants due to type uncertainty: The first argument is a REAL, not a RATIONAL.

;     (AREF (AREF SNARK-USER::LS SNARK-USER::I) SNARK-USER::J)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF/CHECK-BOUNDS ARRAY SB-INT:INDEX)
; 
; note: unable to optimize because: Upgraded element type of array is not known at compile time.

;     (SETF (AREF (AREF SNARK-USER::LS SNARK-USER::I) SNARK-USER::J) SNARK-USER::K)
; --> LET* FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET/CHECK-BOUNDS ARRAY SB-INT:INDEX
;                                                 SB-C::NEW-VALUE)
; 
; note: unable to optimize because: Upgraded element type of array is not known at compile time.

;     (> SNARK-USER::K SNARK-USER::N)
; 
; note: unable to open-code FLOAT to RATIONAL comparison due to type uncertainty: The first argument is a REAL, not a FLOAT.The second argument is a REAL, not a RATIONAL.
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a SINGLE-FLOAT.
;       The second argument is a REAL, not a SINGLE-FLOAT.
;       unable to do inline float comparison (cost 3) because:
;       The first argument is a T, not a DOUBLE-FLOAT.
;       The second argument is a REAL, not a DOUBLE-FLOAT.
;       etc.

;     (+ SNARK-USER::N 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a REAL, not a FIXNUM.
;       The result is a (VALUES REAL &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.

; compiling (DEFUN GENERATE-LATIN-SQUARES ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp
; in: DEFUN GENERATE-LATIN-SQUARES
;     (FUNCALL APPLY
;              (SNARK-USER::MODEL-TO-LATIN-SQUARE SNARK-USER::MODEL
;                                                 SNARK-USER::ORDER))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN APPLY)
; 
; note: unable to optimize away possible call to FDEFINITION at runtime because: not known to be a function

; compiling (DEFUN PRINT-LATIN-SQUARE ...)
; compiling (DEFUN LATIN-SQUARE-CONJUGATE ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp
; in: DEFUN LATIN-SQUARE-CONJUGATE
;     (LENGTH SNARK-USER::LS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (ELT SNARK-USER::LS SNARK-USER::I)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (ELT (ELT SNARK-USER::LS SNARK-USER::I) SNARK-USER::J)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::I) SNARK-USER::K) SNARK-USER::J)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::I) SNARK-USER::K
;                      SNARK-USER::J)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::J) SNARK-USER::I) SNARK-USER::K)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::J) SNARK-USER::I
;                      SNARK-USER::K)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::J) SNARK-USER::K) SNARK-USER::I)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::J) SNARK-USER::K
;                      SNARK-USER::I)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::K) SNARK-USER::I) SNARK-USER::J)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::K) SNARK-USER::I
;                      SNARK-USER::J)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::K) SNARK-USER::J) SNARK-USER::I)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::K) SNARK-USER::J
;                      SNARK-USER::I)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (SETF (ELT (ELT SNARK-USER::LS* SNARK-USER::I) SNARK-USER::J) SNARK-USER::K)
; ==>
;   (SB-KERNEL:%SETELT (ELT SNARK-USER::LS* SNARK-USER::I) SNARK-USER::J
;                      SNARK-USER::K)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

; compiling (DEFUN LATIN-SQUARE-STANDARD-FORM ...)
; file: /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.lisp
; in: DEFUN LATIN-SQUARE-STANDARD-FORM
;     (ELT SNARK-USER::X 0)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (LENGTH SNARK-USER::LS)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a VECTOR.

;     (ELT SNARK-USER::LS 0)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (ELT SNARK-USER::LS SNARK-USER::I)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (ELT SNARK-USER::ROWI SNARK-USER::J)
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.

;     (POSITION (ELT SNARK-USER::ROWI SNARK-USER::J) SNARK-USER::ROW0)
; 
; note: unable to optimize due to type uncertainty: The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (SETF (ELT SNARK-USER::ROWI* SNARK-USER::J)
;             (POSITION (ELT SNARK-USER::ROWI SNARK-USER::J) SNARK-USER::ROW0))
; ==>
;   (SB-KERNEL:%SETELT SNARK-USER::ROWI* SNARK-USER::J
;                      (POSITION (ELT SNARK-USER::ROWI SNARK-USER::J)
;                                SNARK-USER::ROW0))
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to optimize due to type uncertainty: The first argument is a SEQUENCE, not a LIST.


; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/examples/latin-squares.fasl written
; compilation finished in 0:00:00.065
; compiling file "/opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/patches.lisp" (written 27 APR 2018 07:51:29 PM):
; compiling (IN-PACKAGE :SNARK)
; compiling (DEFUN MAKE-INSTANCE-GRAPH ...)

; /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/src/patches.fasl written
; compilation finished in 0:00:00.002
; 
; compilation unit finished
;   caught 7 STYLE-WARNING conditions
;   printed 5102 notes
; Running SNARK from /opt/logicmoo_workspace/packs_usr/wam_common_lisp/t/snark/nilqed-SNARK/snark-system.lisp in SBCL 1.3.1.debian (64-bit) on gitlab at 2018-04-27T20:04:47
NIL
* 